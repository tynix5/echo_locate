
echo_locate.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002b2c  08000198  08000198  00001198  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b18  08002cc4  08002cc4  00003cc4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080037dc  080037dc  00005004  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  080037dc  080037dc  00005004  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  080037dc  080037dc  00005004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080037dc  080037dc  000047dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  080037e0  080037e0  000047e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000004  20000000  080037e4  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000016a8  20000004  080037e8  00005004  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200016ac  080037e8  000056ac  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00005004  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000858f  00000000  00000000  00005034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001c5c  00000000  00000000  0000d5c3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 000033ba  00000000  00000000  0000f21f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000004c0  00000000  00000000  000125e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000055f  00000000  00000000  00012aa0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00026bb9  00000000  00000000  00012fff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000c570  00000000  00000000  00039bb8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0008620d  00000000  00000000  00046128  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  000cc335  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000ccc  00000000  00000000  000cc378  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000070  00000000  00000000  000cd044  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000004 	.word	0x20000004
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08002cac 	.word	0x08002cac

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000008 	.word	0x20000008
 80001d4:	08002cac 	.word	0x08002cac

080001d8 <__aeabi_drsub>:
 80001d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80001dc:	e002      	b.n	80001e4 <__adddf3>
 80001de:	bf00      	nop

080001e0 <__aeabi_dsub>:
 80001e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080001e4 <__adddf3>:
 80001e4:	b530      	push	{r4, r5, lr}
 80001e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80001ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80001ee:	ea94 0f05 	teq	r4, r5
 80001f2:	bf08      	it	eq
 80001f4:	ea90 0f02 	teqeq	r0, r2
 80001f8:	bf1f      	itttt	ne
 80001fa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80001fe:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000202:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000206:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800020a:	f000 80e2 	beq.w	80003d2 <__adddf3+0x1ee>
 800020e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000212:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000216:	bfb8      	it	lt
 8000218:	426d      	neglt	r5, r5
 800021a:	dd0c      	ble.n	8000236 <__adddf3+0x52>
 800021c:	442c      	add	r4, r5
 800021e:	ea80 0202 	eor.w	r2, r0, r2
 8000222:	ea81 0303 	eor.w	r3, r1, r3
 8000226:	ea82 0000 	eor.w	r0, r2, r0
 800022a:	ea83 0101 	eor.w	r1, r3, r1
 800022e:	ea80 0202 	eor.w	r2, r0, r2
 8000232:	ea81 0303 	eor.w	r3, r1, r3
 8000236:	2d36      	cmp	r5, #54	@ 0x36
 8000238:	bf88      	it	hi
 800023a:	bd30      	pophi	{r4, r5, pc}
 800023c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000240:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000244:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000248:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800024c:	d002      	beq.n	8000254 <__adddf3+0x70>
 800024e:	4240      	negs	r0, r0
 8000250:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000254:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000258:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800025c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000260:	d002      	beq.n	8000268 <__adddf3+0x84>
 8000262:	4252      	negs	r2, r2
 8000264:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000268:	ea94 0f05 	teq	r4, r5
 800026c:	f000 80a7 	beq.w	80003be <__adddf3+0x1da>
 8000270:	f1a4 0401 	sub.w	r4, r4, #1
 8000274:	f1d5 0e20 	rsbs	lr, r5, #32
 8000278:	db0d      	blt.n	8000296 <__adddf3+0xb2>
 800027a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800027e:	fa22 f205 	lsr.w	r2, r2, r5
 8000282:	1880      	adds	r0, r0, r2
 8000284:	f141 0100 	adc.w	r1, r1, #0
 8000288:	fa03 f20e 	lsl.w	r2, r3, lr
 800028c:	1880      	adds	r0, r0, r2
 800028e:	fa43 f305 	asr.w	r3, r3, r5
 8000292:	4159      	adcs	r1, r3
 8000294:	e00e      	b.n	80002b4 <__adddf3+0xd0>
 8000296:	f1a5 0520 	sub.w	r5, r5, #32
 800029a:	f10e 0e20 	add.w	lr, lr, #32
 800029e:	2a01      	cmp	r2, #1
 80002a0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002a4:	bf28      	it	cs
 80002a6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002aa:	fa43 f305 	asr.w	r3, r3, r5
 80002ae:	18c0      	adds	r0, r0, r3
 80002b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80002b8:	d507      	bpl.n	80002ca <__adddf3+0xe6>
 80002ba:	f04f 0e00 	mov.w	lr, #0
 80002be:	f1dc 0c00 	rsbs	ip, ip, #0
 80002c2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002c6:	eb6e 0101 	sbc.w	r1, lr, r1
 80002ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80002ce:	d31b      	bcc.n	8000308 <__adddf3+0x124>
 80002d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80002d4:	d30c      	bcc.n	80002f0 <__adddf3+0x10c>
 80002d6:	0849      	lsrs	r1, r1, #1
 80002d8:	ea5f 0030 	movs.w	r0, r0, rrx
 80002dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80002e0:	f104 0401 	add.w	r4, r4, #1
 80002e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80002e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80002ec:	f080 809a 	bcs.w	8000424 <__adddf3+0x240>
 80002f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80002f4:	bf08      	it	eq
 80002f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80002fa:	f150 0000 	adcs.w	r0, r0, #0
 80002fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000302:	ea41 0105 	orr.w	r1, r1, r5
 8000306:	bd30      	pop	{r4, r5, pc}
 8000308:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800030c:	4140      	adcs	r0, r0
 800030e:	eb41 0101 	adc.w	r1, r1, r1
 8000312:	3c01      	subs	r4, #1
 8000314:	bf28      	it	cs
 8000316:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800031a:	d2e9      	bcs.n	80002f0 <__adddf3+0x10c>
 800031c:	f091 0f00 	teq	r1, #0
 8000320:	bf04      	itt	eq
 8000322:	4601      	moveq	r1, r0
 8000324:	2000      	moveq	r0, #0
 8000326:	fab1 f381 	clz	r3, r1
 800032a:	bf08      	it	eq
 800032c:	3320      	addeq	r3, #32
 800032e:	f1a3 030b 	sub.w	r3, r3, #11
 8000332:	f1b3 0220 	subs.w	r2, r3, #32
 8000336:	da0c      	bge.n	8000352 <__adddf3+0x16e>
 8000338:	320c      	adds	r2, #12
 800033a:	dd08      	ble.n	800034e <__adddf3+0x16a>
 800033c:	f102 0c14 	add.w	ip, r2, #20
 8000340:	f1c2 020c 	rsb	r2, r2, #12
 8000344:	fa01 f00c 	lsl.w	r0, r1, ip
 8000348:	fa21 f102 	lsr.w	r1, r1, r2
 800034c:	e00c      	b.n	8000368 <__adddf3+0x184>
 800034e:	f102 0214 	add.w	r2, r2, #20
 8000352:	bfd8      	it	le
 8000354:	f1c2 0c20 	rsble	ip, r2, #32
 8000358:	fa01 f102 	lsl.w	r1, r1, r2
 800035c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000360:	bfdc      	itt	le
 8000362:	ea41 010c 	orrle.w	r1, r1, ip
 8000366:	4090      	lslle	r0, r2
 8000368:	1ae4      	subs	r4, r4, r3
 800036a:	bfa2      	ittt	ge
 800036c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000370:	4329      	orrge	r1, r5
 8000372:	bd30      	popge	{r4, r5, pc}
 8000374:	ea6f 0404 	mvn.w	r4, r4
 8000378:	3c1f      	subs	r4, #31
 800037a:	da1c      	bge.n	80003b6 <__adddf3+0x1d2>
 800037c:	340c      	adds	r4, #12
 800037e:	dc0e      	bgt.n	800039e <__adddf3+0x1ba>
 8000380:	f104 0414 	add.w	r4, r4, #20
 8000384:	f1c4 0220 	rsb	r2, r4, #32
 8000388:	fa20 f004 	lsr.w	r0, r0, r4
 800038c:	fa01 f302 	lsl.w	r3, r1, r2
 8000390:	ea40 0003 	orr.w	r0, r0, r3
 8000394:	fa21 f304 	lsr.w	r3, r1, r4
 8000398:	ea45 0103 	orr.w	r1, r5, r3
 800039c:	bd30      	pop	{r4, r5, pc}
 800039e:	f1c4 040c 	rsb	r4, r4, #12
 80003a2:	f1c4 0220 	rsb	r2, r4, #32
 80003a6:	fa20 f002 	lsr.w	r0, r0, r2
 80003aa:	fa01 f304 	lsl.w	r3, r1, r4
 80003ae:	ea40 0003 	orr.w	r0, r0, r3
 80003b2:	4629      	mov	r1, r5
 80003b4:	bd30      	pop	{r4, r5, pc}
 80003b6:	fa21 f004 	lsr.w	r0, r1, r4
 80003ba:	4629      	mov	r1, r5
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	f094 0f00 	teq	r4, #0
 80003c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80003c6:	bf06      	itte	eq
 80003c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80003cc:	3401      	addeq	r4, #1
 80003ce:	3d01      	subne	r5, #1
 80003d0:	e74e      	b.n	8000270 <__adddf3+0x8c>
 80003d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003d6:	bf18      	it	ne
 80003d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003dc:	d029      	beq.n	8000432 <__adddf3+0x24e>
 80003de:	ea94 0f05 	teq	r4, r5
 80003e2:	bf08      	it	eq
 80003e4:	ea90 0f02 	teqeq	r0, r2
 80003e8:	d005      	beq.n	80003f6 <__adddf3+0x212>
 80003ea:	ea54 0c00 	orrs.w	ip, r4, r0
 80003ee:	bf04      	itt	eq
 80003f0:	4619      	moveq	r1, r3
 80003f2:	4610      	moveq	r0, r2
 80003f4:	bd30      	pop	{r4, r5, pc}
 80003f6:	ea91 0f03 	teq	r1, r3
 80003fa:	bf1e      	ittt	ne
 80003fc:	2100      	movne	r1, #0
 80003fe:	2000      	movne	r0, #0
 8000400:	bd30      	popne	{r4, r5, pc}
 8000402:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000406:	d105      	bne.n	8000414 <__adddf3+0x230>
 8000408:	0040      	lsls	r0, r0, #1
 800040a:	4149      	adcs	r1, r1
 800040c:	bf28      	it	cs
 800040e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000412:	bd30      	pop	{r4, r5, pc}
 8000414:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000418:	bf3c      	itt	cc
 800041a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 800041e:	bd30      	popcc	{r4, r5, pc}
 8000420:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000424:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000428:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800042c:	f04f 0000 	mov.w	r0, #0
 8000430:	bd30      	pop	{r4, r5, pc}
 8000432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000436:	bf1a      	itte	ne
 8000438:	4619      	movne	r1, r3
 800043a:	4610      	movne	r0, r2
 800043c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000440:	bf1c      	itt	ne
 8000442:	460b      	movne	r3, r1
 8000444:	4602      	movne	r2, r0
 8000446:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800044a:	bf06      	itte	eq
 800044c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000450:	ea91 0f03 	teqeq	r1, r3
 8000454:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000458:	bd30      	pop	{r4, r5, pc}
 800045a:	bf00      	nop

0800045c <__aeabi_ui2d>:
 800045c:	f090 0f00 	teq	r0, #0
 8000460:	bf04      	itt	eq
 8000462:	2100      	moveq	r1, #0
 8000464:	4770      	bxeq	lr
 8000466:	b530      	push	{r4, r5, lr}
 8000468:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800046c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000470:	f04f 0500 	mov.w	r5, #0
 8000474:	f04f 0100 	mov.w	r1, #0
 8000478:	e750      	b.n	800031c <__adddf3+0x138>
 800047a:	bf00      	nop

0800047c <__aeabi_i2d>:
 800047c:	f090 0f00 	teq	r0, #0
 8000480:	bf04      	itt	eq
 8000482:	2100      	moveq	r1, #0
 8000484:	4770      	bxeq	lr
 8000486:	b530      	push	{r4, r5, lr}
 8000488:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800048c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000490:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000494:	bf48      	it	mi
 8000496:	4240      	negmi	r0, r0
 8000498:	f04f 0100 	mov.w	r1, #0
 800049c:	e73e      	b.n	800031c <__adddf3+0x138>
 800049e:	bf00      	nop

080004a0 <__aeabi_f2d>:
 80004a0:	0042      	lsls	r2, r0, #1
 80004a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004a6:	ea4f 0131 	mov.w	r1, r1, rrx
 80004aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ae:	bf1f      	itttt	ne
 80004b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80004b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80004b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80004bc:	4770      	bxne	lr
 80004be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80004c2:	bf08      	it	eq
 80004c4:	4770      	bxeq	lr
 80004c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80004ca:	bf04      	itt	eq
 80004cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80004d0:	4770      	bxeq	lr
 80004d2:	b530      	push	{r4, r5, lr}
 80004d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80004e0:	e71c      	b.n	800031c <__adddf3+0x138>
 80004e2:	bf00      	nop

080004e4 <__aeabi_ul2d>:
 80004e4:	ea50 0201 	orrs.w	r2, r0, r1
 80004e8:	bf08      	it	eq
 80004ea:	4770      	bxeq	lr
 80004ec:	b530      	push	{r4, r5, lr}
 80004ee:	f04f 0500 	mov.w	r5, #0
 80004f2:	e00a      	b.n	800050a <__aeabi_l2d+0x16>

080004f4 <__aeabi_l2d>:
 80004f4:	ea50 0201 	orrs.w	r2, r0, r1
 80004f8:	bf08      	it	eq
 80004fa:	4770      	bxeq	lr
 80004fc:	b530      	push	{r4, r5, lr}
 80004fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000502:	d502      	bpl.n	800050a <__aeabi_l2d+0x16>
 8000504:	4240      	negs	r0, r0
 8000506:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800050a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800050e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000512:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000516:	f43f aed8 	beq.w	80002ca <__adddf3+0xe6>
 800051a:	f04f 0203 	mov.w	r2, #3
 800051e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000522:	bf18      	it	ne
 8000524:	3203      	addne	r2, #3
 8000526:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800052a:	bf18      	it	ne
 800052c:	3203      	addne	r2, #3
 800052e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000532:	f1c2 0320 	rsb	r3, r2, #32
 8000536:	fa00 fc03 	lsl.w	ip, r0, r3
 800053a:	fa20 f002 	lsr.w	r0, r0, r2
 800053e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000542:	ea40 000e 	orr.w	r0, r0, lr
 8000546:	fa21 f102 	lsr.w	r1, r1, r2
 800054a:	4414      	add	r4, r2
 800054c:	e6bd      	b.n	80002ca <__adddf3+0xe6>
 800054e:	bf00      	nop

08000550 <__aeabi_dmul>:
 8000550:	b570      	push	{r4, r5, r6, lr}
 8000552:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000556:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 800055a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800055e:	bf1d      	ittte	ne
 8000560:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000564:	ea94 0f0c 	teqne	r4, ip
 8000568:	ea95 0f0c 	teqne	r5, ip
 800056c:	f000 f8de 	bleq	800072c <__aeabi_dmul+0x1dc>
 8000570:	442c      	add	r4, r5
 8000572:	ea81 0603 	eor.w	r6, r1, r3
 8000576:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800057a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800057e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000582:	bf18      	it	ne
 8000584:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000588:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 800058c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000590:	d038      	beq.n	8000604 <__aeabi_dmul+0xb4>
 8000592:	fba0 ce02 	umull	ip, lr, r0, r2
 8000596:	f04f 0500 	mov.w	r5, #0
 800059a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800059e:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 80005a2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005a6:	f04f 0600 	mov.w	r6, #0
 80005aa:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ae:	f09c 0f00 	teq	ip, #0
 80005b2:	bf18      	it	ne
 80005b4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005b8:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 80005bc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 80005c0:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 80005c4:	d204      	bcs.n	80005d0 <__aeabi_dmul+0x80>
 80005c6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ca:	416d      	adcs	r5, r5
 80005cc:	eb46 0606 	adc.w	r6, r6, r6
 80005d0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005d4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005d8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005dc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80005e0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80005e4:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80005e8:	bf88      	it	hi
 80005ea:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80005ee:	d81e      	bhi.n	800062e <__aeabi_dmul+0xde>
 80005f0:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80005f4:	bf08      	it	eq
 80005f6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80005fa:	f150 0000 	adcs.w	r0, r0, #0
 80005fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000602:	bd70      	pop	{r4, r5, r6, pc}
 8000604:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8000608:	ea46 0101 	orr.w	r1, r6, r1
 800060c:	ea40 0002 	orr.w	r0, r0, r2
 8000610:	ea81 0103 	eor.w	r1, r1, r3
 8000614:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000618:	bfc2      	ittt	gt
 800061a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800061e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000622:	bd70      	popgt	{r4, r5, r6, pc}
 8000624:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000628:	f04f 0e00 	mov.w	lr, #0
 800062c:	3c01      	subs	r4, #1
 800062e:	f300 80ab 	bgt.w	8000788 <__aeabi_dmul+0x238>
 8000632:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 8000636:	bfde      	ittt	le
 8000638:	2000      	movle	r0, #0
 800063a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 800063e:	bd70      	pople	{r4, r5, r6, pc}
 8000640:	f1c4 0400 	rsb	r4, r4, #0
 8000644:	3c20      	subs	r4, #32
 8000646:	da35      	bge.n	80006b4 <__aeabi_dmul+0x164>
 8000648:	340c      	adds	r4, #12
 800064a:	dc1b      	bgt.n	8000684 <__aeabi_dmul+0x134>
 800064c:	f104 0414 	add.w	r4, r4, #20
 8000650:	f1c4 0520 	rsb	r5, r4, #32
 8000654:	fa00 f305 	lsl.w	r3, r0, r5
 8000658:	fa20 f004 	lsr.w	r0, r0, r4
 800065c:	fa01 f205 	lsl.w	r2, r1, r5
 8000660:	ea40 0002 	orr.w	r0, r0, r2
 8000664:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000668:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800066c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000670:	fa21 f604 	lsr.w	r6, r1, r4
 8000674:	eb42 0106 	adc.w	r1, r2, r6
 8000678:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800067c:	bf08      	it	eq
 800067e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f1c4 040c 	rsb	r4, r4, #12
 8000688:	f1c4 0520 	rsb	r5, r4, #32
 800068c:	fa00 f304 	lsl.w	r3, r0, r4
 8000690:	fa20 f005 	lsr.w	r0, r0, r5
 8000694:	fa01 f204 	lsl.w	r2, r1, r4
 8000698:	ea40 0002 	orr.w	r0, r0, r2
 800069c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006a0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006a4:	f141 0100 	adc.w	r1, r1, #0
 80006a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006ac:	bf08      	it	eq
 80006ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006b2:	bd70      	pop	{r4, r5, r6, pc}
 80006b4:	f1c4 0520 	rsb	r5, r4, #32
 80006b8:	fa00 f205 	lsl.w	r2, r0, r5
 80006bc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006c0:	fa20 f304 	lsr.w	r3, r0, r4
 80006c4:	fa01 f205 	lsl.w	r2, r1, r5
 80006c8:	ea43 0302 	orr.w	r3, r3, r2
 80006cc:	fa21 f004 	lsr.w	r0, r1, r4
 80006d0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006d4:	fa21 f204 	lsr.w	r2, r1, r4
 80006d8:	ea20 0002 	bic.w	r0, r0, r2
 80006dc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80006e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006e4:	bf08      	it	eq
 80006e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f094 0f00 	teq	r4, #0
 80006f0:	d10f      	bne.n	8000712 <__aeabi_dmul+0x1c2>
 80006f2:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80006f6:	0040      	lsls	r0, r0, #1
 80006f8:	eb41 0101 	adc.w	r1, r1, r1
 80006fc:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000700:	bf08      	it	eq
 8000702:	3c01      	subeq	r4, #1
 8000704:	d0f7      	beq.n	80006f6 <__aeabi_dmul+0x1a6>
 8000706:	ea41 0106 	orr.w	r1, r1, r6
 800070a:	f095 0f00 	teq	r5, #0
 800070e:	bf18      	it	ne
 8000710:	4770      	bxne	lr
 8000712:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 8000716:	0052      	lsls	r2, r2, #1
 8000718:	eb43 0303 	adc.w	r3, r3, r3
 800071c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8000720:	bf08      	it	eq
 8000722:	3d01      	subeq	r5, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1c6>
 8000726:	ea43 0306 	orr.w	r3, r3, r6
 800072a:	4770      	bx	lr
 800072c:	ea94 0f0c 	teq	r4, ip
 8000730:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000734:	bf18      	it	ne
 8000736:	ea95 0f0c 	teqne	r5, ip
 800073a:	d00c      	beq.n	8000756 <__aeabi_dmul+0x206>
 800073c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000740:	bf18      	it	ne
 8000742:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000746:	d1d1      	bne.n	80006ec <__aeabi_dmul+0x19c>
 8000748:	ea81 0103 	eor.w	r1, r1, r3
 800074c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000750:	f04f 0000 	mov.w	r0, #0
 8000754:	bd70      	pop	{r4, r5, r6, pc}
 8000756:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800075a:	bf06      	itte	eq
 800075c:	4610      	moveq	r0, r2
 800075e:	4619      	moveq	r1, r3
 8000760:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000764:	d019      	beq.n	800079a <__aeabi_dmul+0x24a>
 8000766:	ea94 0f0c 	teq	r4, ip
 800076a:	d102      	bne.n	8000772 <__aeabi_dmul+0x222>
 800076c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000770:	d113      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000772:	ea95 0f0c 	teq	r5, ip
 8000776:	d105      	bne.n	8000784 <__aeabi_dmul+0x234>
 8000778:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800077c:	bf1c      	itt	ne
 800077e:	4610      	movne	r0, r2
 8000780:	4619      	movne	r1, r3
 8000782:	d10a      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000784:	ea81 0103 	eor.w	r1, r1, r3
 8000788:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800078c:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000790:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000794:	f04f 0000 	mov.w	r0, #0
 8000798:	bd70      	pop	{r4, r5, r6, pc}
 800079a:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 800079e:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 80007a2:	bd70      	pop	{r4, r5, r6, pc}

080007a4 <__aeabi_ddiv>:
 80007a4:	b570      	push	{r4, r5, r6, lr}
 80007a6:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80007aa:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80007ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007b2:	bf1d      	ittte	ne
 80007b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007b8:	ea94 0f0c 	teqne	r4, ip
 80007bc:	ea95 0f0c 	teqne	r5, ip
 80007c0:	f000 f8a7 	bleq	8000912 <__aeabi_ddiv+0x16e>
 80007c4:	eba4 0405 	sub.w	r4, r4, r5
 80007c8:	ea81 0e03 	eor.w	lr, r1, r3
 80007cc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007d4:	f000 8088 	beq.w	80008e8 <__aeabi_ddiv+0x144>
 80007d8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007dc:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 80007e0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80007e4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80007e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80007ec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80007f0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80007f4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80007f8:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80007fc:	429d      	cmp	r5, r3
 80007fe:	bf08      	it	eq
 8000800:	4296      	cmpeq	r6, r2
 8000802:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 8000806:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 800080a:	d202      	bcs.n	8000812 <__aeabi_ddiv+0x6e>
 800080c:	085b      	lsrs	r3, r3, #1
 800080e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000812:	1ab6      	subs	r6, r6, r2
 8000814:	eb65 0503 	sbc.w	r5, r5, r3
 8000818:	085b      	lsrs	r3, r3, #1
 800081a:	ea4f 0232 	mov.w	r2, r2, rrx
 800081e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8000822:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 8000826:	ebb6 0e02 	subs.w	lr, r6, r2
 800082a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800082e:	bf22      	ittt	cs
 8000830:	1ab6      	subcs	r6, r6, r2
 8000832:	4675      	movcs	r5, lr
 8000834:	ea40 000c 	orrcs.w	r0, r0, ip
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000842:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000846:	bf22      	ittt	cs
 8000848:	1ab6      	subcs	r6, r6, r2
 800084a:	4675      	movcs	r5, lr
 800084c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000850:	085b      	lsrs	r3, r3, #1
 8000852:	ea4f 0232 	mov.w	r2, r2, rrx
 8000856:	ebb6 0e02 	subs.w	lr, r6, r2
 800085a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800085e:	bf22      	ittt	cs
 8000860:	1ab6      	subcs	r6, r6, r2
 8000862:	4675      	movcs	r5, lr
 8000864:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000868:	085b      	lsrs	r3, r3, #1
 800086a:	ea4f 0232 	mov.w	r2, r2, rrx
 800086e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000872:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000876:	bf22      	ittt	cs
 8000878:	1ab6      	subcs	r6, r6, r2
 800087a:	4675      	movcs	r5, lr
 800087c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000880:	ea55 0e06 	orrs.w	lr, r5, r6
 8000884:	d018      	beq.n	80008b8 <__aeabi_ddiv+0x114>
 8000886:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800088a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800088e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000892:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000896:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800089a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800089e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008a2:	d1c0      	bne.n	8000826 <__aeabi_ddiv+0x82>
 80008a4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008a8:	d10b      	bne.n	80008c2 <__aeabi_ddiv+0x11e>
 80008aa:	ea41 0100 	orr.w	r1, r1, r0
 80008ae:	f04f 0000 	mov.w	r0, #0
 80008b2:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 80008b6:	e7b6      	b.n	8000826 <__aeabi_ddiv+0x82>
 80008b8:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008bc:	bf04      	itt	eq
 80008be:	4301      	orreq	r1, r0
 80008c0:	2000      	moveq	r0, #0
 80008c2:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80008c6:	bf88      	it	hi
 80008c8:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80008cc:	f63f aeaf 	bhi.w	800062e <__aeabi_dmul+0xde>
 80008d0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008d4:	bf04      	itt	eq
 80008d6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008de:	f150 0000 	adcs.w	r0, r0, #0
 80008e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80008e6:	bd70      	pop	{r4, r5, r6, pc}
 80008e8:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 80008ec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80008f0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80008f4:	bfc2      	ittt	gt
 80008f6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80008fa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80008fe:	bd70      	popgt	{r4, r5, r6, pc}
 8000900:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000904:	f04f 0e00 	mov.w	lr, #0
 8000908:	3c01      	subs	r4, #1
 800090a:	e690      	b.n	800062e <__aeabi_dmul+0xde>
 800090c:	ea45 0e06 	orr.w	lr, r5, r6
 8000910:	e68d      	b.n	800062e <__aeabi_dmul+0xde>
 8000912:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000916:	ea94 0f0c 	teq	r4, ip
 800091a:	bf08      	it	eq
 800091c:	ea95 0f0c 	teqeq	r5, ip
 8000920:	f43f af3b 	beq.w	800079a <__aeabi_dmul+0x24a>
 8000924:	ea94 0f0c 	teq	r4, ip
 8000928:	d10a      	bne.n	8000940 <__aeabi_ddiv+0x19c>
 800092a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800092e:	f47f af34 	bne.w	800079a <__aeabi_dmul+0x24a>
 8000932:	ea95 0f0c 	teq	r5, ip
 8000936:	f47f af25 	bne.w	8000784 <__aeabi_dmul+0x234>
 800093a:	4610      	mov	r0, r2
 800093c:	4619      	mov	r1, r3
 800093e:	e72c      	b.n	800079a <__aeabi_dmul+0x24a>
 8000940:	ea95 0f0c 	teq	r5, ip
 8000944:	d106      	bne.n	8000954 <__aeabi_ddiv+0x1b0>
 8000946:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800094a:	f43f aefd 	beq.w	8000748 <__aeabi_dmul+0x1f8>
 800094e:	4610      	mov	r0, r2
 8000950:	4619      	mov	r1, r3
 8000952:	e722      	b.n	800079a <__aeabi_dmul+0x24a>
 8000954:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000958:	bf18      	it	ne
 800095a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800095e:	f47f aec5 	bne.w	80006ec <__aeabi_dmul+0x19c>
 8000962:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000966:	f47f af0d 	bne.w	8000784 <__aeabi_dmul+0x234>
 800096a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800096e:	f47f aeeb 	bne.w	8000748 <__aeabi_dmul+0x1f8>
 8000972:	e712      	b.n	800079a <__aeabi_dmul+0x24a>

08000974 <__gedf2>:
 8000974:	f04f 3cff 	mov.w	ip, #4294967295
 8000978:	e006      	b.n	8000988 <__cmpdf2+0x4>
 800097a:	bf00      	nop

0800097c <__ledf2>:
 800097c:	f04f 0c01 	mov.w	ip, #1
 8000980:	e002      	b.n	8000988 <__cmpdf2+0x4>
 8000982:	bf00      	nop

08000984 <__cmpdf2>:
 8000984:	f04f 0c01 	mov.w	ip, #1
 8000988:	f84d cd04 	str.w	ip, [sp, #-4]!
 800098c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000990:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000994:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000998:	bf18      	it	ne
 800099a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800099e:	d01b      	beq.n	80009d8 <__cmpdf2+0x54>
 80009a0:	b001      	add	sp, #4
 80009a2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80009a6:	bf0c      	ite	eq
 80009a8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80009ac:	ea91 0f03 	teqne	r1, r3
 80009b0:	bf02      	ittt	eq
 80009b2:	ea90 0f02 	teqeq	r0, r2
 80009b6:	2000      	moveq	r0, #0
 80009b8:	4770      	bxeq	lr
 80009ba:	f110 0f00 	cmn.w	r0, #0
 80009be:	ea91 0f03 	teq	r1, r3
 80009c2:	bf58      	it	pl
 80009c4:	4299      	cmppl	r1, r3
 80009c6:	bf08      	it	eq
 80009c8:	4290      	cmpeq	r0, r2
 80009ca:	bf2c      	ite	cs
 80009cc:	17d8      	asrcs	r0, r3, #31
 80009ce:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80009d2:	f040 0001 	orr.w	r0, r0, #1
 80009d6:	4770      	bx	lr
 80009d8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80009dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009e0:	d102      	bne.n	80009e8 <__cmpdf2+0x64>
 80009e2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80009e6:	d107      	bne.n	80009f8 <__cmpdf2+0x74>
 80009e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80009ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009f0:	d1d6      	bne.n	80009a0 <__cmpdf2+0x1c>
 80009f2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80009f6:	d0d3      	beq.n	80009a0 <__cmpdf2+0x1c>
 80009f8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <__aeabi_cdrcmple>:
 8000a00:	4684      	mov	ip, r0
 8000a02:	4610      	mov	r0, r2
 8000a04:	4662      	mov	r2, ip
 8000a06:	468c      	mov	ip, r1
 8000a08:	4619      	mov	r1, r3
 8000a0a:	4663      	mov	r3, ip
 8000a0c:	e000      	b.n	8000a10 <__aeabi_cdcmpeq>
 8000a0e:	bf00      	nop

08000a10 <__aeabi_cdcmpeq>:
 8000a10:	b501      	push	{r0, lr}
 8000a12:	f7ff ffb7 	bl	8000984 <__cmpdf2>
 8000a16:	2800      	cmp	r0, #0
 8000a18:	bf48      	it	mi
 8000a1a:	f110 0f00 	cmnmi.w	r0, #0
 8000a1e:	bd01      	pop	{r0, pc}

08000a20 <__aeabi_dcmpeq>:
 8000a20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a24:	f7ff fff4 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a28:	bf0c      	ite	eq
 8000a2a:	2001      	moveq	r0, #1
 8000a2c:	2000      	movne	r0, #0
 8000a2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a32:	bf00      	nop

08000a34 <__aeabi_dcmplt>:
 8000a34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a38:	f7ff ffea 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a3c:	bf34      	ite	cc
 8000a3e:	2001      	movcc	r0, #1
 8000a40:	2000      	movcs	r0, #0
 8000a42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a46:	bf00      	nop

08000a48 <__aeabi_dcmple>:
 8000a48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a4c:	f7ff ffe0 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a50:	bf94      	ite	ls
 8000a52:	2001      	movls	r0, #1
 8000a54:	2000      	movhi	r0, #0
 8000a56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a5a:	bf00      	nop

08000a5c <__aeabi_dcmpge>:
 8000a5c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a60:	f7ff ffce 	bl	8000a00 <__aeabi_cdrcmple>
 8000a64:	bf94      	ite	ls
 8000a66:	2001      	movls	r0, #1
 8000a68:	2000      	movhi	r0, #0
 8000a6a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dcmpgt>:
 8000a70:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a74:	f7ff ffc4 	bl	8000a00 <__aeabi_cdrcmple>
 8000a78:	bf34      	ite	cc
 8000a7a:	2001      	movcc	r0, #1
 8000a7c:	2000      	movcs	r0, #0
 8000a7e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a82:	bf00      	nop

08000a84 <__aeabi_d2f>:
 8000a84:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a88:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000a8c:	bf24      	itt	cs
 8000a8e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000a92:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000a96:	d90d      	bls.n	8000ab4 <__aeabi_d2f+0x30>
 8000a98:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000a9c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000aa0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000aa4:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000aa8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000aac:	bf08      	it	eq
 8000aae:	f020 0001 	biceq.w	r0, r0, #1
 8000ab2:	4770      	bx	lr
 8000ab4:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000ab8:	d121      	bne.n	8000afe <__aeabi_d2f+0x7a>
 8000aba:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000abe:	bfbc      	itt	lt
 8000ac0:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000ac4:	4770      	bxlt	lr
 8000ac6:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000aca:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000ace:	f1c2 0218 	rsb	r2, r2, #24
 8000ad2:	f1c2 0c20 	rsb	ip, r2, #32
 8000ad6:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ada:	fa20 f002 	lsr.w	r0, r0, r2
 8000ade:	bf18      	it	ne
 8000ae0:	f040 0001 	orrne.w	r0, r0, #1
 8000ae4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ae8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000aec:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000af0:	ea40 000c 	orr.w	r0, r0, ip
 8000af4:	fa23 f302 	lsr.w	r3, r3, r2
 8000af8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000afc:	e7cc      	b.n	8000a98 <__aeabi_d2f+0x14>
 8000afe:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b02:	d107      	bne.n	8000b14 <__aeabi_d2f+0x90>
 8000b04:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b08:	bf1e      	ittt	ne
 8000b0a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000b0e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000b12:	4770      	bxne	lr
 8000b14:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000b18:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000b1c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000b20:	4770      	bx	lr
 8000b22:	bf00      	nop

08000b24 <sysclock_init>:
}

void sysclock_init(void)
{
	// 16 MHz HSI oscillator is default on reset, but select anyways
	RCC->CR |= RCC_CR_HSION;
 8000b24:	4a1b      	ldr	r2, [pc, #108]	@ (8000b94 <sysclock_init+0x70>)
 8000b26:	6813      	ldr	r3, [r2, #0]
 8000b28:	f043 0301 	orr.w	r3, r3, #1
{
 8000b2c:	b410      	push	{r4}
	RCC->CR |= RCC_CR_HSION;
 8000b2e:	6013      	str	r3, [r2, #0]
	// wait for HSI to be ready
	while (!((RCC->CR) & RCC_CR_HSIRDY));
 8000b30:	6813      	ldr	r3, [r2, #0]
 8000b32:	0799      	lsls	r1, r3, #30
 8000b34:	d5fc      	bpl.n	8000b30 <sysclock_init+0xc>

	// enable power interface clock for APB1
	RCC->APB1ENR = RCC_APB1ENR_PWREN;

	// configure VCO to scale 2 per CubeMX
	PWR->CR |= PWR_CR_VOS_1;
 8000b36:	4b18      	ldr	r3, [pc, #96]	@ (8000b98 <sysclock_init+0x74>)
	// configure FLASH
	// instruction cache, prefetch enable, and data cache enabled
	uint32_t flash;
	flash = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN;
	flash |= 2;		// 2 wait states for flash
	FLASH->ACR = flash;
 8000b38:	4818      	ldr	r0, [pc, #96]	@ (8000b9c <sysclock_init+0x78>)
	RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000b3a:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
 8000b3e:	6411      	str	r1, [r2, #64]	@ 0x40
	PWR->CR |= PWR_CR_VOS_1;
 8000b40:	6819      	ldr	r1, [r3, #0]
 8000b42:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 8000b46:	6019      	str	r1, [r3, #0]
	PWR->CR &= ~PWR_CR_VOS_0;
 8000b48:	6819      	ldr	r1, [r3, #0]
 8000b4a:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
 8000b4e:	6019      	str	r1, [r3, #0]
	FLASH->ACR = flash;
 8000b50:	f240 7402 	movw	r4, #1794	@ 0x702
	// configure bus prescalers
	uint32_t cfgr = 0;
	cfgr &= ~RCC_CFGR_PPRE2_2;		// APB2 prescaler of 1 (84MHz)
	cfgr |= RCC_CFGR_PPRE1_2;		// APB1 prescaler of 2 (42MHZ)
	cfgr &= ~RCC_CFGR_HPRE;			// AHB prescaler of 1 (84MHz)
	RCC->CFGR = cfgr;
 8000b54:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
	FLASH->ACR = flash;
 8000b58:	6004      	str	r4, [r0, #0]
	RCC->CFGR = cfgr;
 8000b5a:	6093      	str	r3, [r2, #8]

	// configure main PLL
	uint32_t pll_cfg = RCC->PLLCFGR;
 8000b5c:	6851      	ldr	r1, [r2, #4]
	pll_cfg &= ~RCC_PLLCFGR_PLLP;	// main PLL division factor of 2

	pll_cfg &= ~RCC_PLLCFGR_PLLN;
	pll_cfg |= 168UL << 6;	// pll multiplication factor for VCO (x168)

	pll_cfg &= ~RCC_PLLCFGR_PLLM;
 8000b5e:	4810      	ldr	r0, [pc, #64]	@ (8000ba0 <sysclock_init+0x7c>)
	pll_cfg |= 16UL << 0;	// pll division factor for main PLL and audio PLL (/16)
 8000b60:	4b10      	ldr	r3, [pc, #64]	@ (8000ba4 <sysclock_init+0x80>)
 8000b62:	4001      	ands	r1, r0
 8000b64:	430b      	orrs	r3, r1

	RCC->PLLCFGR = pll_cfg;
 8000b66:	6053      	str	r3, [r2, #4]

	// enable PLL and wait for ready
	RCC->CR |= RCC_CR_PLLON;
 8000b68:	6813      	ldr	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b6a:	490a      	ldr	r1, [pc, #40]	@ (8000b94 <sysclock_init+0x70>)
	RCC->CR |= RCC_CR_PLLON;
 8000b6c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8000b70:	6013      	str	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b72:	680b      	ldr	r3, [r1, #0]
 8000b74:	019a      	lsls	r2, r3, #6
 8000b76:	d5fc      	bpl.n	8000b72 <sysclock_init+0x4e>

	// select clock source
	cfgr = RCC->CFGR;
 8000b78:	688b      	ldr	r3, [r1, #8]
	cfgr |= RCC_CFGR_SW_1;		// select PLL as system clock
	cfgr &= ~RCC_CFGR_SW_0;
	RCC->CFGR = cfgr;

	// wait for PLL clock source to become active
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b7a:	4a06      	ldr	r2, [pc, #24]	@ (8000b94 <sysclock_init+0x70>)
 8000b7c:	f023 0301 	bic.w	r3, r3, #1
	cfgr &= ~RCC_CFGR_SW_0;
 8000b80:	f043 0302 	orr.w	r3, r3, #2
	RCC->CFGR = cfgr;
 8000b84:	608b      	str	r3, [r1, #8]
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b86:	6893      	ldr	r3, [r2, #8]
 8000b88:	071b      	lsls	r3, r3, #28
 8000b8a:	d5fc      	bpl.n	8000b86 <sysclock_init+0x62>
}
 8000b8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop
 8000b94:	40023800 	.word	0x40023800
 8000b98:	40007000 	.word	0x40007000
 8000b9c:	40023c00 	.word	0x40023c00
 8000ba0:	f0fc8000 	.word	0xf0fc8000
 8000ba4:	04002a10 	.word	0x04002a10

08000ba8 <spi1_dma2_init>:

void spi1_dma2_init(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000ba8:	495b      	ldr	r1, [pc, #364]	@ (8000d18 <spi1_dma2_init+0x170>)
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock

	// PA4 is SPI1_NSS (select alternate function)
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000baa:	4b5c      	ldr	r3, [pc, #368]	@ (8000d1c <spi1_dma2_init+0x174>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bac:	6c48      	ldr	r0, [r1, #68]	@ 0x44

	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);

	// initialize SPI slave
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000bae:	4a5c      	ldr	r2, [pc, #368]	@ (8000d20 <spi1_dma2_init+0x178>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb0:	f440 5080 	orr.w	r0, r0, #4096	@ 0x1000
{
 8000bb4:	b410      	push	{r4}
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb6:	6448      	str	r0, [r1, #68]	@ 0x44
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock
 8000bb8:	6b08      	ldr	r0, [r1, #48]	@ 0x30
 8000bba:	f040 0001 	orr.w	r0, r0, #1
 8000bbe:	6308      	str	r0, [r1, #48]	@ 0x30
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000bc0:	6818      	ldr	r0, [r3, #0]
 8000bc2:	f440 7000 	orr.w	r0, r0, #512	@ 0x200
 8000bc6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER4_0;
 8000bc8:	6818      	ldr	r0, [r3, #0]
 8000bca:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
 8000bce:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER5_1;
 8000bd0:	6818      	ldr	r0, [r3, #0]
 8000bd2:	f440 6000 	orr.w	r0, r0, #2048	@ 0x800
 8000bd6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER5_0;
 8000bd8:	6818      	ldr	r0, [r3, #0]
 8000bda:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
 8000bde:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER7_1;
 8000be0:	6818      	ldr	r0, [r3, #0]
 8000be2:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
 8000be6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER7_0;
 8000be8:	6818      	ldr	r0, [r3, #0]
 8000bea:	f420 4080 	bic.w	r0, r0, #16384	@ 0x4000
 8000bee:	6018      	str	r0, [r3, #0]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL4_0 | GPIO_AFRL_AFRL4_2;
 8000bf0:	6a18      	ldr	r0, [r3, #32]
 8000bf2:	f440 20a0 	orr.w	r0, r0, #327680	@ 0x50000
 8000bf6:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_3);
 8000bf8:	6a18      	ldr	r0, [r3, #32]
 8000bfa:	f420 2020 	bic.w	r0, r0, #655360	@ 0xa0000
 8000bfe:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL5_0 | GPIO_AFRL_AFRL5_2;
 8000c00:	6a18      	ldr	r0, [r3, #32]
 8000c02:	f440 00a0 	orr.w	r0, r0, #5242880	@ 0x500000
 8000c06:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL5_1 | GPIO_AFRL_AFRL5_3);
 8000c08:	6a18      	ldr	r0, [r3, #32]
 8000c0a:	f420 0020 	bic.w	r0, r0, #10485760	@ 0xa00000
 8000c0e:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
 8000c10:	6a18      	ldr	r0, [r3, #32]
 8000c12:	f040 40a0 	orr.w	r0, r0, #1342177280	@ 0x50000000
 8000c16:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);
 8000c18:	6a18      	ldr	r0, [r3, #32]
 8000c1a:	f020 4020 	bic.w	r0, r0, #2684354560	@ 0xa0000000
 8000c1e:	6218      	str	r0, [r3, #32]
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000c20:	6810      	ldr	r0, [r2, #0]
 8000c22:	f440 6040 	orr.w	r0, r0, #3072	@ 0xc00
 8000c26:	6010      	str	r0, [r2, #0]
	SPI1->CR1 &= ~(SPI_CR1_LSBFIRST | SPI_CR1_SSM | 	// MSb first, disable software slave management
 8000c28:	6810      	ldr	r0, [r2, #0]
 8000c2a:	f420 4002 	bic.w	r0, r0, #33280	@ 0x8200
 8000c2e:	f020 00c7 	bic.w	r0, r0, #199	@ 0xc7
 8000c32:	6010      	str	r0, [r2, #0]
					SPI_CR1_SPE | SPI_CR1_MSTR | 		// disable SPI, slave mode
					SPI_CR1_BIDIMODE |					// not using bidirectional mode
					SPI_CR1_CPOL | SPI_CR1_CPHA);		// SPI mode = [0, 0]

	SPI1->CR2 &= ~(SPI_CR2_SSOE | SPI_CR2_FRF);			// disable slave select output and select Motorola mode
 8000c34:	6850      	ldr	r0, [r2, #4]
 8000c36:	f020 0014 	bic.w	r0, r0, #20
 8000c3a:	6050      	str	r0, [r2, #4]
	SPI1->CR2 |= SPI_CR2_RXDMAEN;						// enable DMA requests when data is received
 8000c3c:	6850      	ldr	r0, [r2, #4]
 8000c3e:	f040 0001 	orr.w	r0, r0, #1
 8000c42:	6050      	str	r0, [r2, #4]


	/* DMA2 Channel 3, Stream 0 --> SPI1 RX */
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c44:	6b0a      	ldr	r2, [r1, #48]	@ 0x30

	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c46:	f503 43c8 	add.w	r3, r3, #25600	@ 0x6400
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c4a:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8000c4e:	630a      	str	r2, [r1, #48]	@ 0x30
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c50:	691a      	ldr	r2, [r3, #16]
 8000c52:	f022 0201 	bic.w	r2, r2, #1
 8000c56:	611a      	str	r2, [r3, #16]
	while (DMA2_Stream0->CR & DMA_SxCR_EN);	// wait for stream to disable
 8000c58:	691a      	ldr	r2, [r3, #16]
 8000c5a:	07d2      	lsls	r2, r2, #31
 8000c5c:	d4fc      	bmi.n	8000c58 <spi1_dma2_init+0xb0>

	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c5e:	4c31      	ldr	r4, [pc, #196]	@ (8000d24 <spi1_dma2_init+0x17c>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c60:	4931      	ldr	r1, [pc, #196]	@ (8000d28 <spi1_dma2_init+0x180>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c62:	4832      	ldr	r0, [pc, #200]	@ (8000d2c <spi1_dma2_init+0x184>)
	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c64:	619c      	str	r4, [r3, #24]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c66:	f44f 62b4 	mov.w	r2, #1440	@ 0x5a0
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c6a:	61d8      	str	r0, [r3, #28]
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c6c:	6219      	str	r1, [r3, #32]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c6e:	615a      	str	r2, [r3, #20]

	// select channel 3 for SPI1 RX
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c70:	691a      	ldr	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;


	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream

	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000c72:	492b      	ldr	r1, [pc, #172]	@ (8000d20 <spi1_dma2_init+0x178>)
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c74:	f022 6260 	bic.w	r2, r2, #234881024	@ 0xe000000
 8000c78:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CHSEL_0 | DMA_SxCR_CHSEL_1;
 8000c7a:	691a      	ldr	r2, [r3, #16]
 8000c7c:	f042 62c0 	orr.w	r2, r2, #100663296	@ 0x6000000
 8000c80:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PFCTRL;	// DMA is the flow controller
 8000c82:	691a      	ldr	r2, [r3, #16]
 8000c84:	f022 0220 	bic.w	r2, r2, #32
 8000c88:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PL_0;
 8000c8a:	691a      	ldr	r2, [r3, #16]
 8000c8c:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8000c90:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PL_1;
 8000c92:	691a      	ldr	r2, [r3, #16]
 8000c94:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8000c98:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->FCR |= DMA_SxFCR_DMDIS;
 8000c9a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000c9c:	f042 0204 	orr.w	r2, r2, #4
 8000ca0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR |= DMA_SxFCR_FTH_0;
 8000ca2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000ca4:	f042 0201 	orr.w	r2, r2, #1
 8000ca8:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR &= ~DMA_SxFCR_FTH_1;
 8000caa:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000cac:	f022 0202 	bic.w	r2, r2, #2
 8000cb0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->CR |= DMA_SxCR_MSIZE_0;
 8000cb2:	691a      	ldr	r2, [r3, #16]
 8000cb4:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8000cb8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_MSIZE_1;
 8000cba:	691a      	ldr	r2, [r3, #16]
 8000cbc:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8000cc0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PSIZE_0;
 8000cc2:	691a      	ldr	r2, [r3, #16]
 8000cc4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8000cc8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PSIZE_1;
 8000cca:	691a      	ldr	r2, [r3, #16]
 8000ccc:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8000cd0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_MINC;
 8000cd2:	691a      	ldr	r2, [r3, #16]
 8000cd4:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8000cd8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PINC;
 8000cda:	691a      	ldr	r2, [r3, #16]
 8000cdc:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8000ce0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce2:	691a      	ldr	r2, [r3, #16]
}
 8000ce4:	f85d 4b04 	ldr.w	r4, [sp], #4
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce8:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8000cec:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CIRC;
 8000cee:	691a      	ldr	r2, [r3, #16]
 8000cf0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8000cf4:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_DBM;
 8000cf6:	691a      	ldr	r2, [r3, #16]
 8000cf8:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8000cfc:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;
 8000cfe:	691a      	ldr	r2, [r3, #16]
 8000d00:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 8000d04:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream
 8000d06:	691a      	ldr	r2, [r3, #16]
 8000d08:	f042 0201 	orr.w	r2, r2, #1
 8000d0c:	611a      	str	r2, [r3, #16]
	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000d0e:	680b      	ldr	r3, [r1, #0]
 8000d10:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8000d14:	600b      	str	r3, [r1, #0]
}
 8000d16:	4770      	bx	lr
 8000d18:	40023800 	.word	0x40023800
 8000d1c:	40020000 	.word	0x40020000
 8000d20:	40013000 	.word	0x40013000
 8000d24:	4001300c 	.word	0x4001300c
 8000d28:	20000024 	.word	0x20000024
 8000d2c:	20000b64 	.word	0x20000b64

08000d30 <stream_splice>:

void stream_splice(struct MicProc * mics)
{
 8000d30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		// mic0 = [CH0_S0, CH0_S1, CH0_S2, ...]
		// mic1 = [CH1_S0, CH1_S1, CH1_S2, ...]
		// mic2 = [CH2_S0, CH2_S1, CH2_S2, ...]

		// DMA is targeting M1AR ---> read from M0AR memory
		if (dma_tgt)
 8000d34:	4b5d      	ldr	r3, [pc, #372]	@ (8000eac <stream_splice+0x17c>)
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
		}
		else
		{
			for (uint32_t j = 0; j < N_MICS; j++)
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d36:	f8df 9194 	ldr.w	r9, [pc, #404]	@ 8000ecc <stream_splice+0x19c>
 8000d3a:	781d      	ldrb	r5, [r3, #0]
{
 8000d3c:	4607      	mov	r7, r0
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d3e:	f04f 0800 	mov.w	r8, #0
 8000d42:	2d00      	cmp	r5, #0
 8000d44:	d158      	bne.n	8000df8 <stream_splice+0xc8>
 8000d46:	f04f 0a00 	mov.w	sl, #0
 8000d4a:	f04f 5b7d 	mov.w	fp, #1061158912	@ 0x3f400000
 8000d4e:	4b58      	ldr	r3, [pc, #352]	@ (8000eb0 <stream_splice+0x180>)
 8000d50:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
		uint32_t ind = i / 3;
 8000d54:	4b57      	ldr	r3, [pc, #348]	@ (8000eb4 <stream_splice+0x184>)
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d56:	ee07 0a90 	vmov	s15, r0
 8000d5a:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8000d5e:	fba3 3405 	umull	r3, r4, r3, r5
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d62:	ee17 0a90 	vmov	r0, s15
 8000d66:	f7ff fb9b 	bl	80004a0 <__aeabi_f2d>
 8000d6a:	4642      	mov	r2, r8
 8000d6c:	464b      	mov	r3, r9
 8000d6e:	f7ff fa37 	bl	80001e0 <__aeabi_dsub>
 8000d72:	4652      	mov	r2, sl
 8000d74:	465b      	mov	r3, fp
 8000d76:	f7ff fbeb 	bl	8000550 <__aeabi_dmul>
		uint32_t ind = i / 3;
 8000d7a:	0864      	lsrs	r4, r4, #1
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d7c:	f7ff fe82 	bl	8000a84 <__aeabi_d2f>
 8000d80:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8000d84:	4b4c      	ldr	r3, [pc, #304]	@ (8000eb8 <stream_splice+0x188>)
 8000d86:	f504 5680 	add.w	r6, r4, #4096	@ 0x1000
 8000d8a:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000d8c:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000d90:	ee07 0a90 	vmov	s15, r0
 8000d94:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000d98:	f504 469c 	add.w	r6, r4, #19968	@ 0x4e00
 8000d9c:	ee17 0a90 	vmov	r0, s15
 8000da0:	f7ff fb7e 	bl	80004a0 <__aeabi_f2d>
 8000da4:	4642      	mov	r2, r8
 8000da6:	464b      	mov	r3, r9
 8000da8:	f7ff fa1a 	bl	80001e0 <__aeabi_dsub>
 8000dac:	4652      	mov	r2, sl
 8000dae:	465b      	mov	r3, fp
 8000db0:	f7ff fbce 	bl	8000550 <__aeabi_dmul>
 8000db4:	f7ff fe66 	bl	8000a84 <__aeabi_d2f>
 8000db8:	4b40      	ldr	r3, [pc, #256]	@ (8000ebc <stream_splice+0x18c>)
 8000dba:	67f0      	str	r0, [r6, #124]	@ 0x7c
 8000dbc:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000dc0:	ee07 0a90 	vmov	s15, r0
 8000dc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000dc8:	f504 440c 	add.w	r4, r4, #35840	@ 0x8c00
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000dcc:	ee17 0a90 	vmov	r0, s15
 8000dd0:	f7ff fb66 	bl	80004a0 <__aeabi_f2d>
 8000dd4:	4642      	mov	r2, r8
 8000dd6:	464b      	mov	r3, r9
 8000dd8:	f7ff fa02 	bl	80001e0 <__aeabi_dsub>
 8000ddc:	4652      	mov	r2, sl
 8000dde:	465b      	mov	r3, fp
 8000de0:	f7ff fbb6 	bl	8000550 <__aeabi_dmul>
 8000de4:	f7ff fe4e 	bl	8000a84 <__aeabi_d2f>
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000de8:	3503      	adds	r5, #3
 8000dea:	f5b5 6fb4 	cmp.w	r5, #1440	@ 0x5a0
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000dee:	f8c4 0080 	str.w	r0, [r4, #128]	@ 0x80
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000df2:	d1ac      	bne.n	8000d4e <stream_splice+0x1e>
		}
	}
}
 8000df4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000df8:	2500      	movs	r5, #0
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000dfa:	f04f 0a00 	mov.w	sl, #0
 8000dfe:	f04f 5b7d 	mov.w	fp, #1061158912	@ 0x3f400000
 8000e02:	4b2f      	ldr	r3, [pc, #188]	@ (8000ec0 <stream_splice+0x190>)
 8000e04:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
		uint32_t ind = i / 3;
 8000e08:	4b2a      	ldr	r3, [pc, #168]	@ (8000eb4 <stream_splice+0x184>)
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e0a:	ee07 0a90 	vmov	s15, r0
 8000e0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8000e12:	fba3 3405 	umull	r3, r4, r3, r5
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e16:	ee17 0a90 	vmov	r0, s15
 8000e1a:	f7ff fb41 	bl	80004a0 <__aeabi_f2d>
 8000e1e:	4642      	mov	r2, r8
 8000e20:	464b      	mov	r3, r9
 8000e22:	f7ff f9dd 	bl	80001e0 <__aeabi_dsub>
 8000e26:	4652      	mov	r2, sl
 8000e28:	465b      	mov	r3, fp
 8000e2a:	f7ff fb91 	bl	8000550 <__aeabi_dmul>
		uint32_t ind = i / 3;
 8000e2e:	0864      	lsrs	r4, r4, #1
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e30:	f7ff fe28 	bl	8000a84 <__aeabi_d2f>
 8000e34:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8000e38:	4b22      	ldr	r3, [pc, #136]	@ (8000ec4 <stream_splice+0x194>)
 8000e3a:	f504 5680 	add.w	r6, r4, #4096	@ 0x1000
 8000e3e:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000e40:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000e44:	ee07 0a90 	vmov	s15, r0
 8000e48:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000e4c:	f504 469c 	add.w	r6, r4, #19968	@ 0x4e00
 8000e50:	ee17 0a90 	vmov	r0, s15
 8000e54:	f7ff fb24 	bl	80004a0 <__aeabi_f2d>
 8000e58:	4642      	mov	r2, r8
 8000e5a:	464b      	mov	r3, r9
 8000e5c:	f7ff f9c0 	bl	80001e0 <__aeabi_dsub>
 8000e60:	4652      	mov	r2, sl
 8000e62:	465b      	mov	r3, fp
 8000e64:	f7ff fb74 	bl	8000550 <__aeabi_dmul>
 8000e68:	f7ff fe0c 	bl	8000a84 <__aeabi_d2f>
 8000e6c:	4b16      	ldr	r3, [pc, #88]	@ (8000ec8 <stream_splice+0x198>)
 8000e6e:	67f0      	str	r0, [r6, #124]	@ 0x7c
 8000e70:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000e74:	ee07 0a90 	vmov	s15, r0
 8000e78:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000e7c:	f504 440c 	add.w	r4, r4, #35840	@ 0x8c00
 8000e80:	ee17 0a90 	vmov	r0, s15
 8000e84:	f7ff fb0c 	bl	80004a0 <__aeabi_f2d>
 8000e88:	4642      	mov	r2, r8
 8000e8a:	464b      	mov	r3, r9
 8000e8c:	f7ff f9a8 	bl	80001e0 <__aeabi_dsub>
 8000e90:	4652      	mov	r2, sl
 8000e92:	465b      	mov	r3, fp
 8000e94:	f7ff fb5c 	bl	8000550 <__aeabi_dmul>
 8000e98:	f7ff fdf4 	bl	8000a84 <__aeabi_d2f>
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000e9c:	3503      	adds	r5, #3
 8000e9e:	f5b5 6fb4 	cmp.w	r5, #1440	@ 0x5a0
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000ea2:	f8c4 0080 	str.w	r0, [r4, #128]	@ 0x80
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000ea6:	d1ac      	bne.n	8000e02 <stream_splice+0xd2>
}
 8000ea8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000eac:	20000020 	.word	0x20000020
 8000eb0:	20000024 	.word	0x20000024
 8000eb4:	aaaaaaab 	.word	0xaaaaaaab
 8000eb8:	20000026 	.word	0x20000026
 8000ebc:	20000028 	.word	0x20000028
 8000ec0:	20000b64 	.word	0x20000b64
 8000ec4:	20000b66 	.word	0x20000b66
 8000ec8:	20000b68 	.word	0x20000b68
 8000ecc:	40a00000 	.word	0x40a00000

08000ed0 <compute_event_pos>:

uint8_t compute_event_pos(float32_t * x, float32_t * y, struct MicCoord * mics_xy, float32_t mic1_delay, float32_t mic2_delay)
{
 8000ed0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	const float32_t max_step = 0.2f;			// maximum dx/dy change per iteration in meters

	// distances from mic1 and mic2 to mic0
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000ed4:	eddf 7a90 	vldr	s15, [pc, #576]	@ 8001118 <compute_event_pos+0x248>
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;

	float32_t lambda = 1e-3f;

	float32_t old_res1 = 0, old_res2 = 0;
 8000ed8:	eddf 4a90 	vldr	s9, [pc, #576]	@ 800111c <compute_event_pos+0x24c>
{
 8000edc:	ed2d 8b0e 	vpush	{d8-d14}
		*y += dy;

		old_res1 = res1;
		old_res2 = res2;

		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000ee0:	a78b      	add	r7, pc, #556	@ (adr r7, 8001110 <compute_event_pos+0x240>)
 8000ee2:	e9d7 6700 	ldrd	r6, r7, [r7]
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000ee6:	ee60 8a27 	vmul.f32	s17, s0, s15
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;
 8000eea:	ee20 8aa7 	vmul.f32	s16, s1, s15
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000eee:	edd1 ba00 	vldr	s23, [r1]
	float32_t lambda = 1e-3f;
 8000ef2:	ed9f da8b 	vldr	s26, [pc, #556]	@ 8001120 <compute_event_pos+0x250>
		if (cost < 1e-8f)	return 1;
 8000ef6:	ed9f 9a8b 	vldr	s18, [pc, #556]	@ 8001124 <compute_event_pos+0x254>
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8000efa:	eddf aa8b 	vldr	s21, [pc, #556]	@ 8001128 <compute_event_pos+0x258>
		if (fabsf(det) < 1e-12f)
 8000efe:	eddf 9a8b 	vldr	s19, [pc, #556]	@ 800112c <compute_event_pos+0x25c>
float32_t clamp(float32_t in, float32_t abs_max)
{
	// clamp in between [-abs_max, abs_max]
	if (in > abs_max)
		return abs_max;
	else if (in < -abs_max)
 8000f02:	ed9f ea8b 	vldr	s28, [pc, #556]	@ 8001130 <compute_event_pos+0x260>
 8000f06:	eddf da8b 	vldr	s27, [pc, #556]	@ 8001134 <compute_event_pos+0x264>
{
 8000f0a:	4689      	mov	r9, r1
	float32_t old_res1 = 0, old_res2 = 0;
 8000f0c:	eeb0 4a64 	vmov.f32	s8, s9
{
 8000f10:	4680      	mov	r8, r0
 8000f12:	4614      	mov	r4, r2
		else						lambda *= 5.0f;			// punish bad step
 8000f14:	eeb1 aa04 	vmov.f32	s20, #20	@ 0x40a00000  5.0
			lambda *= 10.0f;
 8000f18:	eeb2 ba04 	vmov.f32	s22, #36	@ 0x41200000  10.0
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000f1c:	2532      	movs	r5, #50	@ 0x32
 8000f1e:	e057      	b.n	8000fd0 <compute_event_pos+0x100>
		float32_t g2 = j12 * res1 + j22 * res2;
 8000f20:	ee6c 7a27 	vmul.f32	s15, s24, s15
		float32_t g1 = j11 * res1 + j21 * res2;
 8000f24:	ee2c 7a07 	vmul.f32	s14, s24, s14
		float32_t g2 = j12 * res1 + j22 * res2;
 8000f28:	eeec 7aa3 	vfma.f32	s15, s25, s7
		float32_t g1 = j11 * res1 + j21 * res2;
 8000f2c:	eeac 7a85 	vfma.f32	s14, s25, s10
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000f30:	ee23 5a27 	vmul.f32	s10, s6, s15
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000f34:	ee67 7ae5 	vnmul.f32	s15, s15, s11
 8000f38:	eef0 5a45 	vmov.f32	s11, s10
 8000f3c:	eee6 5a47 	vfms.f32	s11, s12, s14
 8000f40:	eee3 7a07 	vfma.f32	s15, s6, s14
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000f44:	ee85 6aa2 	vdiv.f32	s12, s11, s5
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000f48:	ee87 7aa2 	vdiv.f32	s14, s15, s5
	else if (in < -abs_max)
 8000f4c:	eeb4 6ace 	vcmpe.f32	s12, s28
 8000f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f54:	bfb8      	it	lt
 8000f56:	eeb0 6a4e 	vmovlt.f32	s12, s28
 8000f5a:	eeb4 6aed 	vcmpe.f32	s12, s27
 8000f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f62:	eeb4 7ace 	vcmpe.f32	s14, s28
 8000f66:	bf88      	it	hi
 8000f68:	eeb0 6a6d 	vmovhi.f32	s12, s27
 8000f6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f70:	bfb8      	it	lt
 8000f72:	eeb0 7a4e 	vmovlt.f32	s14, s28
 8000f76:	eeb4 7aed 	vcmpe.f32	s14, s27
 8000f7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f7e:	bf88      	it	hi
 8000f80:	eeb0 7a6d 	vmovhi.f32	s14, s27
		*x += dx;
 8000f84:	ee76 7a86 	vadd.f32	s15, s13, s12
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f88:	ee67 6a07 	vmul.f32	s13, s14, s14
		*x += dx;
 8000f8c:	edc8 7a00 	vstr	s15, [r8]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f90:	eef0 7a66 	vmov.f32	s15, s13
 8000f94:	eee6 7a06 	vfma.f32	s15, s12, s12
		*y += dy;
 8000f98:	edd9 5a00 	vldr	s11, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f9c:	eef1 7ae7 	vsqrt.f32	s15, s15
		*y += dy;
 8000fa0:	ee77 ba25 	vadd.f32	s23, s14, s11
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000fa4:	ee17 0a90 	vmov	r0, s15
		*y += dy;
 8000fa8:	edc9 ba00 	vstr	s23, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000fac:	f7ff fa78 	bl	80004a0 <__aeabi_f2d>
 8000fb0:	4632      	mov	r2, r6
 8000fb2:	463b      	mov	r3, r7
 8000fb4:	f7ff fd3e 	bl	8000a34 <__aeabi_dcmplt>
 8000fb8:	2800      	cmp	r0, #0
 8000fba:	f040 80a2 	bne.w	8001102 <compute_event_pos+0x232>
	for (uint8_t i = 0; i < 50; i++)
 8000fbe:	1e6b      	subs	r3, r5, #1
 8000fc0:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
		old_res2 = res2;
 8000fc4:	eef0 4a6c 	vmov.f32	s9, s25
		old_res1 = res1;
 8000fc8:	eeb0 4a4c 	vmov.f32	s8, s24
	for (uint8_t i = 0; i < 50; i++)
 8000fcc:	f000 8094 	beq.w	80010f8 <compute_event_pos+0x228>
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fd0:	edd4 2a01 	vldr	s5, [r4, #4]
 8000fd4:	edd8 6a00 	vldr	s13, [r8]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000fd8:	ed94 6a03 	vldr	s12, [r4, #12]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000fdc:	ed94 7a05 	vldr	s14, [r4, #20]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fe0:	ed94 2a00 	vldr	s4, [r4]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000fe4:	edd4 5a02 	vldr	s11, [r4, #8]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000fe8:	ed94 5a04 	vldr	s10, [r4, #16]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fec:	ee7b 7ae2 	vsub.f32	s15, s23, s5
 8000ff0:	ee76 1ac2 	vsub.f32	s3, s13, s4
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000ff4:	ee3b 6ac6 	vsub.f32	s12, s23, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000ff8:	ee3b 7ac7 	vsub.f32	s14, s23, s14
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000ffc:	ee67 7aa7 	vmul.f32	s15, s15, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001000:	ee76 5ae5 	vsub.f32	s11, s13, s11
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8001004:	eee1 7aa1 	vfma.f32	s15, s3, s3
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001008:	ee66 3a06 	vmul.f32	s7, s12, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 800100c:	ee36 5ac5 	vsub.f32	s10, s13, s10
 8001010:	ee27 3a07 	vmul.f32	s6, s14, s14
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001014:	eee5 3aa5 	vfma.f32	s7, s11, s11
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8001018:	eea5 3a05 	vfma.f32	s6, s10, s10
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 800101c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8001020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8001024:	eef1 1ae7 	vsqrt.f32	s3, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001028:	eeb1 1ae3 	vsqrt.f32	s2, s7
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 800102c:	eef1 0ac3 	vsqrt.f32	s1, s6
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8001030:	d067      	beq.n	8001102 <compute_event_pos+0x232>
 8001032:	eef5 3a40 	vcmp.f32	s7, #0.0
 8001036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800103a:	d062      	beq.n	8001102 <compute_event_pos+0x232>
 800103c:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8001040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001044:	d05d      	beq.n	8001102 <compute_event_pos+0x232>
		float32_t res2 = r2 - r0 - d20;
 8001046:	ee70 cac8 	vsub.f32	s25, s1, s16
		float32_t res1 = r1 - r0 - d10;
 800104a:	ee31 ca68 	vsub.f32	s24, s2, s17
		float32_t res2 = r2 - r0 - d20;
 800104e:	ee7c cae1 	vsub.f32	s25, s25, s3
		float32_t res1 = r1 - r0 - d10;
 8001052:	ee3c ca61 	vsub.f32	s24, s24, s3
		float32_t cost = res1 * res1 + res2 * res2;
 8001056:	ee6c 3aac 	vmul.f32	s7, s25, s25
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 800105a:	ee64 7aa4 	vmul.f32	s15, s9, s9
		float32_t cost = res1 * res1 + res2 * res2;
 800105e:	eeec 3a0c 	vfma.f32	s7, s24, s24
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 8001062:	eee4 7a04 	vfma.f32	s15, s8, s8
		if (cost < 1e-8f)	return 1;
 8001066:	eef4 3ac9 	vcmpe.f32	s7, s18
 800106a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800106e:	d448      	bmi.n	8001102 <compute_event_pos+0x232>
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001070:	ee32 2a66 	vsub.f32	s4, s4, s13
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8001074:	ee72 2aeb 	vsub.f32	s5, s5, s23
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8001078:	eef4 3ae7 	vcmpe.f32	s7, s15
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800107c:	ee82 3aa1 	vdiv.f32	s6, s5, s3
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001080:	ee82 0a21 	vdiv.f32	s0, s4, s3
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8001084:	eec5 2a20 	vdiv.f32	s5, s10, s1
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8001088:	eec7 3a20 	vdiv.f32	s7, s14, s1
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800108c:	eec6 7a01 	vdiv.f32	s15, s12, s2
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001090:	ee85 7a81 	vdiv.f32	s14, s11, s2
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8001094:	ee32 5a80 	vadd.f32	s10, s5, s0
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8001098:	ee73 3a83 	vadd.f32	s7, s7, s6
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800109c:	ee77 7a83 	vadd.f32	s15, s15, s6
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 80010a0:	ee37 7a00 	vadd.f32	s14, s14, s0
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 80010a4:	ee65 5a05 	vmul.f32	s11, s10, s10
		float32_t prod12 = j11 * j12 + j21 * j22;
 80010a8:	ee25 3a23 	vmul.f32	s6, s10, s7
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 80010ac:	ee23 6aa3 	vmul.f32	s12, s7, s7
 80010b0:	eee7 5a07 	vfma.f32	s11, s14, s14
		float32_t prod12 = j11 * j12 + j21 * j22;
 80010b4:	eea7 3a27 	vfma.f32	s6, s14, s15
 80010b8:	eea7 6aa7 	vfma.f32	s12, s15, s15
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 80010bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010c0:	bf4c      	ite	mi
 80010c2:	ee2d da2a 	vmulmi.f32	s26, s26, s21
		else						lambda *= 5.0f;			// punish bad step
 80010c6:	ee2d da0a 	vmulpl.f32	s26, s26, s20
		float32_t det = prod11 * prod22 - prod12 * prod21;
 80010ca:	ee63 2a43 	vnmul.f32	s5, s6, s6
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 80010ce:	ee7d 5a25 	vadd.f32	s11, s26, s11
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 80010d2:	ee3d 6a06 	vadd.f32	s12, s26, s12
		float32_t det = prod11 * prod22 - prod12 * prod21;
 80010d6:	eee5 2a86 	vfma.f32	s5, s11, s12
		if (fabsf(det) < 1e-12f)
 80010da:	eeb0 2ae2 	vabs.f32	s4, s5
 80010de:	eeb4 2ae9 	vcmpe.f32	s4, s19
 80010e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010e6:	f57f af1b 	bpl.w	8000f20 <compute_event_pos+0x50>
	for (uint8_t i = 0; i < 50; i++)
 80010ea:	1e6b      	subs	r3, r5, #1
 80010ec:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
			lambda *= 10.0f;
 80010f0:	ee2d da0b 	vmul.f32	s26, s26, s22
	for (uint8_t i = 0; i < 50; i++)
 80010f4:	f47f af6c 	bne.w	8000fd0 <compute_event_pos+0x100>
}
 80010f8:	ecbd 8b0e 	vpop	{d8-d14}
 80010fc:	4628      	mov	r0, r5
 80010fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001102:	ecbd 8b0e 	vpop	{d8-d14}
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8001106:	2501      	movs	r5, #1
}
 8001108:	4628      	mov	r0, r5
 800110a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800110e:	bf00      	nop
 8001110:	88e368f1 	.word	0x88e368f1
 8001114:	3ee4f8b5 	.word	0x3ee4f8b5
 8001118:	43ab8000 	.word	0x43ab8000
 800111c:	00000000 	.word	0x00000000
 8001120:	3a83126f 	.word	0x3a83126f
 8001124:	322bcc77 	.word	0x322bcc77
 8001128:	3e99999a 	.word	0x3e99999a
 800112c:	2b8cbccc 	.word	0x2b8cbccc
 8001130:	be4ccccd 	.word	0xbe4ccccd
 8001134:	3e4ccccd 	.word	0x3e4ccccd

08001138 <compute_envelope>:
	else
		return in;
}

void compute_envelope(struct MicProc * mics)
{
 8001138:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800113c:	f500 51fb 	add.w	r1, r0, #8032	@ 0x1f60
 8001140:	4605      	mov	r5, r0
 8001142:	f500 4059 	add.w	r0, r0, #55552	@ 0xd900
 8001146:	3118      	adds	r1, #24
 8001148:	3084      	adds	r0, #132	@ 0x84
	// square signals and multiply with gain of 2
	for (uint32_t i = 0; i < N_MICS; i++)
 800114a:	f643 6404 	movw	r4, #15876	@ 0x3e04
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 800114e:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
{
 8001152:	460a      	mov	r2, r1
			mics[i].envelope[j] = mics[i].filtered[j] * mics[i].filtered[j] * 2;
 8001154:	ecf3 7a01 	vldmia	r3!, {s15}
 8001158:	ee67 7aa7 	vmul.f32	s15, s15, s15
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 800115c:	428b      	cmp	r3, r1
			mics[i].envelope[j] = mics[i].filtered[j] * mics[i].filtered[j] * 2;
 800115e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8001162:	ece2 7a01 	vstmia	r2!, {s15}
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8001166:	d1f5      	bne.n	8001154 <compute_envelope+0x1c>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001168:	1919      	adds	r1, r3, r4
 800116a:	4281      	cmp	r1, r0
 800116c:	d1ef      	bne.n	800114e <compute_envelope+0x16>
 800116e:	f505 463a 	add.w	r6, r5, #47616	@ 0xba00
 8001172:	f105 0424 	add.w	r4, r5, #36	@ 0x24
 8001176:	3630      	adds	r6, #48	@ 0x30

	// Lowpass filter to remove high frequencies accumulated during scaling
	for (uint32_t i = 0; i < N_MICS; i++)
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8001178:	f641 7854 	movw	r8, #8020	@ 0x1f54
	for (uint32_t i = 0; i < N_MICS; i++)
 800117c:	f643 6704 	movw	r7, #15876	@ 0x3e04
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8001180:	eb04 0208 	add.w	r2, r4, r8
 8001184:	4620      	mov	r0, r4
 8001186:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800118a:	4611      	mov	r1, r2
	for (uint32_t i = 0; i < N_MICS; i++)
 800118c:	443c      	add	r4, r7
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 800118e:	f000 fbd3 	bl	8001938 <arm_fir_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001192:	42b4      	cmp	r4, r6
 8001194:	d1f4      	bne.n	8001180 <compute_envelope+0x48>
 8001196:	f505 511b 	add.w	r1, r5, #9920	@ 0x26c0
 800119a:	f505 4561 	add.w	r5, r5, #57600	@ 0xe100
 */
__STATIC_FORCEINLINE arm_status arm_sqrt_f32(
  const float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 800119e:	2000      	movs	r0, #0
 80011a0:	3138      	adds	r1, #56	@ 0x38
 80011a2:	3504      	adds	r5, #4

	// square root output
	for (uint32_t i = 0; i < N_MICS; i++)
 80011a4:	f643 6404 	movw	r4, #15876	@ 0x3e04
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 80011a8:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
 80011ac:	e005      	b.n	80011ba <compute_envelope+0x82>
 80011ae:	428b      	cmp	r3, r1
      *pOut = _sqrtf(in);
#elif defined(__GNUC_PYTHON__)
      *pOut = sqrtf(in);
#elif defined ( __GNUC__ )
  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 80011b0:	eef1 7ae7 	vsqrt.f32	s15, s15
 80011b4:	edc2 7a00 	vstr	s15, [r2]
 80011b8:	d00b      	beq.n	80011d2 <compute_envelope+0x9a>
 80011ba:	461a      	mov	r2, r3
			arm_sqrt_f32(mics[i].envelope[j], &mics[i].envelope[j]);
 80011bc:	ecf3 7a01 	vldmia	r3!, {s15}
    if (in >= 0.0f)
 80011c0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80011c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011c8:	daf1      	bge.n	80011ae <compute_envelope+0x76>
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 80011ca:	428b      	cmp	r3, r1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 80011cc:	f843 0c04 	str.w	r0, [r3, #-4]
 80011d0:	d1f3      	bne.n	80011ba <compute_envelope+0x82>
	for (uint32_t i = 0; i < N_MICS; i++)
 80011d2:	1919      	adds	r1, r3, r4
 80011d4:	42a9      	cmp	r1, r5
 80011d6:	d1e7      	bne.n	80011a8 <compute_envelope+0x70>
}
 80011d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080011dc <main>:
{
 80011dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80011e0:	ed2d 8b08 	vpush	{d8-d11}
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 80011e4:	4d9c      	ldr	r5, [pc, #624]	@ (8001458 <main+0x27c>)
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 80011e6:	4f9d      	ldr	r7, [pc, #628]	@ (800145c <main+0x280>)
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 80011e8:	4e9d      	ldr	r6, [pc, #628]	@ (8001460 <main+0x284>)
{
 80011ea:	f5ad 4d4a 	sub.w	sp, sp, #51712	@ 0xca00
 80011ee:	b0a3      	sub	sp, #140	@ 0x8c
	sysclock_init();
 80011f0:	f7ff fc98 	bl	8000b24 <sysclock_init>
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 80011f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80011f6:	ac0d      	add	r4, sp, #52	@ 0x34
 80011f8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80011fa:	e895 0003 	ldmia.w	r5, {r0, r1}
 80011fe:	e884 0003 	stmia.w	r4, {r0, r1}
 8001202:	f50d 5483 	add.w	r4, sp, #4192	@ 0x1060
 8001206:	341c      	adds	r4, #28
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 8001208:	4620      	mov	r0, r4
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 800120a:	f44f 75f0 	mov.w	r5, #480	@ 0x1e0
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 800120e:	f001 fb93 	bl	8002938 <arm_rfft_fast_init_256_f32>
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 8001212:	f104 0330 	add.w	r3, r4, #48	@ 0x30
 8001216:	f104 0018 	add.w	r0, r4, #24
 800121a:	212a      	movs	r1, #42	@ 0x2a
 800121c:	463a      	mov	r2, r7
 800121e:	9500      	str	r5, [sp, #0]
 8001220:	f000 fbc4 	bl	80019ac <arm_fir_init_f32>
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 8001224:	f604 0354 	addw	r3, r4, #2132	@ 0x854
 8001228:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 800122c:	212a      	movs	r1, #42	@ 0x2a
 800122e:	9500      	str	r5, [sp, #0]
 8001230:	4632      	mov	r2, r6
 8001232:	f000 fbbb 	bl	80019ac <arm_fir_init_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001236:	f504 5478 	add.w	r4, r4, #15872	@ 0x3e00
 800123a:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 800123e:	3404      	adds	r4, #4
 8001240:	3388      	adds	r3, #136	@ 0x88
 8001242:	429c      	cmp	r4, r3
 8001244:	d1e0      	bne.n	8001208 <main+0x2c>
	arm_rfft_fast_init_256_f32(&xcorr_01_freq_hfft);
 8001246:	a813      	add	r0, sp, #76	@ 0x4c
 8001248:	f001 fb76 	bl	8002938 <arm_rfft_fast_init_256_f32>
	arm_rfft_fast_init_256_f32(&xcorr_02_freq_hfft);
 800124c:	a819      	add	r0, sp, #100	@ 0x64
 800124e:	f001 fb73 	bl	8002938 <arm_rfft_fast_init_256_f32>
	uart2_set_fcpu(84000000);
 8001252:	4884      	ldr	r0, [pc, #528]	@ (8001464 <main+0x288>)
			float32_t mic02_delay = -((float32_t) lag02 * T_SAMPLE);
 8001254:	ed9f 8a84 	vldr	s16, [pc, #528]	@ 8001468 <main+0x28c>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 8001258:	eddf 9a84 	vldr	s19, [pc, #528]	@ 800146c <main+0x290>
 800125c:	ed9f aa84 	vldr	s20, [pc, #528]	@ 8001470 <main+0x294>
 8001260:	f8df a220 	ldr.w	sl, [pc, #544]	@ 8001484 <main+0x2a8>
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 8001264:	ed9f 9a83 	vldr	s18, [pc, #524]	@ 8001474 <main+0x298>
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 8001268:	eddf 8a83 	vldr	s17, [pc, #524]	@ 8001478 <main+0x29c>
	uart2_set_fcpu(84000000);
 800126c:	f001 fb82 	bl	8002974 <uart2_set_fcpu>
	uart2_dma1_config(115200, USART_DATA_8, USART_STOP_1);
 8001270:	2200      	movs	r2, #0
 8001272:	4611      	mov	r1, r2
 8001274:	f44f 30e1 	mov.w	r0, #115200	@ 0x1c200
 8001278:	f001 fb8c 	bl	8002994 <uart2_dma1_config>
	spi1_dma2_init();
 800127c:	f7ff fc94 	bl	8000ba8 <spi1_dma2_init>
	uint32_t last_trigger_sample = 0;
 8001280:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001284:	331c      	adds	r3, #28
 8001286:	f503 4278 	add.w	r2, r3, #63488	@ 0xf800
 800128a:	f503 4378 	add.w	r3, r3, #63488	@ 0xf800
 800128e:	330c      	adds	r3, #12
 8001290:	f04f 0c00 	mov.w	ip, #0
 8001294:	3204      	adds	r2, #4
 8001296:	9307      	str	r3, [sp, #28]
 8001298:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 800129c:	331c      	adds	r3, #28
 800129e:	e9cd c204 	strd	ip, r2, [sp, #16]
 80012a2:	f503 5567 	add.w	r5, r3, #14784	@ 0x39c0
 80012a6:	f503 5477 	add.w	r4, r3, #15808	@ 0x3dc0
 80012aa:	3538      	adds	r5, #56	@ 0x38
 80012ac:	3438      	adds	r4, #56	@ 0x38
	uint32_t samples = 0;
 80012ae:	46e1      	mov	r9, ip
	uint32_t ref_sample = 0;
 80012b0:	f8cd c018 	str.w	ip, [sp, #24]
	uint8_t triggered = 0;									// has a microphone detected an event?
 80012b4:	f8cd c00c 	str.w	ip, [sp, #12]
	uint8_t window_ind = 0;
 80012b8:	4666      	mov	r6, ip
		while (!!(DMA2_Stream0->CR & DMA_SxCR_CT) == dma_tgt);		// wait for stream to complete
 80012ba:	f89a 2000 	ldrb.w	r2, [sl]
 80012be:	496f      	ldr	r1, [pc, #444]	@ (800147c <main+0x2a0>)
 80012c0:	690b      	ldr	r3, [r1, #16]
 80012c2:	f3c3 43c0 	ubfx	r3, r3, #19, #1
 80012c6:	4293      	cmp	r3, r2
 80012c8:	d0fa      	beq.n	80012c0 <main+0xe4>
		dma_tgt = !dma_tgt;											// switch DMA targets
 80012ca:	fab2 f282 	clz	r2, r2
 80012ce:	0952      	lsrs	r2, r2, #5
 80012d0:	f88a 2000 	strb.w	r2, [sl]
		DMA2->LIFCR |= DMA_LIFCR_CTCIF0 | DMA_LIFCR_CHTIF0;			// clear transfer complete and half complete flag
 80012d4:	688b      	ldr	r3, [r1, #8]
		stream_splice(mics);
 80012d6:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
		DMA2->LIFCR |= DMA_LIFCR_CTCIF0 | DMA_LIFCR_CHTIF0;			// clear transfer complete and half complete flag
 80012da:	f043 0330 	orr.w	r3, r3, #48	@ 0x30
 80012de:	608b      	str	r3, [r1, #8]
		stream_splice(mics);
 80012e0:	301c      	adds	r0, #28
 80012e2:	f7ff fd25 	bl	8000d30 <stream_splice>
			arm_fir_f32(&mics[i].bp_hfir, mics[i].raw, mics[i].filtered, N_SAMPLE);
 80012e6:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 80012ea:	f50d 5183 	add.w	r1, sp, #4192	@ 0x1060
 80012ee:	321c      	adds	r2, #28
 80012f0:	311c      	adds	r1, #28
 80012f2:	f50d 5084 	add.w	r0, sp, #4224	@ 0x1080
 80012f6:	f502 52bf 	add.w	r2, r2, #6112	@ 0x17e0
 80012fa:	f501 5183 	add.w	r1, r1, #4192	@ 0x1060
 80012fe:	3008      	adds	r0, #8
 8001300:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 8001304:	3218      	adds	r2, #24
 8001306:	3118      	adds	r1, #24
 8001308:	300c      	adds	r0, #12
 800130a:	f000 fb15 	bl	8001938 <arm_fir_f32>
 800130e:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 8001312:	f50d 5183 	add.w	r1, sp, #4192	@ 0x1060
 8001316:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 800131a:	321c      	adds	r2, #28
 800131c:	311c      	adds	r1, #28
 800131e:	301c      	adds	r0, #28
 8001320:	f502 42ab 	add.w	r2, r2, #21888	@ 0x5580
 8001324:	f501 419c 	add.w	r1, r1, #19968	@ 0x4e00
 8001328:	f500 5078 	add.w	r0, r0, #15872	@ 0x3e00
 800132c:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 8001330:	327c      	adds	r2, #124	@ 0x7c
 8001332:	317c      	adds	r1, #124	@ 0x7c
 8001334:	301c      	adds	r0, #28
 8001336:	f000 faff 	bl	8001938 <arm_fir_f32>
 800133a:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 800133e:	321c      	adds	r2, #28
 8001340:	f502 410c 	add.w	r1, r2, #35840	@ 0x8c00
 8001344:	f502 40f8 	add.w	r0, r2, #31744	@ 0x7c00
 8001348:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800134c:	3180      	adds	r1, #128	@ 0x80
 800134e:	f502 4214 	add.w	r2, r2, #37888	@ 0x9400
 8001352:	3020      	adds	r0, #32
 8001354:	f000 faf0 	bl	8001938 <arm_fir_f32>
		compute_envelope(mics);
 8001358:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 800135c:	301c      	adds	r0, #28
 800135e:	f7ff feeb 	bl	8001138 <compute_envelope>
			arm_copy_f32(mics[i].envelope, mics[i].buffer + window_ind * N_SAMPLE, N_SAMPLE); 		// copy envelope to buffer for processing later
 8001362:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001366:	331c      	adds	r3, #28
 8001368:	f503 511b 	add.w	r1, r3, #9920	@ 0x26c0
 800136c:	f503 50fb 	add.w	r0, r3, #8032	@ 0x1f60
 8001370:	ebc6 1706 	rsb	r7, r6, r6, lsl #4
 8001374:	3138      	adds	r1, #56	@ 0x38
 8001376:	eb01 11c7 	add.w	r1, r1, r7, lsl #7
 800137a:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800137e:	3018      	adds	r0, #24
 8001380:	f000 fba2 	bl	8001ac8 <arm_copy_f32>
 8001384:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001388:	331c      	adds	r3, #28
 800138a:	f503 41c9 	add.w	r1, r3, #25728	@ 0x6480
 800138e:	f503 40ba 	add.w	r0, r3, #23808	@ 0x5d00
 8001392:	01ff      	lsls	r7, r7, #7
 8001394:	317c      	adds	r1, #124	@ 0x7c
 8001396:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800139a:	4439      	add	r1, r7
 800139c:	307c      	adds	r0, #124	@ 0x7c
 800139e:	f000 fb93 	bl	8001ac8 <arm_copy_f32>
 80013a2:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 80013a6:	331c      	adds	r3, #28
 80013a8:	f503 4123 	add.w	r1, r3, #41728	@ 0xa300
 80013ac:	f503 401b 	add.w	r0, r3, #39680	@ 0x9b00
		samples += N_SAMPLE;
 80013b0:	f509 78f0 	add.w	r8, r9, #480	@ 0x1e0
			arm_copy_f32(mics[i].envelope, mics[i].buffer + window_ind * N_SAMPLE, N_SAMPLE); 		// copy envelope to buffer for processing later
 80013b4:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 80013b8:	4439      	add	r1, r7
 80013ba:	3080      	adds	r0, #128	@ 0x80
 80013bc:	f000 fb84 	bl	8001ac8 <arm_copy_f32>
		if (samples == N_SAMPLE)
 80013c0:	f5b8 7ff0 	cmp.w	r8, #480	@ 0x1e0
			arm_copy_f32(mics[i].envelope, mics[i].buffer + window_ind * N_SAMPLE, N_SAMPLE); 		// copy envelope to buffer for processing later
 80013c4:	ea4f 1b06 	mov.w	fp, r6, lsl #4
		if (samples == N_SAMPLE)
 80013c8:	d01e      	beq.n	8001408 <main+0x22c>
		if (!triggered && samples - last_trigger_sample > N_UPDATE_DELAY)			// wait for event detection after N_UPDATE_DELAY samples since last event
 80013ca:	9b03      	ldr	r3, [sp, #12]
 80013cc:	b9ab      	cbnz	r3, 80013fa <main+0x21e>
 80013ce:	9b04      	ldr	r3, [sp, #16]
 80013d0:	eba8 0303 	sub.w	r3, r8, r3
 80013d4:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80013d8:	f200 81cc 	bhi.w	8001774 <main+0x598>
		if (++window_ind == N_WINDOW)
 80013dc:	3601      	adds	r6, #1
 80013de:	b2f6      	uxtb	r6, r6
			window_ind = 0;
 80013e0:	2e02      	cmp	r6, #2
 80013e2:	bf08      	it	eq
 80013e4:	2600      	moveq	r6, #0
			window_ind = 1;
 80013e6:	46c1      	mov	r9, r8
 80013e8:	e767      	b.n	80012ba <main+0xde>
				if (thresh_ind_sorted[i] != -1)
 80013ea:	460b      	mov	r3, r1
					ref_sample = thresh_ind_sorted[i] + window_ind * N_SAMPLE;				// calculate reference sample location in buffer
 80013ec:	ebab 0b06 	sub.w	fp, fp, r6
 80013f0:	eb03 124b 	add.w	r2, r3, fp, lsl #5
					last_trigger_sample = samples - (N_SAMPLE - thresh_ind_sorted[i]);		// compute global sample value
 80013f4:	444b      	add	r3, r9
					ref_sample = thresh_ind_sorted[i] + window_ind * N_SAMPLE;				// calculate reference sample location in buffer
 80013f6:	9206      	str	r2, [sp, #24]
					last_trigger_sample = samples - (N_SAMPLE - thresh_ind_sorted[i]);		// compute global sample value
 80013f8:	9304      	str	r3, [sp, #16]
		if (triggered && samples > last_trigger_sample + N_SAMPLES_AFTER)		// wait until enough samples have been taken after peak is detected
 80013fa:	9b04      	ldr	r3, [sp, #16]
 80013fc:	33e5      	adds	r3, #229	@ 0xe5
 80013fe:	4543      	cmp	r3, r8
 8001400:	d342      	bcc.n	8001488 <main+0x2ac>
 8001402:	2301      	movs	r3, #1
 8001404:	9303      	str	r3, [sp, #12]
 8001406:	e7e9      	b.n	80013dc <main+0x200>
 8001408:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 800140c:	331c      	adds	r3, #28
 800140e:	f503 5777 	add.w	r7, r3, #15808	@ 0x3dc0
				mics[i].thresh = mics[i].noise_mean + k * mics[i].noise_std;
 8001412:	eddf aa1b 	vldr	s21, [pc, #108]	@ 8001480 <main+0x2a4>
			for (uint32_t i = 0; i < N_MICS; i++)
 8001416:	f8dd b014 	ldr.w	fp, [sp, #20]
 800141a:	3738      	adds	r7, #56	@ 0x38
 800141c:	f643 6604 	movw	r6, #15876	@ 0x3e04
				arm_mean_f32(mics[i].envelope, N_SAMPLE, &mics[i].noise_mean);
 8001420:	f5a7 59f4 	sub.w	r9, r7, #7808	@ 0x1e80
 8001424:	463a      	mov	r2, r7
 8001426:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 800142a:	4648      	mov	r0, r9
 800142c:	f000 faf2 	bl	8001a14 <arm_mean_f32>
				arm_std_f32(mics[i].envelope, N_SAMPLE, &mics[i].noise_std);
 8001430:	1d3a      	adds	r2, r7, #4
 8001432:	4648      	mov	r0, r9
 8001434:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 8001438:	f000 fb08 	bl	8001a4c <arm_std_f32>
				mics[i].thresh = mics[i].noise_mean + k * mics[i].noise_std;
 800143c:	ed97 7a01 	vldr	s14, [r7, #4]
 8001440:	edd7 7a00 	vldr	s15, [r7]
 8001444:	eee7 7a2a 	vfma.f32	s15, s14, s21
 8001448:	edc7 7a02 	vstr	s15, [r7, #8]
			for (uint32_t i = 0; i < N_MICS; i++)
 800144c:	4437      	add	r7, r6
 800144e:	455f      	cmp	r7, fp
 8001450:	d1e6      	bne.n	8001420 <main+0x244>
			window_ind = 1;
 8001452:	2601      	movs	r6, #1
 8001454:	46c1      	mov	r9, r8
 8001456:	e730      	b.n	80012ba <main+0xde>
 8001458:	08002cc4 	.word	0x08002cc4
 800145c:	08002d84 	.word	0x08002d84
 8001460:	08002cdc 	.word	0x08002cdc
 8001464:	0501bd00 	.word	0x0501bd00
 8001468:	37d1b717 	.word	0x37d1b717
 800146c:	3f99999a 	.word	0x3f99999a
 8001470:	be4ccccd 	.word	0xbe4ccccd
 8001474:	3e9c0ebf 	.word	0x3e9c0ebf
 8001478:	3f1c0ebf 	.word	0x3f1c0ebf
 800147c:	40026400 	.word	0x40026400
 8001480:	42960000 	.word	0x42960000
 8001484:	20000020 	.word	0x20000020
			int32_t start_sample = (int32_t) ref_sample - N_SAMPLES_BEFORE;
 8001488:	9906      	ldr	r1, [sp, #24]
 800148a:	f1a1 031a 	sub.w	r3, r1, #26
			if (start_sample > 0 && stop_sample < N_BUFFER)					// if N_FFT is not wrapped in buffer...
 800148e:	2b00      	cmp	r3, #0
 8001490:	f340 8138 	ble.w	8001704 <main+0x528>
 8001494:	f240 22da 	movw	r2, #730	@ 0x2da
 8001498:	4291      	cmp	r1, r2
 800149a:	f300 8136 	bgt.w	800170a <main+0x52e>
					arm_copy_f32(mics[i].buffer + start_sample, mics[i].fft_window, N_FFT);
 800149e:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 80014a2:	321c      	adds	r2, #28
 80014a4:	f502 501b 	add.w	r0, r2, #9920	@ 0x26c0
 80014a8:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 80014ac:	3038      	adds	r0, #56	@ 0x38
 80014ae:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 80014b2:	3138      	adds	r1, #56	@ 0x38
 80014b4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80014b8:	009f      	lsls	r7, r3, #2
 80014ba:	f000 fb05 	bl	8001ac8 <arm_copy_f32>
 80014be:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 80014c2:	331c      	adds	r3, #28
 80014c4:	f503 40c9 	add.w	r0, r3, #25728	@ 0x6480
 80014c8:	f503 41e7 	add.w	r1, r3, #29568	@ 0x7380
 80014cc:	307c      	adds	r0, #124	@ 0x7c
 80014ce:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80014d2:	4438      	add	r0, r7
 80014d4:	317c      	adds	r1, #124	@ 0x7c
 80014d6:	f000 faf7 	bl	8001ac8 <arm_copy_f32>
 80014da:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 80014de:	331c      	adds	r3, #28
 80014e0:	f503 4023 	add.w	r0, r3, #41728	@ 0xa300
 80014e4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80014e8:	4438      	add	r0, r7
 80014ea:	f503 4132 	add.w	r1, r3, #45568	@ 0xb200
 80014ee:	f000 faeb 	bl	8001ac8 <arm_copy_f32>
						curr_sample = 0;
 80014f2:	f50d 5b83 	add.w	fp, sp, #4192	@ 0x1060
 80014f6:	f10b 0b1c 	add.w	fp, fp, #28
				arm_rfft_fast_f32(&mics[i].hfft, mics[i].fft_window, mics[i].fft, 0);
 80014fa:	f643 19f8 	movw	r9, #14840	@ 0x39f8
 80014fe:	f243 57f8 	movw	r7, #13816	@ 0x35f8
 8001502:	2300      	movs	r3, #0
 8001504:	eb0b 0209 	add.w	r2, fp, r9
 8001508:	eb0b 0107 	add.w	r1, fp, r7
 800150c:	4658      	mov	r0, fp
 800150e:	f001 f95d 	bl	80027cc <arm_rfft_fast_f32>
			for (uint32_t i = 0; i < N_MICS; i++)
 8001512:	f50b 5b78 	add.w	fp, fp, #15872	@ 0x3e00
 8001516:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 800151a:	f10b 0b04 	add.w	fp, fp, #4
 800151e:	3388      	adds	r3, #136	@ 0x88
 8001520:	459b      	cmp	fp, r3
 8001522:	d1ee      	bne.n	8001502 <main+0x326>
 8001524:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001528:	331c      	adds	r3, #28
 800152a:	f503 42f0 	add.w	r2, r3, #30720	@ 0x7800
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800152e:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 8001532:	3204      	adds	r2, #4
 8001534:	f503 5368 	add.w	r3, r3, #14848	@ 0x3a00
 8001538:	f60d 007c 	addw	r0, sp, #2172	@ 0x87c
 800153c:	f60d 417c 	addw	r1, sp, #3196	@ 0xc7c
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 8001540:	f647 4e08 	movw	lr, #31752	@ 0x7c08
 8001544:	f647 4c0c 	movw	ip, #31756	@ 0x7c0c
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 8001548:	edd3 6a00 	vldr	s13, [r3]
 800154c:	edd2 7a01 	vldr	s15, [r2, #4]
 8001550:	ed93 6a01 	vldr	s12, [r3, #4]
 8001554:	edd2 5a00 	vldr	s11, [r2]
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 8001558:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 800155c:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 8001560:	eea5 7a86 	vfma.f32	s14, s11, s12
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 8001564:	eb03 070c 	add.w	r7, r3, ip
			for (uint32_t i = 2; i < N_FFT; i += 2)
 8001568:	3208      	adds	r2, #8
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 800156a:	eee6 7aa5 	vfma.f32	s15, s13, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 800156e:	3008      	adds	r0, #8
 8001570:	3108      	adds	r1, #8
				float32_t mag_01 = sqrtf(re_01 * re_01 + im_01 * im_01);
 8001572:	ee67 5a07 	vmul.f32	s11, s14, s14
 8001576:	eee7 5aa7 	vfma.f32	s11, s15, s15
 800157a:	eef1 4ae5 	vsqrt.f32	s9, s11
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800157e:	eec5 5a24 	vdiv.f32	s11, s10, s9
 8001582:	ee65 7aa7 	vmul.f32	s15, s11, s15
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001586:	ee65 5a87 	vmul.f32	s11, s11, s14
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800158a:	edc0 7a00 	vstr	s15, [r0]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800158e:	edd7 7a00 	vldr	s15, [r7]
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001592:	edc0 5a01 	vstr	s11, [r0, #4]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 8001596:	eb03 070e 	add.w	r7, r3, lr
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 800159a:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800159e:	edd7 5a00 	vldr	s11, [r7]
 80015a2:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 80015a6:	eea6 7a25 	vfma.f32	s14, s12, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80015aa:	3308      	adds	r3, #8
 80015ac:	42a3      	cmp	r3, r4
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 80015ae:	eee6 7aa5 	vfma.f32	s15, s13, s11
				float32_t mag_02 = sqrtf(re_02 * re_02 + im_02 * im_02);
 80015b2:	ee67 6a07 	vmul.f32	s13, s14, s14
 80015b6:	eee7 6aa7 	vfma.f32	s13, s15, s15
 80015ba:	eeb1 6ae6 	vsqrt.f32	s12, s13
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 80015be:	eec5 6a06 	vdiv.f32	s13, s10, s12
 80015c2:	ee66 7aa7 	vmul.f32	s15, s13, s15
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 80015c6:	ee66 6a87 	vmul.f32	s13, s13, s14
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 80015ca:	edc1 7a00 	vstr	s15, [r1]
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 80015ce:	edc1 6a01 	vstr	s13, [r1, #4]
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80015d2:	d1b9      	bne.n	8001548 <main+0x36c>
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 80015d4:	f50d 53d4 	add.w	r3, sp, #6784	@ 0x1a80
 80015d8:	3308      	adds	r3, #8
 80015da:	f6a3 230c 	subw	r3, r3, #2572	@ 0xa0c
 80015de:	f503 41ef 	add.w	r1, r3, #30592	@ 0x7780
 80015e2:	ed91 6a1f 	vldr	s12, [r1, #124]	@ 0x7c
 80015e6:	f503 5240 	add.w	r2, r3, #12288	@ 0x3000
			xcorr_02_freq[1] = mics[0].fft[1] * mics[2].fft[1];
 80015ea:	f503 4136 	add.w	r1, r3, #46592	@ 0xb600
 80015ee:	edd1 7a01 	vldr	s15, [r1, #4]
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 80015f2:	f602 11f8 	addw	r1, r2, #2552	@ 0x9f8
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 80015f6:	f602 12fc 	addw	r2, r2, #2556	@ 0x9fc
 80015fa:	ed92 5a00 	vldr	s10, [r2]
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 80015fe:	edd1 5a00 	vldr	s11, [r1]
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 8001602:	f503 42f0 	add.w	r2, r3, #30720	@ 0x7800
 8001606:	edd2 6a00 	vldr	s13, [r2]
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 800160a:	f503 4336 	add.w	r3, r3, #46592	@ 0xb600
 800160e:	ed93 7a00 	vldr	s14, [r3]
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 8001612:	ee26 6a25 	vmul.f32	s12, s12, s11
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 8001616:	ee66 6a85 	vmul.f32	s13, s13, s10
			xcorr_02_freq[1] = mics[0].fft[1] * mics[2].fft[1];
 800161a:	ee67 7a85 	vmul.f32	s15, s15, s10
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 800161e:	ee27 7a25 	vmul.f32	s14, s14, s11
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 8001622:	f60d 037c 	addw	r3, sp, #2172	@ 0x87c
 8001626:	ed83 6a00 	vstr	s12, [r3]
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 800162a:	edc3 6a01 	vstr	s13, [r3, #4]
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 800162e:	f60d 437c 	addw	r3, sp, #3196	@ 0xc7c
			xcorr_02_freq[1] = mics[0].fft[1] * mics[2].fft[1];
 8001632:	edc3 7a01 	vstr	s15, [r3, #4]
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 8001636:	ed83 7a00 	vstr	s14, [r3]
			arm_rfft_fast_f32(&xcorr_01_freq_hfft, xcorr_01_freq, xcorr_01_time, 1);
 800163a:	aa1f      	add	r2, sp, #124	@ 0x7c
 800163c:	2301      	movs	r3, #1
 800163e:	f60d 017c 	addw	r1, sp, #2172	@ 0x87c
 8001642:	a813      	add	r0, sp, #76	@ 0x4c
 8001644:	f001 f8c2 	bl	80027cc <arm_rfft_fast_f32>
			arm_rfft_fast_f32(&xcorr_02_freq_hfft, xcorr_02_freq, xcorr_02_time, 1);
 8001648:	2301      	movs	r3, #1
 800164a:	f20d 427c 	addw	r2, sp, #1148	@ 0x47c
 800164e:	f60d 417c 	addw	r1, sp, #3196	@ 0xc7c
 8001652:	a819      	add	r0, sp, #100	@ 0x64
 8001654:	f001 f8ba 	bl	80027cc <arm_rfft_fast_f32>
			arm_max_f32(xcorr_01_time, N_FFT, &dummy, &max_ind_01);
 8001658:	ab09      	add	r3, sp, #36	@ 0x24
 800165a:	aa08      	add	r2, sp, #32
 800165c:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001660:	a81f      	add	r0, sp, #124	@ 0x7c
 8001662:	f000 f9b3 	bl	80019cc <arm_max_f32>
			arm_max_f32(xcorr_02_time, N_FFT, &dummy, &max_ind_02);
 8001666:	ab0a      	add	r3, sp, #40	@ 0x28
 8001668:	aa08      	add	r2, sp, #32
 800166a:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800166e:	f20d 407c 	addw	r0, sp, #1148	@ 0x47c
 8001672:	f000 f9ab 	bl	80019cc <arm_max_f32>
			if (max_ind_01 > N_FFT / 2)
 8001676:	ab09      	add	r3, sp, #36	@ 0x24
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 8001678:	af0b      	add	r7, sp, #44	@ 0x2c
			if (max_ind_01 > N_FFT / 2)
 800167a:	681b      	ldr	r3, [r3, #0]
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 800167c:	ed87 9a00 	vstr	s18, [r7]
			if (max_ind_01 > N_FFT / 2)
 8001680:	2b80      	cmp	r3, #128	@ 0x80
				lag01 = (int32_t) max_ind_01 - N_FFT;
 8001682:	bf88      	it	hi
 8001684:	f5a3 7380 	subhi.w	r3, r3, #256	@ 0x100
				lag01 = max_ind_01;
 8001688:	ee00 3a10 	vmov	s0, r3
			if (max_ind_02 > N_FFT / 2)
 800168c:	ab0a      	add	r3, sp, #40	@ 0x28
			float32_t mic01_delay = -((float32_t) lag01 * T_SAMPLE);
 800168e:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
			if (max_ind_02 > N_FFT / 2)
 8001692:	681b      	ldr	r3, [r3, #0]
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 8001694:	edc7 8a01 	vstr	s17, [r7, #4]
			if (max_ind_02 > N_FFT / 2)
 8001698:	2b80      	cmp	r3, #128	@ 0x80
				lag02 = (int32_t) max_ind_02 - N_FFT;
 800169a:	bf88      	it	hi
 800169c:	f5a3 7380 	subhi.w	r3, r3, #256	@ 0x100
			float32_t mic02_delay = -((float32_t) lag02 * T_SAMPLE);
 80016a0:	ee07 3a90 	vmov	s15, r3
 80016a4:	eef8 0ae7 	vcvt.f32.s32	s1, s15
			uint8_t valid = compute_event_pos(&coords.xy[0], &coords.xy[1], mics_xy, mic01_delay, mic02_delay);
 80016a8:	ee28 0a40 	vnmul.f32	s0, s16, s0
 80016ac:	ee68 0a60 	vnmul.f32	s1, s16, s1
 80016b0:	aa0d      	add	r2, sp, #52	@ 0x34
 80016b2:	a90c      	add	r1, sp, #48	@ 0x30
 80016b4:	4638      	mov	r0, r7
 80016b6:	f7ff fc0b 	bl	8000ed0 <compute_event_pos>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 80016ba:	b1c0      	cbz	r0, 80016ee <main+0x512>
 80016bc:	edd7 7a00 	vldr	s15, [r7]
 80016c0:	eef4 7ae9 	vcmpe.f32	s15, s19
 80016c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80016c8:	dc11      	bgt.n	80016ee <main+0x512>
 80016ca:	eef4 7aca 	vcmpe.f32	s15, s20
 80016ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80016d2:	d40c      	bmi.n	80016ee <main+0x512>
 80016d4:	edd7 7a01 	vldr	s15, [r7, #4]
 80016d8:	eef4 7ae9 	vcmpe.f32	s15, s19
 80016dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80016e0:	dc05      	bgt.n	80016ee <main+0x512>
 80016e2:	eef4 7aca 	vcmpe.f32	s15, s20
 80016e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80016ea:	f140 80cf 	bpl.w	800188c <main+0x6b0>
				coords.xy[0] = -1.0f;
 80016ee:	ab0b      	add	r3, sp, #44	@ 0x2c
 80016f0:	4a6a      	ldr	r2, [pc, #424]	@ (800189c <main+0x6c0>)
 80016f2:	601a      	str	r2, [r3, #0]
				coords.xy[1] = -1.0f;
 80016f4:	605a      	str	r2, [r3, #4]
				uart2_dma1_write(8, coords.ser);
 80016f6:	4619      	mov	r1, r3
 80016f8:	2008      	movs	r0, #8
 80016fa:	f001 fa6d 	bl	8002bd8 <uart2_dma1_write>
			triggered = 0;
 80016fe:	2300      	movs	r3, #0
 8001700:	9303      	str	r3, [sp, #12]
 8001702:	e66b      	b.n	80013dc <main+0x200>
				if (start_sample < 0)
 8001704:	d001      	beq.n	800170a <main+0x52e>
					curr_sample = (int32_t)N_BUFFER + start_sample;			// if start is on other end of buffer, move pointer back
 8001706:	f201 33a6 	addw	r3, r1, #934	@ 0x3a6
				for (uint32_t i = 0; i < N_FFT; i++)
 800170a:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 800170e:	321c      	adds	r2, #28
 8001710:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 8001714:	f502 47e7 	add.w	r7, r2, #29568	@ 0x7380
 8001718:	f502 4c32 	add.w	ip, r2, #45568	@ 0xb200
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 800171c:	f50d 52d4 	add.w	r2, sp, #6784	@ 0x1a80
 8001720:	3208      	adds	r2, #8
 8001722:	3138      	adds	r1, #56	@ 0x38
 8001724:	377c      	adds	r7, #124	@ 0x7c
 8001726:	f6a2 200c 	subw	r0, r2, #2572	@ 0xa0c
 800172a:	f641 1e3f 	movw	lr, #6463	@ 0x193f
 800172e:	f603 12be 	addw	r2, r3, #2494	@ 0x9be
 8001732:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8001736:	f8d2 9000 	ldr.w	r9, [r2]
 800173a:	f841 9b04 	str.w	r9, [r1], #4
 800173e:	eb03 020e 	add.w	r2, r3, lr
 8001742:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8001746:	f8d2 9000 	ldr.w	r9, [r2]
 800174a:	f847 9b04 	str.w	r9, [r7], #4
 800174e:	f503 5223 	add.w	r2, r3, #10432	@ 0x28c0
 8001752:	eb00 0282 	add.w	r2, r0, r2, lsl #2
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 8001756:	3301      	adds	r3, #1
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 8001758:	6812      	ldr	r2, [r2, #0]
 800175a:	f84c 2b04 	str.w	r2, [ip], #4
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 800175e:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
 8001762:	d002      	beq.n	800176a <main+0x58e>
				for (uint32_t i = 0; i < N_FFT; i++)
 8001764:	428d      	cmp	r5, r1
 8001766:	d1e2      	bne.n	800172e <main+0x552>
 8001768:	e6c3      	b.n	80014f2 <main+0x316>
 800176a:	428d      	cmp	r5, r1
 800176c:	f43f aec1 	beq.w	80014f2 <main+0x316>
						curr_sample = 0;
 8001770:	2300      	movs	r3, #0
 8001772:	e7dc      	b.n	800172e <main+0x552>
 8001774:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001778:	331c      	adds	r3, #28
			for (uint32_t i = 0; i < N_MICS; i++)
 800177a:	f8dd c01c 	ldr.w	ip, [sp, #28]
 800177e:	f503 5178 	add.w	r1, r3, #15872	@ 0x3e00
 8001782:	f60d 407c 	addw	r0, sp, #3196	@ 0xc7c
 8001786:	f643 6704 	movw	r7, #15876	@ 0x3e04
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, mics[i].thresh);
 800178a:	f5a1 52f4 	sub.w	r2, r1, #7808	@ 0x1e80
 800178e:	ed91 7a00 	vldr	s14, [r1]
 8001792:	3a08      	subs	r2, #8

}

int32_t thresh_search(float32_t * src, uint32_t len, float32_t thresh)
{
	for (uint32_t i = 0; i < len; i++)
 8001794:	2300      	movs	r3, #0
 8001796:	e003      	b.n	80017a0 <main+0x5c4>
 8001798:	3301      	adds	r3, #1
 800179a:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800179e:	d060      	beq.n	8001862 <main+0x686>
	{
		if (src[i] > thresh)
 80017a0:	ecf2 7a01 	vldmia	r2!, {s15}
 80017a4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80017a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80017ac:	d5f4      	bpl.n	8001798 <main+0x5bc>
			for (uint32_t i = 0; i < N_MICS; i++)
 80017ae:	4439      	add	r1, r7
 80017b0:	4561      	cmp	r1, ip
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, mics[i].thresh);
 80017b2:	f840 3b04 	str.w	r3, [r0], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 80017b6:	d1e8      	bne.n	800178a <main+0x5ae>
}

void simple_sort3(int32_t * src, int32_t * dst)
{

	if (src[0] <= src[1] && src[0] <= src[2])
 80017b8:	f60d 417c 	addw	r1, sp, #3196	@ 0xc7c
 80017bc:	e9d1 2300 	ldrd	r2, r3, [r1]
 80017c0:	429a      	cmp	r2, r3
 80017c2:	6889      	ldr	r1, [r1, #8]
 80017c4:	dd55      	ble.n	8001872 <main+0x696>
		{
			dst[1] = src[2];
			dst[2] = src[1];
		}
	}
	else if (src[1] <= src[0] && src[1] <= src[2])
 80017c6:	428b      	cmp	r3, r1
 80017c8:	dc5c      	bgt.n	8001884 <main+0x6a8>
	{
		dst[0] = src[1];

		if (src[0] <= src[2])
 80017ca:	428a      	cmp	r2, r1
 80017cc:	4608      	mov	r0, r1
		dst[0] = src[1];
 80017ce:	4619      	mov	r1, r3
		if (src[0] <= src[2])
 80017d0:	dd5a      	ble.n	8001888 <main+0x6ac>
			dst[2] = src[2];
		}
		else
		{
			dst[1] = src[2];
			dst[2] = src[0];
 80017d2:	4613      	mov	r3, r2
			dst[1] = src[2];
 80017d4:	4602      	mov	r2, r0
				if (thresh_ind_sorted[i] != -1)
 80017d6:	1c48      	adds	r0, r1, #1
 80017d8:	f47f ae07 	bne.w	80013ea <main+0x20e>
 80017dc:	1c51      	adds	r1, r2, #1
 80017de:	d15a      	bne.n	8001896 <main+0x6ba>
 80017e0:	1c5a      	adds	r2, r3, #1
 80017e2:	f47f ae03 	bne.w	80013ec <main+0x210>
 80017e6:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 80017ea:	331c      	adds	r3, #28
 80017ec:	f503 5777 	add.w	r7, r3, #15808	@ 0x3dc0
		mics[i].noise_mean = (1 - alpha) * mics[i].noise_mean + alpha * mean;
 80017f0:	ed9f ba2b 	vldr	s22, [pc, #172]	@ 80018a0 <main+0x6c4>
 80017f4:	eddf aa2b 	vldr	s21, [pc, #172]	@ 80018a4 <main+0x6c8>
		mics[i].thresh = mics[i].noise_mean + k * mics[i].noise_std;
 80017f8:	eddf ba2b 	vldr	s23, [pc, #172]	@ 80018a8 <main+0x6cc>
 80017fc:	f8dd b014 	ldr.w	fp, [sp, #20]
 8001800:	3738      	adds	r7, #56	@ 0x38
		arm_mean_f32(mics[i].envelope, N_SAMPLE, &mean);
 8001802:	f5a7 59f4 	sub.w	r9, r7, #7808	@ 0x1e80
 8001806:	aa0b      	add	r2, sp, #44	@ 0x2c
 8001808:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 800180c:	4648      	mov	r0, r9
 800180e:	f000 f901 	bl	8001a14 <arm_mean_f32>
		arm_std_f32(mics[i].envelope, N_SAMPLE, &std);
 8001812:	f60d 027c 	addw	r2, sp, #2172	@ 0x87c
 8001816:	4648      	mov	r0, r9
 8001818:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 800181c:	f000 f916 	bl	8001a4c <arm_std_f32>
		mics[i].noise_mean = (1 - alpha) * mics[i].noise_mean + alpha * mean;
 8001820:	eddd 7a0b 	vldr	s15, [sp, #44]	@ 0x2c
 8001824:	ed97 7a00 	vldr	s14, [r7]
		mics[i].noise_std = (1 - alpha) * mics[i].noise_std + alpha * std;
 8001828:	edd7 6a01 	vldr	s13, [r7, #4]
		mics[i].noise_mean = (1 - alpha) * mics[i].noise_mean + alpha * mean;
 800182c:	ee67 7a8b 	vmul.f32	s15, s15, s22
 8001830:	ab0b      	add	r3, sp, #44	@ 0x2c
		mics[i].noise_std = (1 - alpha) * mics[i].noise_std + alpha * std;
 8001832:	f60d 037c 	addw	r3, sp, #2172	@ 0x87c
		mics[i].noise_mean = (1 - alpha) * mics[i].noise_mean + alpha * mean;
 8001836:	eee7 7a2a 	vfma.f32	s15, s14, s21
		mics[i].noise_std = (1 - alpha) * mics[i].noise_std + alpha * std;
 800183a:	ed93 7a00 	vldr	s14, [r3]
		mics[i].noise_mean = (1 - alpha) * mics[i].noise_mean + alpha * mean;
 800183e:	edc7 7a00 	vstr	s15, [r7]
		mics[i].noise_std = (1 - alpha) * mics[i].noise_std + alpha * std;
 8001842:	ee27 7a0b 	vmul.f32	s14, s14, s22
 8001846:	eea6 7aaa 	vfma.f32	s14, s13, s21
		mics[i].thresh = mics[i].noise_mean + k * mics[i].noise_std;
 800184a:	eee7 7a2b 	vfma.f32	s15, s14, s23
		mics[i].noise_std = (1 - alpha) * mics[i].noise_std + alpha * std;
 800184e:	ed87 7a01 	vstr	s14, [r7, #4]
		mics[i].thresh = mics[i].noise_mean + k * mics[i].noise_std;
 8001852:	edc7 7a02 	vstr	s15, [r7, #8]
	for (uint32_t i = 0; i < N_MICS; i++)
 8001856:	f507 5778 	add.w	r7, r7, #15872	@ 0x3e00
 800185a:	3704      	adds	r7, #4
 800185c:	45bb      	cmp	fp, r7
 800185e:	d1d0      	bne.n	8001802 <main+0x626>
 8001860:	e5bc      	b.n	80013dc <main+0x200>
			for (uint32_t i = 0; i < N_MICS; i++)
 8001862:	4439      	add	r1, r7
	return -1;
 8001864:	f04f 33ff 	mov.w	r3, #4294967295
			for (uint32_t i = 0; i < N_MICS; i++)
 8001868:	4561      	cmp	r1, ip
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, mics[i].thresh);
 800186a:	f840 3b04 	str.w	r3, [r0], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 800186e:	d18c      	bne.n	800178a <main+0x5ae>
 8001870:	e7a2      	b.n	80017b8 <main+0x5dc>
	if (src[0] <= src[1] && src[0] <= src[2])
 8001872:	428a      	cmp	r2, r1
 8001874:	dcaf      	bgt.n	80017d6 <main+0x5fa>
		if (src[1] <= src[2])
 8001876:	428b      	cmp	r3, r1
 8001878:	4608      	mov	r0, r1
		dst[0] = src[0];
 800187a:	4611      	mov	r1, r2
		if (src[1] <= src[2])
 800187c:	dcaa      	bgt.n	80017d4 <main+0x5f8>
			dst[1] = src[0];
			dst[2] = src[1];
		}
		else
		{
			dst[1] = src[1];
 800187e:	461a      	mov	r2, r3
			dst[2] = src[0];
 8001880:	4603      	mov	r3, r0
 8001882:	e7a8      	b.n	80017d6 <main+0x5fa>
	else if (src[1] <= src[0] && src[1] <= src[2])
 8001884:	4610      	mov	r0, r2
 8001886:	e7fa      	b.n	800187e <main+0x6a2>
			dst[2] = src[2];
 8001888:	4603      	mov	r3, r0
 800188a:	e7a4      	b.n	80017d6 <main+0x5fa>
				uart2_dma1_write(8, coords.ser);
 800188c:	a90b      	add	r1, sp, #44	@ 0x2c
 800188e:	2008      	movs	r0, #8
 8001890:	f001 f9a2 	bl	8002bd8 <uart2_dma1_write>
 8001894:	e733      	b.n	80016fe <main+0x522>
				if (thresh_ind_sorted[i] != -1)
 8001896:	4613      	mov	r3, r2
 8001898:	e5a8      	b.n	80013ec <main+0x210>
 800189a:	bf00      	nop
 800189c:	bf800000 	.word	0xbf800000
 80018a0:	3cf5c28f 	.word	0x3cf5c28f
 80018a4:	3f7851ec 	.word	0x3f7851ec
 80018a8:	42960000 	.word	0x42960000

080018ac <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80018ac:	e7fe      	b.n	80018ac <NMI_Handler>
 80018ae:	bf00      	nop

080018b0 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80018b0:	e7fe      	b.n	80018b0 <HardFault_Handler>
 80018b2:	bf00      	nop

080018b4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80018b4:	e7fe      	b.n	80018b4 <MemManage_Handler>
 80018b6:	bf00      	nop

080018b8 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80018b8:	e7fe      	b.n	80018b8 <BusFault_Handler>
 80018ba:	bf00      	nop

080018bc <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80018bc:	e7fe      	b.n	80018bc <UsageFault_Handler>
 80018be:	bf00      	nop

080018c0 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80018c0:	4770      	bx	lr
 80018c2:	bf00      	nop

080018c4 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 80018c4:	4770      	bx	lr
 80018c6:	bf00      	nop

080018c8 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 80018c8:	4770      	bx	lr
 80018ca:	bf00      	nop

080018cc <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80018cc:	f001 b846 	b.w	800295c <HAL_IncTick>

080018d0 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80018d0:	4a03      	ldr	r2, [pc, #12]	@ (80018e0 <SystemInit+0x10>)
 80018d2:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 80018d6:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 80018da:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80018de:	4770      	bx	lr
 80018e0:	e000ed00 	.word	0xe000ed00

080018e4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 80018e4:	f8df d034 	ldr.w	sp, [pc, #52]	@ 800191c <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit  
 80018e8:	f7ff fff2 	bl	80018d0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 80018ec:	480c      	ldr	r0, [pc, #48]	@ (8001920 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 80018ee:	490d      	ldr	r1, [pc, #52]	@ (8001924 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 80018f0:	4a0d      	ldr	r2, [pc, #52]	@ (8001928 <LoopFillZerobss+0x1a>)
  movs r3, #0
 80018f2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80018f4:	e002      	b.n	80018fc <LoopCopyDataInit>

080018f6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80018f6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80018f8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80018fa:	3304      	adds	r3, #4

080018fc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80018fc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80018fe:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001900:	d3f9      	bcc.n	80018f6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001902:	4a0a      	ldr	r2, [pc, #40]	@ (800192c <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001904:	4c0a      	ldr	r4, [pc, #40]	@ (8001930 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001906:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001908:	e001      	b.n	800190e <LoopFillZerobss>

0800190a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800190a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800190c:	3204      	adds	r2, #4

0800190e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800190e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001910:	d3fb      	bcc.n	800190a <FillZerobss>
 
/* Call static constructors */
    bl __libc_init_array
 8001912:	f001 f9a7 	bl	8002c64 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001916:	f7ff fc61 	bl	80011dc <main>
  bx  lr    
 800191a:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 800191c:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 8001920:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001924:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 8001928:	080037e4 	.word	0x080037e4
  ldr r2, =_sbss
 800192c:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 8001930:	200016ac 	.word	0x200016ac

08001934 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001934:	e7fe      	b.n	8001934 <ADC_IRQHandler>
	...

08001938 <arm_fir_f32>:
ARM_DSP_ATTRIBUTE void arm_fir_f32(
  const arm_fir_instance_f32 * S,
  const float32_t * pSrc,
        float32_t * pDst,
        uint32_t blockSize)
{
 8001938:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800193c:	4690      	mov	r8, r2
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
        float32_t *pStateCurnt;                        /* Points to the current sample of the state */
        float32_t *px;                                 /* Temporary pointer for state buffer */
  const float32_t *pb;                                 /* Temporary pointer for coefficient buffer */
        float32_t acc0;                                /* Accumulator */
        uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
 800193e:	8802      	ldrh	r2, [r0, #0]
        float32_t *pState = S->pState;                 /* State pointer */
 8001940:	6846      	ldr	r6, [r0, #4]
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
 8001942:	f8d0 9008 	ldr.w	r9, [r0, #8]
        float32_t c0;                                           /* Temporary variable to hold coefficient value */
#endif

  /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
  /* pStateCurnt points to the location where the new input data should be written */
  pStateCurnt = &(S->pState[(numTaps - 1U)]);
 8001946:	f102 4080 	add.w	r0, r2, #1073741824	@ 0x40000000
 800194a:	3801      	subs	r0, #1
 800194c:	eb06 0580 	add.w	r5, r6, r0, lsl #2
  /* Initialize blkCnt with number of taps */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001950:	b33b      	cbz	r3, 80019a2 <arm_fir_f32+0x6a>
 8001952:	460f      	mov	r7, r1
 8001954:	461c      	mov	r4, r3
  blkCnt = blockSize;
 8001956:	4619      	mov	r1, r3
        float32_t *pState = S->pState;                 /* State pointer */
 8001958:	4633      	mov	r3, r6
  {
    /* Copy one sample at a time into state buffer */
    *pStateCurnt++ = *pSrc++;
 800195a:	f857 0b04 	ldr.w	r0, [r7], #4
 800195e:	f845 0b04 	str.w	r0, [r5], #4

    /* Set the accumulator to zero */
    acc0 = 0.0f;
 8001962:	eddf 7a11 	vldr	s15, [pc, #68]	@ 80019a8 <arm_fir_f32+0x70>
    pb = pCoeffs;

    i = numTaps;

    /* Perform the multiply-accumulates */
    while (i > 0U)
 8001966:	b152      	cbz	r2, 800197e <arm_fir_f32+0x46>
    i = numTaps;
 8001968:	4610      	mov	r0, r2
    pb = pCoeffs;
 800196a:	46ce      	mov	lr, r9
    px = pState;
 800196c:	469c      	mov	ip, r3
    {
      /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
      acc0 += *px++ * *pb++;
 800196e:	ecfc 6a01 	vldmia	ip!, {s13}
 8001972:	ecbe 7a01 	vldmia	lr!, {s14}
    while (i > 0U)
 8001976:	3801      	subs	r0, #1
      acc0 += *px++ * *pb++;
 8001978:	eee6 7a87 	vfma.f32	s15, s13, s14
    while (i > 0U)
 800197c:	d1f7      	bne.n	800196e <arm_fir_f32+0x36>
  while (blkCnt > 0U)
 800197e:	3901      	subs	r1, #1

      i--;
    }

    /* Store result in destination buffer. */
    *pDst++ = acc0;
 8001980:	ece8 7a01 	vstmia	r8!, {s15}

    /* Advance state pointer by 1 for the next sample */
    pState = pState + 1U;
 8001984:	f103 0304 	add.w	r3, r3, #4
  while (blkCnt > 0U)
 8001988:	d1e7      	bne.n	800195a <arm_fir_f32+0x22>
 800198a:	eb06 0184 	add.w	r1, r6, r4, lsl #2
  tapCnt = (numTaps - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  /* Copy remaining data */
  while (tapCnt > 0U)
 800198e:	1e53      	subs	r3, r2, #1
 8001990:	d005      	beq.n	800199e <arm_fir_f32+0x66>
  {
    *pStateCurnt++ = *pState++;
 8001992:	f851 2b04 	ldr.w	r2, [r1], #4
 8001996:	f846 2b04 	str.w	r2, [r6], #4
  while (tapCnt > 0U)
 800199a:	3b01      	subs	r3, #1
 800199c:	d1f9      	bne.n	8001992 <arm_fir_f32+0x5a>

    /* Decrement loop counter */
    tapCnt--;
  }

}
 800199e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        float32_t *pState = S->pState;                 /* State pointer */
 80019a2:	4631      	mov	r1, r6
 80019a4:	e7f3      	b.n	800198e <arm_fir_f32+0x56>
 80019a6:	bf00      	nop
 80019a8:	00000000 	.word	0x00000000

080019ac <arm_fir_init_f32>:
        arm_fir_instance_f32 * S,
        uint16_t numTaps,
  const float32_t * pCoeffs,
        float32_t * pState,
        uint32_t blockSize)
{
 80019ac:	b510      	push	{r4, lr}
 80019ae:	4604      	mov	r4, r0

  /* Clear state buffer. The size is always (blockSize + numTaps - 1) */
#if defined(ARM_MATH_MVEF) && !defined(ARM_MATH_AUTOVECTORIZE)
  memset(pState, 0, (numTaps + (blockSize - 1U) + blockSize) * sizeof(float32_t));
#else
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019b0:	9802      	ldr	r0, [sp, #8]
  S->numTaps = numTaps;
 80019b2:	8021      	strh	r1, [r4, #0]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019b4:	f100 3cff 	add.w	ip, r0, #4294967295
 80019b8:	448c      	add	ip, r1
  S->pCoeffs = pCoeffs;
 80019ba:	60a2      	str	r2, [r4, #8]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80019bc:	2100      	movs	r1, #0
 80019be:	ea4f 028c 	mov.w	r2, ip, lsl #2
 80019c2:	4618      	mov	r0, r3
 80019c4:	f001 f946 	bl	8002c54 <memset>
#endif
  /* Assign state pointer */
  S->pState = pState;
 80019c8:	6060      	str	r0, [r4, #4]
}
 80019ca:	bd10      	pop	{r4, pc}

080019cc <arm_max_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = (blockSize - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 80019cc:	2901      	cmp	r1, #1
{
 80019ce:	b410      	push	{r4}
  out = *pSrc++;
 80019d0:	ecf0 7a01 	vldmia	r0!, {s15}
  while (blkCnt > 0U)
 80019d4:	d017      	beq.n	8001a06 <arm_max_f32+0x3a>
 80019d6:	f04f 0c01 	mov.w	ip, #1
  outIndex = 0U;
 80019da:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal = *pSrc++;
 80019dc:	ecb0 7a01 	vldmia	r0!, {s14}

    /* compare for the maximum value */
    if (out < maxVal)
    {
      /* Update the maximum value and it's index */
      out = maxVal;
 80019e0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80019e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80019e8:	bf48      	it	mi
 80019ea:	4664      	movmi	r4, ip
  while (blkCnt > 0U)
 80019ec:	f10c 0c01 	add.w	ip, ip, #1
      out = maxVal;
 80019f0:	bf48      	it	mi
 80019f2:	eef0 7a47 	vmovmi.f32	s15, s14
  while (blkCnt > 0U)
 80019f6:	4561      	cmp	r1, ip
 80019f8:	d1f0      	bne.n	80019dc <arm_max_f32+0x10>
    /* Decrement loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 80019fa:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 80019fe:	601c      	str	r4, [r3, #0]
}
 8001a00:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a04:	4770      	bx	lr
  outIndex = 0U;
 8001a06:	2400      	movs	r4, #0
  *pResult = out;
 8001a08:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 8001a0c:	601c      	str	r4, [r3, #0]
}
 8001a0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a12:	4770      	bx	lr

08001a14 <arm_mean_f32>:
#else
ARM_DSP_ATTRIBUTE void arm_mean_f32(
  const float32_t * pSrc,
        uint32_t blockSize,
        float32_t * pResult)
{
 8001a14:	b082      	sub	sp, #8
  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001a16:	9101      	str	r1, [sp, #4]
 8001a18:	b191      	cbz	r1, 8001a40 <arm_mean_f32+0x2c>
        float32_t sum = 0.0f;                          /* Temporary result storage */
 8001a1a:	eddf 7a0b 	vldr	s15, [pc, #44]	@ 8001a48 <arm_mean_f32+0x34>
 8001a1e:	460b      	mov	r3, r1
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 8001a20:	ecb0 7a01 	vldmia	r0!, {s14}
  while (blkCnt > 0U)
 8001a24:	3b01      	subs	r3, #1
    sum += *pSrc++;
 8001a26:	ee77 7a87 	vadd.f32	s15, s15, s14
  while (blkCnt > 0U)
 8001a2a:	d1f9      	bne.n	8001a20 <arm_mean_f32+0xc>
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store result to destination */
  *pResult = (sum / blockSize);
 8001a2c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8001a30:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8001a34:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8001a38:	edc2 6a00 	vstr	s13, [r2]
}
 8001a3c:	b002      	add	sp, #8
 8001a3e:	4770      	bx	lr
        float32_t sum = 0.0f;                          /* Temporary result storage */
 8001a40:	eddf 7a01 	vldr	s15, [pc, #4]	@ 8001a48 <arm_mean_f32+0x34>
 8001a44:	e7f2      	b.n	8001a2c <arm_mean_f32+0x18>
 8001a46:	bf00      	nop
 8001a48:	00000000 	.word	0x00000000

08001a4c <arm_std_f32>:
 */
ARM_DSP_ATTRIBUTE void arm_std_f32(
  const float32_t * pSrc,
        uint32_t blockSize,
        float32_t * pResult)
{
 8001a4c:	b510      	push	{r4, lr}
 8001a4e:	b082      	sub	sp, #8
 8001a50:	4614      	mov	r4, r2
  float32_t var;
  arm_var_f32(pSrc,blockSize,&var);
 8001a52:	aa01      	add	r2, sp, #4
 8001a54:	f000 f810 	bl	8001a78 <arm_var_f32>
  arm_sqrt_f32(var, pResult);
 8001a58:	eddd 7a01 	vldr	s15, [sp, #4]
    if (in >= 0.0f)
 8001a5c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8001a60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001a64:	db05      	blt.n	8001a72 <arm_std_f32+0x26>
      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 8001a66:	eef1 7ae7 	vsqrt.f32	s15, s15
 8001a6a:	edc4 7a00 	vstr	s15, [r4]
}
 8001a6e:	b002      	add	sp, #8
 8001a70:	bd10      	pop	{r4, pc}
 8001a72:	2300      	movs	r3, #0
      *pOut = 0.0f;
 8001a74:	6023      	str	r3, [r4, #0]
 8001a76:	e7fa      	b.n	8001a6e <arm_std_f32+0x22>

08001a78 <arm_var_f32>:
        float32_t sum = 0.0f;                          /* Temporary result storage */
        float32_t fSum = 0.0f;
        float32_t fMean, fValue;
  const float32_t * pInput = pSrc;

  if (blockSize <= 1U)
 8001a78:	2901      	cmp	r1, #1
 8001a7a:	eddf 7a12 	vldr	s15, [pc, #72]	@ 8001ac4 <arm_var_f32+0x4c>
 8001a7e:	d91d      	bls.n	8001abc <arm_var_f32+0x44>
  const float32_t * pInput = pSrc;
 8001a80:	4684      	mov	ip, r0
  blkCnt = blockSize % 0x4U;

#else

  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;
 8001a82:	460b      	mov	r3, r1

  while (blkCnt > 0U)
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */

    sum += *pInput++;
 8001a84:	ecbc 7a01 	vldmia	ip!, {s14}
  while (blkCnt > 0U)
 8001a88:	3b01      	subs	r3, #1
    sum += *pInput++;
 8001a8a:	ee77 7a87 	vadd.f32	s15, s15, s14
  while (blkCnt > 0U)
 8001a8e:	d1f9      	bne.n	8001a84 <arm_var_f32+0xc>
    /* Decrement loop counter */
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  fMean = sum / (float32_t) blockSize;
 8001a90:	ee07 1a10 	vmov	s14, r1
 8001a94:	eeb8 6a47 	vcvt.f32.u32	s12, s14
        float32_t fSum = 0.0f;
 8001a98:	ed9f 7a0a 	vldr	s14, [pc, #40]	@ 8001ac4 <arm_var_f32+0x4c>
  fMean = sum / (float32_t) blockSize;
 8001a9c:	eec7 6a86 	vdiv.f32	s13, s15, s12
  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001aa0:	3901      	subs	r1, #1
  {
    fValue = *pInput++ - fMean;
 8001aa2:	ecf0 7a01 	vldmia	r0!, {s15}
 8001aa6:	ee77 7ae6 	vsub.f32	s15, s15, s13
    fSum += fValue * fValue;
 8001aaa:	eea7 7aa7 	vfma.f32	s14, s15, s15
  while (blkCnt > 0U)
 8001aae:	d1f7      	bne.n	8001aa0 <arm_var_f32+0x28>
    /* Decrement loop counter */
    blkCnt--;
  }

  /* Variance */
  *pResult = fSum / (float32_t)(blockSize - 1.0f);
 8001ab0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8001ab4:	ee36 6a67 	vsub.f32	s12, s12, s15
 8001ab8:	eec7 7a06 	vdiv.f32	s15, s14, s12
    *pResult = 0;
 8001abc:	edc2 7a00 	vstr	s15, [r2]
}
 8001ac0:	4770      	bx	lr
 8001ac2:	bf00      	nop
 8001ac4:	00000000 	.word	0x00000000

08001ac8 <arm_copy_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001ac8:	b12a      	cbz	r2, 8001ad6 <arm_copy_f32+0xe>
  {
    /* C = A */

    /* Copy and store result in destination buffer */
    *pDst++ = *pSrc++;
 8001aca:	f850 3b04 	ldr.w	r3, [r0], #4
 8001ace:	f841 3b04 	str.w	r3, [r1], #4
  while (blkCnt > 0U)
 8001ad2:	3a01      	subs	r2, #1
 8001ad4:	d1f9      	bne.n	8001aca <arm_copy_f32+0x2>

    /* Decrement loop counter */
    blkCnt--;
  }
}
 8001ad6:	4770      	bx	lr

08001ad8 <arm_bitreversal_32>:
  const uint16_t bitRevLen,
  const uint16_t *pBitRevTab)
{
  uint32_t a, b, i, tmp;

  for (i = 0; i < bitRevLen; )
 8001ad8:	b331      	cbz	r1, 8001b28 <arm_bitreversal_32+0x50>
{
 8001ada:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  for (i = 0; i < bitRevLen; )
 8001ade:	f04f 0e00 	mov.w	lr, #0
 8001ae2:	f102 0802 	add.w	r8, r2, #2
  {
     a = pBitRevTab[i    ] >> 2;
 8001ae6:	f832 c01e 	ldrh.w	ip, [r2, lr, lsl #1]
     b = pBitRevTab[i + 1] >> 2;
 8001aea:	f838 301e 	ldrh.w	r3, [r8, lr, lsl #1]
     a = pBitRevTab[i    ] >> 2;
 8001aee:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
     b = pBitRevTab[i + 1] >> 2;
 8001af2:	089b      	lsrs	r3, r3, #2

     //real
     tmp = pSrc[a];
 8001af4:	f850 702c 	ldr.w	r7, [r0, ip, lsl #2]
     pSrc[a] = pSrc[b];
 8001af8:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]
 8001afc:	f840 602c 	str.w	r6, [r0, ip, lsl #2]
     tmp = pSrc[a];
 8001b00:	ea4f 058c 	mov.w	r5, ip, lsl #2
     pSrc[a] = pSrc[b];
 8001b04:	009c      	lsls	r4, r3, #2
     pSrc[b] = tmp;
 8001b06:	f840 7023 	str.w	r7, [r0, r3, lsl #2]

     //complex
     tmp = pSrc[a+1];
 8001b0a:	f105 0c04 	add.w	ip, r5, #4
     pSrc[a+1] = pSrc[b+1];
 8001b0e:	1d23      	adds	r3, r4, #4
     pSrc[b+1] = tmp;

    i += 2;
 8001b10:	f10e 0e02 	add.w	lr, lr, #2
     tmp = pSrc[a+1];
 8001b14:	f850 500c 	ldr.w	r5, [r0, ip]
     pSrc[a+1] = pSrc[b+1];
 8001b18:	58c4      	ldr	r4, [r0, r3]
 8001b1a:	f840 400c 	str.w	r4, [r0, ip]
  for (i = 0; i < bitRevLen; )
 8001b1e:	458e      	cmp	lr, r1
     pSrc[b+1] = tmp;
 8001b20:	50c5      	str	r5, [r0, r3]
  for (i = 0; i < bitRevLen; )
 8001b22:	d3e0      	bcc.n	8001ae6 <arm_bitreversal_32+0xe>
  }
}
 8001b24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001b28:	4770      	bx	lr
 8001b2a:	bf00      	nop

08001b2c <arm_cfft_f32>:
ARM_DSP_ATTRIBUTE void arm_cfft_f32(
  const arm_cfft_instance_f32 * S,
        float32_t * p1,
        uint8_t ifftFlag,
        uint8_t bitReverseFlag)
{
 8001b2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001b30:	ed2d 8b0a 	vpush	{d8-d12}
 8001b34:	b08f      	sub	sp, #60	@ 0x3c
  uint32_t  L = S->fftLen, l;
  float32_t invL, * pSrc;

  if (ifftFlag == 1U)
 8001b36:	2a01      	cmp	r2, #1
  uint32_t  L = S->fftLen, l;
 8001b38:	8805      	ldrh	r5, [r0, #0]
{
 8001b3a:	9202      	str	r2, [sp, #8]
 8001b3c:	4683      	mov	fp, r0
 8001b3e:	460c      	mov	r4, r1
 8001b40:	9301      	str	r3, [sp, #4]
  if (ifftFlag == 1U)
 8001b42:	f000 8138 	beq.w	8001db6 <arm_cfft_f32+0x28a>
      *pSrc = -*pSrc;
      pSrc += 2;
    }
  }

  switch (L)
 8001b46:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 8001b4a:	f000 8146 	beq.w	8001dda <arm_cfft_f32+0x2ae>
 8001b4e:	d835      	bhi.n	8001bbc <arm_cfft_f32+0x90>
 8001b50:	2d40      	cmp	r5, #64	@ 0x40
 8001b52:	f000 8124 	beq.w	8001d9e <arm_cfft_f32+0x272>
 8001b56:	d84a      	bhi.n	8001bee <arm_cfft_f32+0xc2>
 8001b58:	2d10      	cmp	r5, #16
 8001b5a:	d04a      	beq.n	8001bf2 <arm_cfft_f32+0xc6>
 8001b5c:	2d20      	cmp	r5, #32
 8001b5e:	f000 813c 	beq.w	8001dda <arm_cfft_f32+0x2ae>
  case 4096:
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
    break;
  }

  if ( bitReverseFlag )
 8001b62:	9b01      	ldr	r3, [sp, #4]
 8001b64:	b133      	cbz	r3, 8001b74 <arm_cfft_f32+0x48>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 8001b66:	f8db 2008 	ldr.w	r2, [fp, #8]
 8001b6a:	f8bb 100c 	ldrh.w	r1, [fp, #12]
 8001b6e:	4620      	mov	r0, r4
 8001b70:	f7ff ffb2 	bl	8001ad8 <arm_bitreversal_32>

  if (ifftFlag == 1U)
 8001b74:	9b02      	ldr	r3, [sp, #8]
 8001b76:	2b01      	cmp	r3, #1
 8001b78:	d134      	bne.n	8001be4 <arm_cfft_f32+0xb8>
  {
    invL = 1.0f / (float32_t)L;
 8001b7a:	ee07 5a90 	vmov	s15, r5
 8001b7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8001b82:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8001b86:	eec7 6a27 	vdiv.f32	s13, s14, s15

    /* Conjugate and scale output data */
    pSrc = p1;
    for (l= 0; l < L; l++)
 8001b8a:	b35d      	cbz	r5, 8001be4 <arm_cfft_f32+0xb8>
 8001b8c:	3408      	adds	r4, #8
 8001b8e:	2300      	movs	r3, #0
 8001b90:	3301      	adds	r3, #1
 8001b92:	429d      	cmp	r5, r3
 8001b94:	f104 0408 	add.w	r4, r4, #8
    {
      *pSrc++ *=   invL ;
 8001b98:	ed14 7a04 	vldr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 8001b9c:	ed54 7a03 	vldr	s15, [r4, #-12]
      *pSrc++ *=   invL ;
 8001ba0:	ee27 7a26 	vmul.f32	s14, s14, s13
      *pSrc    = -(*pSrc) * invL;
 8001ba4:	ee67 7ae6 	vnmul.f32	s15, s15, s13
      *pSrc++ *=   invL ;
 8001ba8:	ed04 7a04 	vstr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 8001bac:	ed44 7a03 	vstr	s15, [r4, #-12]
    for (l= 0; l < L; l++)
 8001bb0:	d1ee      	bne.n	8001b90 <arm_cfft_f32+0x64>
      pSrc++;
    }
  }
}
 8001bb2:	b00f      	add	sp, #60	@ 0x3c
 8001bb4:	ecbd 8b0a 	vpop	{d8-d12}
 8001bb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 8001bbc:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
 8001bc0:	f000 810b 	beq.w	8001dda <arm_cfft_f32+0x2ae>
 8001bc4:	f200 80e7 	bhi.w	8001d96 <arm_cfft_f32+0x26a>
 8001bc8:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
 8001bcc:	f000 80e7 	beq.w	8001d9e <arm_cfft_f32+0x272>
 8001bd0:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
 8001bd4:	d00d      	beq.n	8001bf2 <arm_cfft_f32+0xc6>
  if ( bitReverseFlag )
 8001bd6:	9b01      	ldr	r3, [sp, #4]
 8001bd8:	2b00      	cmp	r3, #0
 8001bda:	d1c4      	bne.n	8001b66 <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 8001bdc:	9b02      	ldr	r3, [sp, #8]
 8001bde:	2b01      	cmp	r3, #1
 8001be0:	f000 80d0 	beq.w	8001d84 <arm_cfft_f32+0x258>
}
 8001be4:	b00f      	add	sp, #60	@ 0x3c
 8001be6:	ecbd 8b0a 	vpop	{d8-d12}
 8001bea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 8001bee:	2d80      	cmp	r5, #128	@ 0x80
 8001bf0:	d1f1      	bne.n	8001bd6 <arm_cfft_f32+0xaa>
  L >>= 1;
 8001bf2:	0869      	lsrs	r1, r5, #1
  const float32_t * tw = (float32_t *) S->pTwiddle;
 8001bf4:	f8db 2004 	ldr.w	r2, [fp, #4]
  pMid1 = p1 + L;
 8001bf8:	0088      	lsls	r0, r1, #2
 8001bfa:	3010      	adds	r0, #16
  float32_t * p2 = p1 + L;
 8001bfc:	eb04 0685 	add.w	r6, r4, r5, lsl #2
  for (l = L >> 2; l > 0; l-- )
 8001c00:	f104 0310 	add.w	r3, r4, #16
 8001c04:	ea4f 0ed5 	mov.w	lr, r5, lsr #3
 8001c08:	eb04 0c00 	add.w	ip, r4, r0
 8001c0c:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 8001c10:	4430      	add	r0, r6
 8001c12:	f102 0810 	add.w	r8, r2, #16
 8001c16:	f106 0710 	add.w	r7, r6, #16
    t2[0] = p2[0];
 8001c1a:	ed17 1a04 	vldr	s2, [r7, #-16]
    t2[1] = p2[1];
 8001c1e:	ed57 1a03 	vldr	s3, [r7, #-12]
    t4[0] = pMid2[0];
 8001c22:	ed10 5a04 	vldr	s10, [r0, #-16]
    t4[1] = pMid2[1];
 8001c26:	ed50 5a03 	vldr	s11, [r0, #-12]
    t2[2] = p2[2];
 8001c2a:	ed57 8a02 	vldr	s17, [r7, #-8]
    t2[3] = p2[3];
 8001c2e:	ed17 8a01 	vldr	s16, [r7, #-4]
    t4[2] = pMid2[2];
 8001c32:	ed10 7a02 	vldr	s14, [r0, #-8]
    t4[3] = pMid2[3];
 8001c36:	ed50 7a01 	vldr	s15, [r0, #-4]
    t1[0] = p1[0];
 8001c3a:	ed13 4a04 	vldr	s8, [r3, #-16]
    t1[1] = p1[1];
 8001c3e:	ed53 4a03 	vldr	s9, [r3, #-12]
    t1[2] = p1[2];
 8001c42:	ed13 6a02 	vldr	s12, [r3, #-8]
    t1[3] = p1[3];
 8001c46:	ed53 6a01 	vldr	s13, [r3, #-4]
    t3[0] = pMid1[0];
 8001c4a:	ed1c 2a04 	vldr	s4, [ip, #-16]
    t3[1] = pMid1[1];
 8001c4e:	ed5c 2a03 	vldr	s5, [ip, #-12]
    t3[2] = pMid1[2];
 8001c52:	ed1c 0a02 	vldr	s0, [ip, #-8]
    t3[3] = pMid1[3];
 8001c56:	ed5c 0a01 	vldr	s1, [ip, #-4]
    *p1++ = t1[0] + t2[0];
 8001c5a:	ee74 ba01 	vadd.f32	s23, s8, s2
    *p1++ = t1[1] + t2[1];
 8001c5e:	ee34 baa1 	vadd.f32	s22, s9, s3
    *pMid1++ = t3[0] + t4[0];
 8001c62:	ee72 9a05 	vadd.f32	s19, s4, s10
    *pMid1++ = t3[1] + t4[1];
 8001c66:	ee32 9aa5 	vadd.f32	s18, s5, s11
    *pMid1++ = t3[2] + t4[2];
 8001c6a:	ee30 3a07 	vadd.f32	s6, s0, s14
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 8001c6e:	ee70 3aa7 	vadd.f32	s7, s1, s15
    *p1++ = t1[2] + t2[2];
 8001c72:	ee76 aa28 	vadd.f32	s21, s12, s17
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001c76:	ee36 aa88 	vadd.f32	s20, s13, s16
    *p1++ = t1[0] + t2[0];
 8001c7a:	ed43 ba04 	vstr	s23, [r3, #-16]
    *p1++ = t1[1] + t2[1];
 8001c7e:	ed03 ba03 	vstr	s22, [r3, #-12]
    *p1++ = t1[2] + t2[2];
 8001c82:	ed43 aa02 	vstr	s21, [r3, #-8]
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001c86:	ed03 aa01 	vstr	s20, [r3, #-4]
    *pMid1++ = t3[0] + t4[0];
 8001c8a:	ed4c 9a04 	vstr	s19, [ip, #-16]
    *pMid1++ = t3[1] + t4[1];
 8001c8e:	ed0c 9a03 	vstr	s18, [ip, #-12]
    *pMid1++ = t3[2] + t4[2];
 8001c92:	ed0c 3a02 	vstr	s6, [ip, #-8]
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 8001c96:	ed4c 3a01 	vstr	s7, [ip, #-4]
    twI = *tw++;
 8001c9a:	ed58 3a03 	vldr	s7, [r8, #-12]
    twR = *tw++;
 8001c9e:	ed18 3a04 	vldr	s6, [r8, #-16]
    t2[0] = t1[0] - t2[0];
 8001ca2:	ee34 4a41 	vsub.f32	s8, s8, s2
    t2[1] = t1[1] - t2[1];
 8001ca6:	ee74 4ae1 	vsub.f32	s9, s9, s3
    t4[1] = t4[1] - t3[1];
 8001caa:	ee75 5ae2 	vsub.f32	s11, s11, s5
    t4[0] = t4[0] - t3[0];
 8001cae:	ee35 5a42 	vsub.f32	s10, s10, s4
    m1 = t2[1] * twI;
 8001cb2:	ee24 1aa3 	vmul.f32	s2, s9, s7
    *p2++ = m2 - m3;
 8001cb6:	ee63 1ac4 	vnmul.f32	s3, s7, s8
    *pMid2++ = m0 - m1;
 8001cba:	ee23 2a65 	vnmul.f32	s4, s6, s11
    *p2++ = m0 + m1;
 8001cbe:	eea4 1a03 	vfma.f32	s2, s8, s6
  for (l = L >> 2; l > 0; l-- )
 8001cc2:	3310      	adds	r3, #16
 8001cc4:	459e      	cmp	lr, r3
    m3 = t4[0] * twR;
 8001cc6:	ee65 2a03 	vmul.f32	s5, s10, s6
    *p2++ = m2 - m3;
 8001cca:	eeb0 4a61 	vmov.f32	s8, s3
 8001cce:	eea4 4a83 	vfma.f32	s8, s9, s6
  for (l = L >> 2; l > 0; l-- )
 8001cd2:	f10c 0c10 	add.w	ip, ip, #16
 8001cd6:	f108 0810 	add.w	r8, r8, #16
    *pMid2++ = m0 - m1;
 8001cda:	eef0 4a42 	vmov.f32	s9, s4
 8001cde:	eee5 4a23 	vfma.f32	s9, s10, s7
  for (l = L >> 2; l > 0; l-- )
 8001ce2:	f107 0710 	add.w	r7, r7, #16
 8001ce6:	f100 0010 	add.w	r0, r0, #16
    *pMid2++ = m2 + m3;
 8001cea:	eeb0 5a62 	vmov.f32	s10, s5
 8001cee:	eea5 5aa3 	vfma.f32	s10, s11, s7
    *p2++ = m2 - m3;
 8001cf2:	ed07 4a07 	vstr	s8, [r7, #-28]	@ 0xffffffe4
    *p2++ = m0 + m1;
 8001cf6:	ed07 1a08 	vstr	s2, [r7, #-32]	@ 0xffffffe0
    *pMid2++ = m0 - m1;
 8001cfa:	ed40 4a08 	vstr	s9, [r0, #-32]	@ 0xffffffe0
    *pMid2++ = m2 + m3;
 8001cfe:	ed00 5a07 	vstr	s10, [r0, #-28]	@ 0xffffffe4
    twI = *tw++;
 8001d02:	ed58 5a05 	vldr	s11, [r8, #-20]	@ 0xffffffec
    twR = *tw++;
 8001d06:	ed18 5a06 	vldr	s10, [r8, #-24]	@ 0xffffffe8
    t2[2] = t1[2] - t2[2];
 8001d0a:	ee36 6a68 	vsub.f32	s12, s12, s17
    t2[3] = t1[3] - t2[3];    /* for col 2 */
 8001d0e:	ee76 6ac8 	vsub.f32	s13, s13, s16
    t4[3] = t4[3] - t3[3];    /* for col 2 */
 8001d12:	ee77 7ae0 	vsub.f32	s15, s15, s1
    t4[2] = t4[2] - t3[2];
 8001d16:	ee37 7a40 	vsub.f32	s14, s14, s0
    m1 = t2[3] * twI;
 8001d1a:	ee26 3aa5 	vmul.f32	s6, s13, s11
    *p2++ = m2 - m3;
 8001d1e:	ee65 3ac6 	vnmul.f32	s7, s11, s12
    *pMid2++ = m0 - m1;
 8001d22:	ee25 4a67 	vnmul.f32	s8, s10, s15
    *p2++ = m0 + m1;
 8001d26:	eea6 3a05 	vfma.f32	s6, s12, s10
    m3 = t4[2] * twR;
 8001d2a:	ee67 4a05 	vmul.f32	s9, s14, s10
    *p2++ = m2 - m3;
 8001d2e:	eeb0 6a63 	vmov.f32	s12, s7
 8001d32:	eea6 6a85 	vfma.f32	s12, s13, s10
    *pMid2++ = m0 - m1;
 8001d36:	eef0 6a44 	vmov.f32	s13, s8
 8001d3a:	eee7 6a25 	vfma.f32	s13, s14, s11
    *pMid2++ = m2 + m3;
 8001d3e:	eeb0 7a64 	vmov.f32	s14, s9
 8001d42:	eea7 7aa5 	vfma.f32	s14, s15, s11
    *p2++ = m0 + m1;
 8001d46:	ed07 3a06 	vstr	s6, [r7, #-24]	@ 0xffffffe8
    *p2++ = m2 - m3;
 8001d4a:	ed07 6a05 	vstr	s12, [r7, #-20]	@ 0xffffffec
    *pMid2++ = m0 - m1;
 8001d4e:	ed40 6a06 	vstr	s13, [r0, #-24]	@ 0xffffffe8
    *pMid2++ = m2 + m3;
 8001d52:	ed00 7a05 	vstr	s14, [r0, #-20]	@ 0xffffffec
  for (l = L >> 2; l > 0; l-- )
 8001d56:	f47f af60 	bne.w	8001c1a <arm_cfft_f32+0xee>
  arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 2U);
 8001d5a:	b28f      	uxth	r7, r1
 8001d5c:	2302      	movs	r3, #2
 8001d5e:	4639      	mov	r1, r7
 8001d60:	4620      	mov	r0, r4
 8001d62:	f000 fa79 	bl	8002258 <arm_radix8_butterfly_f32>
  arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 2U);
 8001d66:	2302      	movs	r3, #2
 8001d68:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001d6c:	4639      	mov	r1, r7
 8001d6e:	4630      	mov	r0, r6
 8001d70:	f000 fa72 	bl	8002258 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001d74:	9b01      	ldr	r3, [sp, #4]
 8001d76:	2b00      	cmp	r3, #0
 8001d78:	f47f aef5 	bne.w	8001b66 <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 8001d7c:	9b02      	ldr	r3, [sp, #8]
 8001d7e:	2b01      	cmp	r3, #1
 8001d80:	f47f af30 	bne.w	8001be4 <arm_cfft_f32+0xb8>
    invL = 1.0f / (float32_t)L;
 8001d84:	ee07 5a90 	vmov	s15, r5
 8001d88:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8001d8c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8001d90:	eec7 6a27 	vdiv.f32	s13, s14, s15
    for (l= 0; l < L; l++)
 8001d94:	e6fa      	b.n	8001b8c <arm_cfft_f32+0x60>
  switch (L)
 8001d96:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 8001d9a:	f47f af1c 	bne.w	8001bd6 <arm_cfft_f32+0xaa>
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
 8001d9e:	2301      	movs	r3, #1
 8001da0:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001da4:	4629      	mov	r1, r5
 8001da6:	4620      	mov	r0, r4
 8001da8:	f000 fa56 	bl	8002258 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001dac:	9b01      	ldr	r3, [sp, #4]
 8001dae:	2b00      	cmp	r3, #0
 8001db0:	f43f af14 	beq.w	8001bdc <arm_cfft_f32+0xb0>
 8001db4:	e6d7      	b.n	8001b66 <arm_cfft_f32+0x3a>
    for (l = 0; l < L; l++)
 8001db6:	2d00      	cmp	r5, #0
 8001db8:	f000 8233 	beq.w	8002222 <arm_cfft_f32+0x6f6>
 8001dbc:	f101 030c 	add.w	r3, r1, #12
 8001dc0:	2200      	movs	r2, #0
      *pSrc = -*pSrc;
 8001dc2:	ed53 7a02 	vldr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001dc6:	3201      	adds	r2, #1
      *pSrc = -*pSrc;
 8001dc8:	eef1 7a67 	vneg.f32	s15, s15
    for (l = 0; l < L; l++)
 8001dcc:	4295      	cmp	r5, r2
      *pSrc = -*pSrc;
 8001dce:	ed43 7a02 	vstr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001dd2:	f103 0308 	add.w	r3, r3, #8
 8001dd6:	d1f4      	bne.n	8001dc2 <arm_cfft_f32+0x296>
 8001dd8:	e6b5      	b.n	8001b46 <arm_cfft_f32+0x1a>
    uint32_t    L  = S->fftLen >> 1;
 8001dda:	086b      	lsrs	r3, r5, #1
    float32_t * p3 = p2 + L;
 8001ddc:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    p1ap3_0 = p1[0] + p3[0];
 8001de0:	ed91 6a00 	vldr	s12, [r1]
    p1ap3_1 = p1[1] + p3[1];
 8001de4:	edd1 5a01 	vldr	s11, [r1, #4]
    p1ap3_0 = p1[0] + p3[0];
 8001de8:	ed94 7a00 	vldr	s14, [r4]
    p1ap3_1 = p1[1] + p3[1];
 8001dec:	edd4 7a01 	vldr	s15, [r4, #4]
    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8001df0:	f8db 6004 	ldr.w	r6, [fp, #4]
 8001df4:	9606      	str	r6, [sp, #24]
    float32_t * p4 = p3 + L;
 8001df6:	eb01 0283 	add.w	r2, r1, r3, lsl #2
    p1ap3_0 = p1[0] + p3[0];
 8001dfa:	ee77 6a06 	vadd.f32	s13, s14, s12
    p1sp3_0 = p1[0] - p3[0];
 8001dfe:	ee37 7a46 	vsub.f32	s14, s14, s12
    p1ap3_1 = p1[1] + p3[1];
 8001e02:	ee37 6aa5 	vadd.f32	s12, s15, s11
    p1sp3_1 = p1[1] - p3[1];
 8001e06:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001e0a:	edd2 5a00 	vldr	s11, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001e0e:	ed92 2a01 	vldr	s4, [r2, #4]
 8001e12:	9203      	str	r2, [sp, #12]
    float32_t * p2 = p1 + L;
 8001e14:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001e18:	ed90 5a00 	vldr	s10, [r0]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001e1c:	edd0 2a01 	vldr	s5, [r0, #4]
    float32_t * p3 = p2 + L;
 8001e20:	9105      	str	r1, [sp, #20]
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001e22:	ee36 3aa5 	vadd.f32	s6, s13, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001e26:	ee77 3aa5 	vadd.f32	s7, s15, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001e2a:	ee33 3a05 	vadd.f32	s6, s6, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001e2e:	ee77 4a02 	vadd.f32	s9, s14, s4
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001e32:	ed84 3a00 	vstr	s6, [r4]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001e36:	ee76 6ac5 	vsub.f32	s13, s13, s10
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001e3a:	ee77 7a85 	vadd.f32	s15, s15, s10
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001e3e:	ee73 3ac5 	vsub.f32	s7, s7, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001e42:	ee34 5ae2 	vsub.f32	s10, s9, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001e46:	edd2 4a01 	vldr	s9, [r2, #4]
    float32_t * p2 = p1 + L;
 8001e4a:	9004      	str	r0, [sp, #16]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001e4c:	ee36 4a62 	vsub.f32	s8, s12, s5
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001e50:	ee76 6ae5 	vsub.f32	s13, s13, s11
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001e54:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001e58:	ee37 7a22 	vadd.f32	s14, s14, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001e5c:	edd0 5a01 	vldr	s11, [r0, #4]
 8001e60:	950d      	str	r5, [sp, #52]	@ 0x34
 8001e62:	ee36 6a24 	vadd.f32	s12, s12, s9
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001e66:	ee37 7a42 	vsub.f32	s14, s14, s4
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001e6a:	ee34 4a42 	vsub.f32	s8, s8, s4
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001e6e:	ee36 6a25 	vadd.f32	s12, s12, s11
    L >>= 1;
 8001e72:	085f      	lsrs	r7, r3, #1
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001e74:	ed84 6a01 	vstr	s12, [r4, #4]
 8001e78:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *p2++ = t2[0];
 8001e7c:	ed80 7a00 	vstr	s14, [r0]
    *p2++ = t2[1];
 8001e80:	edc0 3a01 	vstr	s7, [r0, #4]
    *p3++ = t3[0];
 8001e84:	edc1 6a00 	vstr	s13, [r1]
    *p3++ = t3[1];
 8001e88:	ed81 4a01 	vstr	s8, [r1, #4]
    *p4++ = t4[0];
 8001e8c:	ed82 5a00 	vstr	s10, [r2]
    *p4++ = t4[1];
 8001e90:	edc2 7a01 	vstr	s15, [r2, #4]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e94:	1eba      	subs	r2, r7, #2
    L >>= 1;
 8001e96:	9708      	str	r7, [sp, #32]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e98:	0857      	lsrs	r7, r2, #1
 8001e9a:	9707      	str	r7, [sp, #28]
 8001e9c:	3b0c      	subs	r3, #12
 8001e9e:	930b      	str	r3, [sp, #44]	@ 0x2c
 8001ea0:	f106 0820 	add.w	r8, r6, #32
    tw3 += twMod3;
 8001ea4:	f106 0310 	add.w	r3, r6, #16
 8001ea8:	f106 0930 	add.w	r9, r6, #48	@ 0x30
 8001eac:	9e07      	ldr	r6, [sp, #28]
 8001eae:	9309      	str	r3, [sp, #36]	@ 0x24
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001eb0:	f1a0 0c0c 	sub.w	ip, r0, #12
 8001eb4:	469a      	mov	sl, r3
 8001eb6:	0133      	lsls	r3, r6, #4
 8001eb8:	460a      	mov	r2, r1
 8001eba:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
 8001ebe:	930a      	str	r3, [sp, #40]	@ 0x28
 8001ec0:	eb08 1306 	add.w	r3, r8, r6, lsl #4
 8001ec4:	f102 0e10 	add.w	lr, r2, #16
 8001ec8:	461d      	mov	r5, r3
 8001eca:	9a03      	ldr	r2, [sp, #12]
 8001ecc:	e9dd 360b 	ldrd	r3, r6, [sp, #44]	@ 0x2c
 8001ed0:	f1a2 0c0c 	sub.w	ip, r2, #12
 8001ed4:	f104 0710 	add.w	r7, r4, #16
 8001ed8:	3010      	adds	r0, #16
 8001eda:	390c      	subs	r1, #12
 8001edc:	3210      	adds	r2, #16
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001ede:	ed12 8a02 	vldr	s16, [r2, #-8]
 8001ee2:	ed50 2a02 	vldr	s5, [r0, #-8]
      p1ap3_0 = p1[0] + p3[0];
 8001ee6:	ed1e 6a02 	vldr	s12, [lr, #-8]
 8001eea:	ed17 3a02 	vldr	s6, [r7, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001eee:	ed12 2a01 	vldr	s4, [r2, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001ef2:	ed1e 7a01 	vldr	s14, [lr, #-4]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001ef6:	ed50 aa01 	vldr	s21, [r0, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001efa:	ed57 6a01 	vldr	s13, [r7, #-4]
      p1ap3_0 = p1[0] + p3[0];
 8001efe:	ee33 4a06 	vadd.f32	s8, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001f02:	ee72 7a88 	vadd.f32	s15, s5, s16
      p1ap3_1 = p1[1] + p3[1];
 8001f06:	ee76 4a87 	vadd.f32	s9, s13, s14
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001f0a:	ee77 7a84 	vadd.f32	s15, s15, s8
      p1sp3_0 = p1[0] - p3[0];
 8001f0e:	ee33 3a46 	vsub.f32	s6, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001f12:	ed47 7a02 	vstr	s15, [r7, #-8]
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001f16:	ed52 5a01 	vldr	s11, [r2, #-4]
 8001f1a:	ed50 7a01 	vldr	s15, [r0, #-4]
 8001f1e:	ee77 7aa5 	vadd.f32	s15, s15, s11
      p1sp3_1 = p1[1] - p3[1];
 8001f22:	ee76 6ac7 	vsub.f32	s13, s13, s14
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001f26:	ee77 7aa4 	vadd.f32	s15, s15, s9
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001f2a:	ee73 9a42 	vsub.f32	s19, s6, s4
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001f2e:	ed47 7a01 	vstr	s15, [r7, #-4]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001f32:	edd3 ba02 	vldr	s23, [r3, #8]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001f36:	ed9c 6a02 	vldr	s12, [ip, #8]
 8001f3a:	edd6 1a02 	vldr	s3, [r6, #8]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001f3e:	edd1 5a02 	vldr	s11, [r1, #8]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001f42:	ed93 ba01 	vldr	s22, [r3, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001f46:	ed9c 1a01 	vldr	s2, [ip, #4]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001f4a:	ed91 0a01 	vldr	s0, [r1, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001f4e:	ed96 aa01 	vldr	s20, [r6, #4]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001f52:	ee31 ca86 	vadd.f32	s24, s3, s12
 8001f56:	ee75 0aab 	vadd.f32	s1, s11, s23
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001f5a:	ee3a 5a01 	vadd.f32	s10, s20, s2
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001f5e:	ee70 7a8c 	vadd.f32	s15, s1, s24
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001f62:	ee36 9ae2 	vsub.f32	s18, s13, s5
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001f66:	edc6 7a02 	vstr	s15, [r6, #8]
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001f6a:	edd3 8a01 	vldr	s17, [r3, #4]
 8001f6e:	edd1 7a01 	vldr	s15, [r1, #4]
 8001f72:	ee77 7aa8 	vadd.f32	s15, s15, s17
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001f76:	ee35 7aeb 	vsub.f32	s14, s11, s23
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001f7a:	ee77 7a85 	vadd.f32	s15, s15, s10
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001f7e:	ee39 9a08 	vadd.f32	s18, s18, s16
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001f82:	edc6 7a01 	vstr	s15, [r6, #4]
      twI = *tw2++;
 8001f86:	ed5a 8a01 	vldr	s17, [sl, #-4]
      twR = *tw2++;
 8001f8a:	ed5a 7a02 	vldr	s15, [sl, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001f8e:	ee79 9aaa 	vadd.f32	s19, s19, s21
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001f92:	ee7c 5a65 	vsub.f32	s11, s24, s11
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001f96:	ee71 3a8b 	vadd.f32	s7, s3, s22
      m0 = -t3[3] * twR;
 8001f9a:	ee70 0acc 	vsub.f32	s1, s1, s24
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001f9e:	ee75 5aeb 	vsub.f32	s11, s11, s23
      m1 = t2[1] * twI;
 8001fa2:	ee29 ca28 	vmul.f32	s24, s18, s17
      *p2++ = m2 - m3;
 8001fa6:	ee68 bae9 	vnmul.f32	s23, s17, s19
      *p2++ = m0 + m1;
 8001faa:	eea9 caa7 	vfma.f32	s24, s19, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001fae:	f108 0810 	add.w	r8, r8, #16
 8001fb2:	3708      	adds	r7, #8
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001fb4:	ee73 3ac6 	vsub.f32	s7, s7, s12
      *p2++ = m2 - m3;
 8001fb8:	eef0 9a6b 	vmov.f32	s19, s23
 8001fbc:	eee9 9a27 	vfma.f32	s19, s18, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001fc0:	3e08      	subs	r6, #8
 8001fc2:	f10a 0a08 	add.w	sl, sl, #8
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001fc6:	ee37 9a41 	vsub.f32	s18, s14, s2
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001fca:	ee73 3ac0 	vsub.f32	s7, s7, s0
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001fce:	ee35 5a40 	vsub.f32	s10, s10, s0
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001fd2:	ee39 9a0a 	vadd.f32	s18, s18, s20
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001fd6:	ee35 5a4b 	vsub.f32	s10, s10, s22
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001fda:	ee36 6a0b 	vadd.f32	s12, s12, s22
      m3 = t2[3] * twR;
 8001fde:	ee23 baa7 	vmul.f32	s22, s7, s15
      *pEnd2-- = m0 - m1;
 8001fe2:	ee67 7ac9 	vnmul.f32	s15, s15, s18
      *p2++ = m2 - m3;
 8001fe6:	ed40 9a01 	vstr	s19, [r0, #-4]
      *pEnd2-- = m2 + m3;
 8001fea:	eef0 9a4b 	vmov.f32	s19, s22
      *pEnd2-- = m0 - m1;
 8001fee:	eee3 7aa8 	vfma.f32	s15, s7, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001ff2:	3008      	adds	r0, #8
 8001ff4:	3908      	subs	r1, #8
      *pEnd2-- = m2 + m3;
 8001ff6:	eee9 9a28 	vfma.f32	s19, s18, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001ffa:	f10e 0e08 	add.w	lr, lr, #8
 8001ffe:	f1ac 0c08 	sub.w	ip, ip, #8
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 8002002:	ee34 4a62 	vsub.f32	s8, s8, s5
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8002006:	ee74 4aea 	vsub.f32	s9, s9, s21
      *p2++ = m0 + m1;
 800200a:	ed00 ca04 	vstr	s24, [r0, #-16]
      *pEnd2-- = m2 + m3;
 800200e:	edc1 9a03 	vstr	s19, [r1, #12]
      *pEnd2-- = m0 - m1;
 8002012:	edc1 7a04 	vstr	s15, [r1, #16]
      twI = tw3[1];
 8002016:	ed58 7a07 	vldr	s15, [r8, #-28]	@ 0xffffffe4
      twR = tw3[0];
 800201a:	ed58 3a08 	vldr	s7, [r8, #-32]	@ 0xffffffe0
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 800201e:	ee34 4a48 	vsub.f32	s8, s8, s16
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8002022:	ee74 4ac2 	vsub.f32	s9, s9, s4
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 8002026:	ee76 6ac8 	vsub.f32	s13, s13, s16
      m1 = t3[1] * twI;
 800202a:	ee64 8aa7 	vmul.f32	s17, s9, s15
      *p3++ = m2 - m3;
 800202e:	ee27 8ac4 	vnmul.f32	s16, s15, s8
      m3 =  t3[3] * twI;
 8002032:	ee65 5aa7 	vmul.f32	s11, s11, s15
      *pEnd3-- = m0 - m1;
 8002036:	ee67 7ac5 	vnmul.f32	s15, s15, s10
      *p3++ = m0 + m1;
 800203a:	eee4 8a23 	vfma.f32	s17, s8, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 800203e:	4545      	cmp	r5, r8
 8002040:	f109 0918 	add.w	r9, r9, #24
      *p3++ = m2 - m3;
 8002044:	eeb0 4a48 	vmov.f32	s8, s16
 8002048:	eea4 4aa3 	vfma.f32	s8, s9, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 800204c:	f102 0208 	add.w	r2, r2, #8
 8002050:	f1a3 0308 	sub.w	r3, r3, #8
      *pEnd3-- = m3 - m2;
 8002054:	eee5 5a63 	vfms.f32	s11, s10, s7
      *pEnd3-- = m0 - m1;
 8002058:	eee3 7aa0 	vfma.f32	s15, s7, s1
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 800205c:	ee37 7a4a 	vsub.f32	s14, s14, s20
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8002060:	ee33 3a6a 	vsub.f32	s6, s6, s21
      *p3++ = m0 + m1;
 8002064:	ed4e 8a04 	vstr	s17, [lr, #-16]
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8002068:	ee36 6a40 	vsub.f32	s12, s12, s0
      *p3++ = m2 - m3;
 800206c:	ed0e 4a03 	vstr	s8, [lr, #-12]
      *pEnd3-- = m0 - m1;
 8002070:	edcc 7a04 	vstr	s15, [ip, #16]
      *pEnd3-- = m3 - m2;
 8002074:	edcc 5a03 	vstr	s11, [ip, #12]
      twR = tw4[0];
 8002078:	ed19 5a0c 	vldr	s10, [r9, #-48]	@ 0xffffffd0
      twI = tw4[1];
 800207c:	ed59 5a0b 	vldr	s11, [r9, #-44]	@ 0xffffffd4
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 8002080:	ee77 7a01 	vadd.f32	s15, s14, s2
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8002084:	ee33 3a02 	vadd.f32	s6, s6, s4
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8002088:	ee36 7a61 	vsub.f32	s14, s12, s3
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 800208c:	ee76 6aa2 	vadd.f32	s13, s13, s5
      *p4++ = m2 - m3;
 8002090:	ee25 4ac3 	vnmul.f32	s8, s11, s6
      *pEnd4-- = m0 - m1;
 8002094:	ee65 4a67 	vnmul.f32	s9, s10, s15
      m3 = t4[3] * twR;
 8002098:	ee27 6a05 	vmul.f32	s12, s14, s10
      *p4++ = m2 - m3;
 800209c:	eea6 4a85 	vfma.f32	s8, s13, s10
      m1 = t4[1] * twI;
 80020a0:	ee66 3aa5 	vmul.f32	s7, s13, s11
      *pEnd4-- = m0 - m1;
 80020a4:	eef0 6a64 	vmov.f32	s13, s9
 80020a8:	eee7 6a25 	vfma.f32	s13, s14, s11
      *pEnd4-- = m2 + m3;
 80020ac:	eeb0 7a46 	vmov.f32	s14, s12
      *p4++ = m0 + m1;
 80020b0:	eee3 3a05 	vfma.f32	s7, s6, s10
      *pEnd4-- = m2 + m3;
 80020b4:	eea7 7aa5 	vfma.f32	s14, s15, s11
      *p4++ = m0 + m1;
 80020b8:	ed42 3a04 	vstr	s7, [r2, #-16]
      *p4++ = m2 - m3;
 80020bc:	ed02 4a03 	vstr	s8, [r2, #-12]
      *pEnd4-- = m0 - m1;
 80020c0:	edc3 6a04 	vstr	s13, [r3, #16]
      *pEnd4-- = m2 + m3;
 80020c4:	ed83 7a03 	vstr	s14, [r3, #12]
    for (l = (L - 2) >> 1; l > 0; l-- )
 80020c8:	f47f af09 	bne.w	8001ede <arm_cfft_f32+0x3b2>
 80020cc:	e9dd 0309 	ldrd	r0, r3, [sp, #36]	@ 0x24
 80020d0:	4418      	add	r0, r3
 80020d2:	9b07      	ldr	r3, [sp, #28]
 80020d4:	9f05      	ldr	r7, [sp, #20]
 80020d6:	9906      	ldr	r1, [sp, #24]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 80020d8:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 80020dc:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 80020de:	00da      	lsls	r2, r3, #3
 80020e0:	3208      	adds	r2, #8
 80020e2:	eb07 0c02 	add.w	ip, r7, r2
 80020e6:	eb04 0e02 	add.w	lr, r4, r2
 80020ea:	9f03      	ldr	r7, [sp, #12]
    p1ap3_0 = p1[0] + p3[0];
 80020ec:	ed9c 5a00 	vldr	s10, [ip]
 80020f0:	edde 7a00 	vldr	s15, [lr]
    p1ap3_1 = p1[1] + p3[1];
 80020f4:	eddc 5a01 	vldr	s11, [ip, #4]
 80020f8:	ed9e 7a01 	vldr	s14, [lr, #4]
 80020fc:	3301      	adds	r3, #1
 80020fe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002102:	eb07 0802 	add.w	r8, r7, r2
    p1ap3_0 = p1[0] + p3[0];
 8002106:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800210a:	9904      	ldr	r1, [sp, #16]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 800210c:	edd8 4a00 	vldr	s9, [r8]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8002110:	edd8 2a01 	vldr	s5, [r8, #4]
    p1ap3_0 = p1[0] + p3[0];
 8002114:	ee77 6a85 	vadd.f32	s13, s15, s10
    p1sp3_0 = p1[0] - p3[0];
 8002118:	188f      	adds	r7, r1, r2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 800211a:	ed97 4a00 	vldr	s8, [r7]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 800211e:	ed97 3a01 	vldr	s6, [r7, #4]
 8002122:	9906      	ldr	r1, [sp, #24]
    p1ap3_1 = p1[1] + p3[1];
 8002124:	ee37 6a25 	vadd.f32	s12, s14, s11
    p1sp3_1 = p1[1] - p3[1];
 8002128:	ee37 7a65 	vsub.f32	s14, s14, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 800212c:	ee76 5aa4 	vadd.f32	s11, s13, s9
    p1sp3_0 = p1[0] - p3[0];
 8002130:	ee77 7ac5 	vsub.f32	s15, s15, s10
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8002134:	ee75 5a84 	vadd.f32	s11, s11, s8
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8002138:	ee37 5aa2 	vadd.f32	s10, s15, s5
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 800213c:	edce 5a00 	vstr	s11, [lr]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8002140:	edd8 5a01 	vldr	s11, [r8, #4]
 8002144:	ed97 2a01 	vldr	s4, [r7, #4]
 8002148:	ee76 5a25 	vadd.f32	s11, s12, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 800214c:	ee77 3a44 	vsub.f32	s7, s14, s8
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8002150:	ee75 5a82 	vadd.f32	s11, s11, s4
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8002154:	ee77 7a83 	vadd.f32	s15, s15, s6
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8002158:	edce 5a01 	vstr	s11, [lr, #4]
 800215c:	440a      	add	r2, r1
    twI = tw2[1];
 800215e:	edd2 5a01 	vldr	s11, [r2, #4]
    twR = tw2[0];
 8002162:	edd2 1a00 	vldr	s3, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8002166:	ee77 7ae2 	vsub.f32	s15, s15, s5
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 800216a:	ee73 3aa4 	vadd.f32	s7, s7, s9
    *p2++ = m2 - m3;
 800216e:	ee25 2ae7 	vnmul.f32	s4, s11, s15
    m1 = t2[1] * twI;
 8002172:	ee63 5aa5 	vmul.f32	s11, s7, s11
    *p2++ = m2 - m3;
 8002176:	eea3 2aa1 	vfma.f32	s4, s7, s3
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 800217a:	460a      	mov	r2, r1
 800217c:	4631      	mov	r1, r6
    *p2++ = m0 + m1;
 800217e:	eee7 5aa1 	vfma.f32	s11, s15, s3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8002182:	ee76 7ac4 	vsub.f32	s15, s13, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8002186:	ee76 6a43 	vsub.f32	s13, s12, s6
    *p2++ = m2 - m3;
 800218a:	ed87 2a01 	vstr	s4, [r7, #4]
    *p2++ = m0 + m1;
 800218e:	edc7 5a00 	vstr	s11, [r7]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8002192:	ee77 7ae4 	vsub.f32	s15, s15, s9
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8002196:	ee76 6ae2 	vsub.f32	s13, s13, s5
    twI = tw3[1];
 800219a:	ed90 6a01 	vldr	s12, [r0, #4]
    twR = tw3[0];
 800219e:	edd0 3a00 	vldr	s7, [r0]
    *p3++ = m2 - m3;
 80021a2:	ee66 5a67 	vnmul.f32	s11, s12, s15
    m1 = t3[1] * twI;
 80021a6:	ee26 6a86 	vmul.f32	s12, s13, s12
    *p3++ = m2 - m3;
 80021aa:	eee6 5aa3 	vfma.f32	s11, s13, s7
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 80021ae:	4620      	mov	r0, r4
    *p3++ = m0 + m1;
 80021b0:	eea7 6aa3 	vfma.f32	s12, s15, s7
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 80021b4:	ee77 7a04 	vadd.f32	s15, s14, s8
    *p3++ = m0 + m1;
 80021b8:	ed8c 6a00 	vstr	s12, [ip]
    *p3++ = m2 - m3;
 80021bc:	edcc 5a01 	vstr	s11, [ip, #4]
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 80021c0:	ee75 6a43 	vsub.f32	s13, s10, s6
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 80021c4:	ee77 7ae4 	vsub.f32	s15, s15, s9
    twI = tw4[1];
 80021c8:	ed93 7a01 	vldr	s14, [r3, #4]
    twR = tw4[0];
 80021cc:	edd3 5a00 	vldr	s11, [r3]
    *p4++ = m2 - m3;
 80021d0:	ee27 6a66 	vnmul.f32	s12, s14, s13
    m1 = t4[1] * twI;
 80021d4:	ee27 7a87 	vmul.f32	s14, s15, s14
    *p4++ = m2 - m3;
 80021d8:	eea7 6aa5 	vfma.f32	s12, s15, s11
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 80021dc:	2304      	movs	r3, #4
    *p4++ = m0 + m1;
 80021de:	eea6 7aa5 	vfma.f32	s14, s13, s11
    *p4++ = m2 - m3;
 80021e2:	ed88 6a01 	vstr	s12, [r8, #4]
    *p4++ = m0 + m1;
 80021e6:	ed88 7a00 	vstr	s14, [r8]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 80021ea:	f000 f835 	bl	8002258 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 4U);
 80021ee:	9804      	ldr	r0, [sp, #16]
 80021f0:	f8db 2004 	ldr.w	r2, [fp, #4]
 80021f4:	2304      	movs	r3, #4
 80021f6:	4631      	mov	r1, r6
 80021f8:	f000 f82e 	bl	8002258 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol3, L, (float32_t *) S->pTwiddle, 4U);
 80021fc:	9805      	ldr	r0, [sp, #20]
 80021fe:	f8db 2004 	ldr.w	r2, [fp, #4]
 8002202:	2304      	movs	r3, #4
 8002204:	4631      	mov	r1, r6
 8002206:	f000 f827 	bl	8002258 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol4, L, (float32_t *) S->pTwiddle, 4U);
 800220a:	2304      	movs	r3, #4
 800220c:	9803      	ldr	r0, [sp, #12]
 800220e:	f8db 2004 	ldr.w	r2, [fp, #4]
 8002212:	4631      	mov	r1, r6
 8002214:	f000 f820 	bl	8002258 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8002218:	9b01      	ldr	r3, [sp, #4]
 800221a:	2b00      	cmp	r3, #0
 800221c:	f43f acde 	beq.w	8001bdc <arm_cfft_f32+0xb0>
 8002220:	e4a1      	b.n	8001b66 <arm_cfft_f32+0x3a>
 8002222:	9b01      	ldr	r3, [sp, #4]
 8002224:	2b00      	cmp	r3, #0
 8002226:	f43f acdd 	beq.w	8001be4 <arm_cfft_f32+0xb8>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 800222a:	6882      	ldr	r2, [r0, #8]
 800222c:	8981      	ldrh	r1, [r0, #12]
 800222e:	4620      	mov	r0, r4
 8002230:	f7ff fc52 	bl	8001ad8 <arm_bitreversal_32>
  if (ifftFlag == 1U)
 8002234:	e4a1      	b.n	8001b7a <arm_cfft_f32+0x4e>
 8002236:	bf00      	nop

08002238 <arm_cfft_init_128_f32>:

  @par          Use of this function is mandatory only for the Helium and Neon versions of the FFT.
                Other versions can still initialize directly the data structure using 
                variables declared in arm_const_structs.h
 */
CFFTINIT_F32(128,64)
 8002238:	4b06      	ldr	r3, [pc, #24]	@ (8002254 <arm_cfft_init_128_f32+0x1c>)
 800223a:	8999      	ldrh	r1, [r3, #12]
 800223c:	8181      	strh	r1, [r0, #12]
 800223e:	e9d3 3201 	ldrd	r3, r2, [r3, #4]
 8002242:	f04f 0c80 	mov.w	ip, #128	@ 0x80
 8002246:	e9c0 3201 	strd	r3, r2, [r0, #4]
 800224a:	f8a0 c000 	strh.w	ip, [r0]
 800224e:	2000      	movs	r0, #0
 8002250:	4770      	bx	lr
 8002252:	bf00      	nop
 8002254:	080037cc 	.word	0x080037cc

08002258 <arm_radix8_butterfly_f32>:
ARM_DSP_ATTRIBUTE void arm_radix8_butterfly_f32(
  float32_t * pSrc,
  uint16_t fftLen,
  const float32_t * pCoef,
  uint16_t twidCoefModifier)
{
 8002258:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800225c:	ed2d 8b10 	vpush	{d8-d15}
 8002260:	b08f      	sub	sp, #60	@ 0x3c
 8002262:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
 8002266:	4603      	mov	r3, r0
 8002268:	3304      	adds	r3, #4
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 800226a:	ed9f cabc 	vldr	s24, [pc, #752]	@ 800255c <arm_radix8_butterfly_f32+0x304>
{
 800226e:	900c      	str	r0, [sp, #48]	@ 0x30
 8002270:	468a      	mov	sl, r1
   n2 = fftLen;
 8002272:	468b      	mov	fp, r1
 8002274:	930d      	str	r3, [sp, #52]	@ 0x34
      n2 = n2 >> 3;
 8002276:	ea4f 07db 	mov.w	r7, fp, lsr #3
 800227a:	eb07 0187 	add.w	r1, r7, r7, lsl #2
 800227e:	ea4f 00cb 	mov.w	r0, fp, lsl #3
 8002282:	9000      	str	r0, [sp, #0]
 8002284:	00c8      	lsls	r0, r1, #3
 8002286:	ebc7 01c7 	rsb	r1, r7, r7, lsl #3
 800228a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 800228c:	9002      	str	r0, [sp, #8]
 800228e:	ea4f 09c7 	mov.w	r9, r7, lsl #3
 8002292:	00c8      	lsls	r0, r1, #3
 8002294:	ea4f 1807 	mov.w	r8, r7, lsl #4
 8002298:	9005      	str	r0, [sp, #20]
 800229a:	f108 0104 	add.w	r1, r8, #4
 800229e:	f109 0004 	add.w	r0, r9, #4
 80022a2:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 80022a6:	eb03 1247 	add.w	r2, r3, r7, lsl #5
 80022aa:	4418      	add	r0, r3
 80022ac:	4419      	add	r1, r3
 80022ae:	017b      	lsls	r3, r7, #5
 80022b0:	9301      	str	r3, [sp, #4]
 80022b2:	0133      	lsls	r3, r6, #4
 80022b4:	eb02 1507 	add.w	r5, r2, r7, lsl #4
 80022b8:	9303      	str	r3, [sp, #12]
 80022ba:	00f3      	lsls	r3, r6, #3
 80022bc:	eba5 04c6 	sub.w	r4, r5, r6, lsl #3
 80022c0:	9304      	str	r3, [sp, #16]
 80022c2:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
      i1 = 0;
 80022c4:	9b00      	ldr	r3, [sp, #0]
      n2 = n2 >> 3;
 80022c6:	9709      	str	r7, [sp, #36]	@ 0x24
      i1 = 0;
 80022c8:	eb02 0cc7 	add.w	ip, r2, r7, lsl #3
 80022cc:	f04f 0e00 	mov.w	lr, #0
 80022d0:	eb04 1747 	add.w	r7, r4, r7, lsl #5
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80022d4:	edd5 9a00 	vldr	s19, [r5]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80022d8:	ed94 4a00 	vldr	s8, [r4]
 80022dc:	ed97 9a00 	vldr	s18, [r7]
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80022e0:	ed11 2a01 	vldr	s4, [r1, #-4]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80022e4:	ed92 6a00 	vldr	s12, [r2]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80022e8:	ed9c 5a00 	vldr	s10, [ip]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80022ec:	ed56 3a01 	vldr	s7, [r6, #-4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80022f0:	ed50 7a01 	vldr	s15, [r0, #-4]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80022f4:	ee34 8a09 	vadd.f32	s16, s8, s18
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80022f8:	ee37 0a85 	vadd.f32	s0, s15, s10
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80022fc:	ee32 3a29 	vadd.f32	s6, s4, s19
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002300:	ee33 7a86 	vadd.f32	s14, s7, s12
         r2 = r2 + r4;
 8002304:	ee70 5a08 	vadd.f32	s11, s0, s16
         r1 = r1 + r3;
 8002308:	ee77 6a03 	vadd.f32	s13, s14, s6
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 800230c:	ee77 7ac5 	vsub.f32	s15, s15, s10
         pSrc[2 * i1] = r1 + r2;
 8002310:	ee36 5aa5 	vadd.f32	s10, s13, s11
         pSrc[2 * i5] = r1 - r2;
 8002314:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i1] = r1 + r2;
 8002318:	ed06 5a01 	vstr	s10, [r6, #-4]
         pSrc[2 * i5] = r1 - r2;
 800231c:	edc2 6a00 	vstr	s13, [r2]
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002320:	ed9c ba01 	vldr	s22, [ip, #4]
 8002324:	edd0 ba00 	vldr	s23, [r0]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002328:	ed94 1a01 	vldr	s2, [r4, #4]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 800232c:	edd2 aa01 	vldr	s21, [r2, #4]
 8002330:	edd6 5a00 	vldr	s11, [r6]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002334:	edd7 2a01 	vldr	s5, [r7, #4]
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002338:	ed91 aa00 	vldr	s20, [r1]
 800233c:	edd5 1a01 	vldr	s3, [r5, #4]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 8002340:	ee7b 6acb 	vsub.f32	s13, s23, s22
         r1 = (r6 - r8) * C81;
 8002344:	ee37 5ac4 	vsub.f32	s10, s15, s8
         r2 = (s6 - s8) * C81;
 8002348:	ee76 4ac1 	vsub.f32	s9, s13, s2
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 800234c:	ee75 0aea 	vsub.f32	s1, s11, s21
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8002350:	ee73 3ac6 	vsub.f32	s7, s7, s12
         r1 = (r6 - r8) * C81;
 8002354:	ee35 5a09 	vadd.f32	s10, s10, s18
         r2 = (s6 - s8) * C81;
 8002358:	ee34 6aa2 	vadd.f32	s12, s9, s5
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 800235c:	eef0 8a60 	vmov.f32	s17, s1
         t1 = r5 - r1;
 8002360:	eef0 4a63 	vmov.f32	s9, s7
 8002364:	eee5 4a4c 	vfms.f32	s9, s10, s24
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 8002368:	44de      	add	lr, fp
      } while (i1 < fftLen);
 800236a:	45f2      	cmp	sl, lr
         t2 = s5 - r2;
 800236c:	eee6 8a4c 	vfms.f32	s17, s12, s24
         r6 = (r6 + r8) * C81;
 8002370:	ee77 7ac9 	vsub.f32	s15, s15, s18
         s6 = (s6 + s8) * C81;
 8002374:	ee76 6ae2 	vsub.f32	s13, s13, s5
         r6 = (r6 + r8) * C81;
 8002378:	ee77 7a84 	vadd.f32	s15, s15, s8
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 800237c:	ee32 9a69 	vsub.f32	s18, s4, s19
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8002380:	ee3a 4a61 	vsub.f32	s8, s20, s3
         s6 = (s6 + s8) * C81;
 8002384:	ee76 6a81 	vadd.f32	s13, s13, s2
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002388:	ee75 5aaa 	vadd.f32	s11, s11, s21
 800238c:	ee39 2ac2 	vsub.f32	s4, s19, s4
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002390:	ee7a aa21 	vadd.f32	s21, s20, s3
 8002394:	ee71 1aca 	vsub.f32	s3, s3, s20
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002398:	ee7b ba8b 	vadd.f32	s23, s23, s22
         r5 = r5 + r1;
 800239c:	eee5 3a0c 	vfma.f32	s7, s10, s24
         s7 = s7 + s6;
 80023a0:	eeb0 aa44 	vmov.f32	s20, s8
 80023a4:	eeb0 ba64 	vmov.f32	s22, s9
         r7 = r7 + r6;
 80023a8:	eeb0 5a49 	vmov.f32	s10, s18
 80023ac:	eef0 9a68 	vmov.f32	s19, s17
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80023b0:	ee31 1a22 	vadd.f32	s2, s2, s5
         r7 = r7 + r6;
 80023b4:	eea7 5a8c 	vfma.f32	s10, s15, s24
         s5 = s5 + r2;
 80023b8:	eee6 0a0c 	vfma.f32	s1, s12, s24
         s7 = s7 + s6;
 80023bc:	eea6 aa8c 	vfma.f32	s20, s13, s24
         t2 = r1 - s3;
 80023c0:	ee35 6aea 	vsub.f32	s12, s11, s21
 80023c4:	eee6 1a8c 	vfma.f32	s3, s13, s24
         t1 = r1 - r3;
 80023c8:	ee37 7a43 	vsub.f32	s14, s14, s6
         r1 = r1 + s3;
 80023cc:	eee7 9acc 	vfms.f32	s19, s15, s24
 80023d0:	eea6 bacc 	vfms.f32	s22, s13, s24
 80023d4:	eea7 2a8c 	vfma.f32	s4, s15, s24
         r2 = r2 + r4;
 80023d8:	ee7b 2a81 	vadd.f32	s5, s23, s2
         pSrc[2 * i3]     = t1 + s3;
 80023dc:	ee77 6a41 	vsub.f32	s13, s14, s2
         r1 = r1 + s3;
 80023e0:	ee75 7aaa 	vadd.f32	s15, s11, s21
         pSrc[2 * i3 + 1] = t2 - r3;
 80023e4:	ee36 3a40 	vsub.f32	s6, s12, s0
         pSrc[2 * i7]     = t1 - s3;
 80023e8:	ee37 7a6b 	vsub.f32	s14, s14, s23
         pSrc[2 * i7 + 1] = t2 + r3;
 80023ec:	ee36 6a48 	vsub.f32	s12, s12, s16
         pSrc[2 * i1 + 1] = r1 + r2;
 80023f0:	ee77 aaa2 	vadd.f32	s21, s15, s5
         pSrc[2 * i7]     = t1 - s3;
 80023f4:	ee37 7a01 	vadd.f32	s14, s14, s2
         pSrc[2 * i5 + 1] = r1 - r2;
 80023f8:	ee77 7ae2 	vsub.f32	s15, s15, s5
         pSrc[2 * i2]     = r5 + s7;
 80023fc:	ee33 1a8a 	vadd.f32	s2, s7, s20
         pSrc[2 * i3]     = t1 + s3;
 8002400:	ee76 2aab 	vadd.f32	s5, s13, s23
         pSrc[2 * i4]     = t1 - s8;
 8002404:	ee74 4aa1 	vadd.f32	s9, s9, s3
         pSrc[2 * i3 + 1] = t2 - r3;
 8002408:	ee33 3a08 	vadd.f32	s6, s6, s16
         pSrc[2 * i2 + 1] = s5 - r7;
 800240c:	ee70 1ac5 	vsub.f32	s3, s1, s10
         pSrc[2 * i7 + 1] = t2 + r3;
 8002410:	ee36 6a00 	vadd.f32	s12, s12, s0
         pSrc[2 * i8]     = r5 - s7;
 8002414:	ee73 3aca 	vsub.f32	s7, s7, s20
         pSrc[2 * i6]     = t1 + s8;
 8002418:	ee34 4a0b 	vadd.f32	s8, s8, s22
         pSrc[2 * i8 + 1] = s5 + r7;
 800241c:	ee35 5a20 	vadd.f32	s10, s10, s1
         pSrc[2 * i6 + 1] = t2 - r8;
 8002420:	ee78 5a82 	vadd.f32	s11, s17, s4
         pSrc[2 * i4 + 1] = t2 + r8;
 8002424:	ee79 6a29 	vadd.f32	s13, s18, s19
         pSrc[2 * i1 + 1] = r1 + r2;
 8002428:	edc6 aa00 	vstr	s21, [r6]
         pSrc[2 * i5 + 1] = r1 - r2;
 800242c:	edc2 7a01 	vstr	s15, [r2, #4]
      } while (i1 < fftLen);
 8002430:	441e      	add	r6, r3
         pSrc[2 * i3]     = t1 + s3;
 8002432:	ed41 2a01 	vstr	s5, [r1, #-4]
      } while (i1 < fftLen);
 8002436:	441a      	add	r2, r3
         pSrc[2 * i7]     = t1 - s3;
 8002438:	ed85 7a00 	vstr	s14, [r5]
         pSrc[2 * i3 + 1] = t2 - r3;
 800243c:	ed81 3a00 	vstr	s6, [r1]
         pSrc[2 * i7 + 1] = t2 + r3;
 8002440:	ed85 6a01 	vstr	s12, [r5, #4]
      } while (i1 < fftLen);
 8002444:	4419      	add	r1, r3
         pSrc[2 * i2]     = r5 + s7;
 8002446:	ed00 1a01 	vstr	s2, [r0, #-4]
      } while (i1 < fftLen);
 800244a:	441d      	add	r5, r3
         pSrc[2 * i8]     = r5 - s7;
 800244c:	edc7 3a00 	vstr	s7, [r7]
         pSrc[2 * i6]     = t1 + s8;
 8002450:	ed8c 4a00 	vstr	s8, [ip]
         pSrc[2 * i4]     = t1 - s8;
 8002454:	edc4 4a00 	vstr	s9, [r4]
         pSrc[2 * i2 + 1] = s5 - r7;
 8002458:	edc0 1a00 	vstr	s3, [r0]
         pSrc[2 * i8 + 1] = s5 + r7;
 800245c:	ed87 5a01 	vstr	s10, [r7, #4]
      } while (i1 < fftLen);
 8002460:	4418      	add	r0, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 8002462:	edcc 5a01 	vstr	s11, [ip, #4]
      } while (i1 < fftLen);
 8002466:	441f      	add	r7, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 8002468:	edc4 6a01 	vstr	s13, [r4, #4]
      } while (i1 < fftLen);
 800246c:	449c      	add	ip, r3
 800246e:	441c      	add	r4, r3
 8002470:	f63f af30 	bhi.w	80022d4 <arm_radix8_butterfly_f32+0x7c>

      if (n2 < 8)
 8002474:	461f      	mov	r7, r3
 8002476:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002478:	2b07      	cmp	r3, #7
 800247a:	f240 81a1 	bls.w	80027c0 <arm_radix8_butterfly_f32+0x568>
 800247e:	9d01      	ldr	r5, [sp, #4]
 8002480:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8002482:	9c02      	ldr	r4, [sp, #8]
 8002484:	9803      	ldr	r0, [sp, #12]
 8002486:	9904      	ldr	r1, [sp, #16]
 8002488:	9a05      	ldr	r2, [sp, #20]
 800248a:	3508      	adds	r5, #8
 800248c:	f109 0908 	add.w	r9, r9, #8
 8002490:	1973      	adds	r3, r6, r5
 8002492:	3408      	adds	r4, #8
 8002494:	9308      	str	r3, [sp, #32]
 8002496:	eb06 0309 	add.w	r3, r6, r9
 800249a:	3008      	adds	r0, #8
 800249c:	9307      	str	r3, [sp, #28]
 800249e:	1933      	adds	r3, r6, r4
 80024a0:	3108      	adds	r1, #8
 80024a2:	9306      	str	r3, [sp, #24]
 80024a4:	1833      	adds	r3, r6, r0
 80024a6:	3208      	adds	r2, #8
 80024a8:	9305      	str	r3, [sp, #20]
 80024aa:	1873      	adds	r3, r6, r1
 80024ac:	f108 080c 	add.w	r8, r8, #12
 80024b0:	9304      	str	r3, [sp, #16]
 80024b2:	18b3      	adds	r3, r6, r2
 80024b4:	9303      	str	r3, [sp, #12]
 80024b6:	eb06 0308 	add.w	r3, r6, r8
 80024ba:	9301      	str	r3, [sp, #4]
 80024bc:	f106 030c 	add.w	r3, r6, #12
 80024c0:	9302      	str	r3, [sp, #8]
         break;

      ia1 = 0;
      j = 1;
 80024c2:	f04f 0901 	mov.w	r9, #1
      ia1 = 0;
 80024c6:	f04f 0800 	mov.w	r8, #0
 80024ca:	463b      	mov	r3, r7

      do
      {
         /*  index calculation for the coefficients */
         id  = ia1 + twidCoefModifier;
 80024cc:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80024ce:	4490      	add	r8, r2
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 80024d0:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 80024d2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024d6:	ed92 fa00 	vldr	s30, [r2]
         co3 = pCoef[2 * ia2];
 80024da:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024de:	edd2 ea00 	vldr	s29, [r2]
         co4 = pCoef[2 * ia3];
 80024e2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024e6:	ed92 ea00 	vldr	s28, [r2]
         co5 = pCoef[2 * ia4];
 80024ea:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024ee:	edd2 da00 	vldr	s27, [r2]
         co6 = pCoef[2 * ia5];
 80024f2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024f6:	ed92 da00 	vldr	s26, [r2]
         co7 = pCoef[2 * ia6];
 80024fa:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80024fe:	eb08 0148 	add.w	r1, r8, r8, lsl #1
 8002502:	edd2 ca00 	vldr	s25, [r2]
         co8 = pCoef[2 * ia7];
 8002506:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800250a:	edd2 ba00 	vldr	s23, [r2]
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
         si8 = pCoef[2 * ia7 + 1];
 800250e:	ed92 ba01 	vldr	s22, [r2, #4]
 8002512:	eba2 1201 	sub.w	r2, r2, r1, lsl #4
         si2 = pCoef[2 * ia1 + 1];
 8002516:	edd2 aa01 	vldr	s21, [r2, #4]
         si3 = pCoef[2 * ia2 + 1];
 800251a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800251e:	ed92 aa01 	vldr	s20, [r2, #4]
         si4 = pCoef[2 * ia3 + 1];
 8002522:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002526:	edd2 9a01 	vldr	s19, [r2, #4]
         si5 = pCoef[2 * ia4 + 1];
 800252a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800252e:	ed92 9a01 	vldr	s18, [r2, #4]
         si6 = pCoef[2 * ia5 + 1];
 8002532:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002536:	edd2 8a01 	vldr	s17, [r2, #4]
         si7 = pCoef[2 * ia6 + 1];
 800253a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800253e:	edd2 7a01 	vldr	s15, [r2, #4]
         si8 = pCoef[2 * ia7 + 1];
 8002542:	e9dd c701 	ldrd	ip, r7, [sp, #4]
 8002546:	e9dd 6503 	ldrd	r6, r5, [sp, #12]
 800254a:	e9dd 4005 	ldrd	r4, r0, [sp, #20]
 800254e:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
         si7 = pCoef[2 * ia6 + 1];
 8002552:	edcd 7a00 	vstr	s15, [sp]

         i1 = j;
 8002556:	46ce      	mov	lr, r9
 8002558:	e002      	b.n	8002560 <arm_radix8_butterfly_f32+0x308>
 800255a:	bf00      	nop
 800255c:	3f3504f3 	.word	0x3f3504f3
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002560:	edd5 4a00 	vldr	s9, [r5]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002564:	ed1c 7a01 	vldr	s14, [ip, #-4]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002568:	edd6 fa00 	vldr	s31, [r6]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 800256c:	edd4 6a00 	vldr	s13, [r4]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002570:	edd2 3a00 	vldr	s7, [r2]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002574:	ed90 3a00 	vldr	s6, [r0]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002578:	ed57 5a01 	vldr	s11, [r7, #-4]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 800257c:	edd1 7a00 	vldr	s15, [r1]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002580:	ed97 1a00 	vldr	s2, [r7]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002584:	ee74 0aaf 	vadd.f32	s1, s9, s31
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002588:	ee37 0a83 	vadd.f32	s0, s15, s6
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 800258c:	ee37 5a26 	vadd.f32	s10, s14, s13
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002590:	ee35 6aa3 	vadd.f32	s12, s11, s7
            r2 = r2 + r4;
 8002594:	ee30 4a20 	vadd.f32	s8, s0, s1
            r1 = r1 + r3;
 8002598:	ee36 2a05 	vadd.f32	s4, s12, s10
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 800259c:	ee77 7ac3 	vsub.f32	s15, s15, s6
            pSrc[2 * i1] = r1 + r2;
 80025a0:	ee32 3a04 	vadd.f32	s6, s4, s8
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 80025a4:	ee75 5ae3 	vsub.f32	s11, s11, s7
            pSrc[2 * i1] = r1 + r2;
 80025a8:	ed07 3a01 	vstr	s6, [r7, #-4]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 80025ac:	ed90 3a01 	vldr	s6, [r0, #4]
 80025b0:	edd1 3a01 	vldr	s7, [r1, #4]
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80025b4:	ed92 8a01 	vldr	s16, [r2, #4]
            r2 = r1 - r2;
 80025b8:	ee32 2a44 	vsub.f32	s4, s4, s8
            t1 = r1 - r3;
 80025bc:	ee36 6a45 	vsub.f32	s12, s12, s10
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80025c0:	ed95 4a01 	vldr	s8, [r5, #4]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 80025c4:	ee33 5ac3 	vsub.f32	s10, s7, s6
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 80025c8:	ee73 3a83 	vadd.f32	s7, s7, s6
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 80025cc:	ee37 3ae4 	vsub.f32	s6, s15, s9
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 80025d0:	ee77 1a66 	vsub.f32	s3, s14, s13
            r1 = (r6 - r8) * C81;
 80025d4:	ee33 3a2f 	vadd.f32	s6, s6, s31
 80025d8:	ee76 6ac7 	vsub.f32	s13, s13, s14
            r6 = (r6 + r8) * C81;
 80025dc:	ee77 7aef 	vsub.f32	s15, s15, s31
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80025e0:	ed96 7a01 	vldr	s14, [r6, #4]
            s1 = (s6 - s8) * C81;
 80025e4:	ee75 fa44 	vsub.f32	s31, s10, s8
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 80025e8:	ee71 2a48 	vsub.f32	s5, s2, s16
            r6 = (r6 + r8) * C81;
 80025ec:	ee77 7aa4 	vadd.f32	s15, s15, s9
            s1 = (s6 - s8) * C81;
 80025f0:	ee7f fa87 	vadd.f32	s31, s31, s14
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 80025f4:	eef0 4a65 	vmov.f32	s9, s11
 80025f8:	eee3 4a4c 	vfms.f32	s9, s6, s24
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 80025fc:	44de      	add	lr, fp
         } while (i1 < fftLen);
 80025fe:	45f2      	cmp	sl, lr
            r5 = r5 + r1;
 8002600:	eee3 5a0c 	vfma.f32	s11, s6, s24
            t2 = s5 - s1;
 8002604:	eeb0 3a62 	vmov.f32	s6, s5
 8002608:	eeaf 3acc 	vfms.f32	s6, s31, s24
 800260c:	eee7 6a8c 	vfma.f32	s13, s15, s24
            s6 = (s6 + s8) * C81;
 8002610:	ee35 5a47 	vsub.f32	s10, s10, s14
            s6 = t2 - r8;
 8002614:	ee73 6a26 	vadd.f32	s13, s6, s13
 8002618:	eea7 3acc 	vfms.f32	s6, s15, s24
            s6 = (s6 + s8) * C81;
 800261c:	ee35 5a04 	vadd.f32	s10, s10, s8
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002620:	ee31 1a08 	vadd.f32	s2, s2, s16
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002624:	ee34 4a07 	vadd.f32	s8, s8, s14
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002628:	ed9c 8a00 	vldr	s16, [ip]
 800262c:	ed94 7a01 	vldr	s14, [r4, #4]
            s5 = s5 + s1;
 8002630:	eeef 2a8c 	vfma.f32	s5, s31, s24
 8002634:	eef0 fa43 	vmov.f32	s31, s6
            r7 = r7 + r6;
 8002638:	eeb0 3a61 	vmov.f32	s6, s3
 800263c:	eea7 3a8c 	vfma.f32	s6, s15, s24
            t2 = t2 + r8;
 8002640:	ee71 7aaf 	vadd.f32	s15, s3, s31
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002644:	ee78 1a07 	vadd.f32	s3, s16, s14
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8002648:	ee78 fa47 	vsub.f32	s31, s16, s14
            t2 = s1 - s3;
 800264c:	ee37 7a48 	vsub.f32	s14, s14, s16
            s7 = s7 + s6;
 8002650:	eeb0 8a6f 	vmov.f32	s16, s31
 8002654:	eea5 7a0c 	vfma.f32	s14, s10, s24
 8002658:	eea5 8a0c 	vfma.f32	s16, s10, s24
            t1 = t1 - s8;
 800265c:	ee37 7a24 	vadd.f32	s14, s14, s9
 8002660:	eee5 4a4c 	vfms.f32	s9, s10, s24
            t2 = s1 - s3;
 8002664:	ee31 5a61 	vsub.f32	s10, s2, s3
            r6 = t1 + s8;
 8002668:	ee74 4aaf 	vadd.f32	s9, s9, s31
 800266c:	ee75 fa60 	vsub.f32	s31, s10, s1
            s1 = t2 - r3;
 8002670:	ee35 5a40 	vsub.f32	s10, s10, s0
            s1 = s1 + s3;
 8002674:	ee71 1a21 	vadd.f32	s3, s2, s3
            s1 = t2 - r3;
 8002678:	ee35 5a20 	vadd.f32	s10, s10, s1
            s2 = s2 + s4;
 800267c:	ee33 1a84 	vadd.f32	s2, s7, s8
            r1 = t1 + s3;
 8002680:	ee76 0a44 	vsub.f32	s1, s12, s8
 8002684:	ee36 6a63 	vsub.f32	s12, s12, s7
 8002688:	ee70 0aa3 	vadd.f32	s1, s1, s7
            t1 = t1 - s3;
 800268c:	ee34 6a06 	vadd.f32	s12, s8, s12
            pSrc[2 * i1 + 1] = s1 + s2;
 8002690:	ee71 3a81 	vadd.f32	s7, s3, s2
            pSrc[2 * i5 + 1] = p3 - p4;
 8002694:	ee22 4a49 	vnmul.f32	s8, s4, s18
            s2 = s1 - s2;
 8002698:	ee31 1ac1 	vsub.f32	s2, s3, s2
            pSrc[2 * i1 + 1] = s1 + s2;
 800269c:	edc7 3a00 	vstr	s7, [r7]
            pSrc[2 * i5 + 1] = p3 - p4;
 80026a0:	eead 4a81 	vfma.f32	s8, s27, s2
         } while (i1 < fftLen);
 80026a4:	441f      	add	r7, r3
            p2 = si5 * s2;
 80026a6:	ee69 1a01 	vmul.f32	s3, s18, s2
            p2 = si3 * s1;
 80026aa:	ee2a 1a05 	vmul.f32	s2, s20, s10
            pSrc[2 * i5]     = p1 + p2;
 80026ae:	eeed 1a82 	vfma.f32	s3, s27, s4
            pSrc[2 * i3]     = p1 + p2;
 80026b2:	eeb0 2a41 	vmov.f32	s4, s2
            t2 = t2 + r3;
 80026b6:	ee70 fa2f 	vadd.f32	s31, s0, s31
            p2 = si7 * t2;
 80026ba:	eddd 3a00 	vldr	s7, [sp]
            pSrc[2 * i5]     = p1 + p2;
 80026be:	edc2 1a00 	vstr	s3, [r2]
            pSrc[2 * i3]     = p1 + p2;
 80026c2:	eeae 2aa0 	vfma.f32	s4, s29, s1
            pSrc[2 * i3 + 1] = p3 - p4;
 80026c6:	ee60 0aca 	vnmul.f32	s1, s1, s20
            s1 = s5 - r7;
 80026ca:	ee32 1ac3 	vsub.f32	s2, s5, s6
            pSrc[2 * i3 + 1] = p3 - p4;
 80026ce:	eeee 0a85 	vfma.f32	s1, s29, s10
            p2 = si7 * t2;
 80026d2:	ee23 5aaf 	vmul.f32	s10, s7, s31
            pSrc[2 * i7 + 1] = p3 - p4;
 80026d6:	ee66 3a63 	vnmul.f32	s7, s12, s7
            pSrc[2 * i7]     = p1 + p2;
 80026da:	eeac 5a86 	vfma.f32	s10, s25, s12
            r1 = r5 + s7;
 80026de:	ee35 6a88 	vadd.f32	s12, s11, s16
            r5 = r5 - s7;
 80026e2:	ee35 8ac8 	vsub.f32	s16, s11, s16
            pSrc[2 * i5 + 1] = p3 - p4;
 80026e6:	ed82 4a01 	vstr	s8, [r2, #4]
            s5 = s5 + r7;
 80026ea:	ee33 3a22 	vadd.f32	s6, s6, s5
            p2 = si2 * s1;
 80026ee:	ee6a 1a81 	vmul.f32	s3, s21, s2
            pSrc[2 * i8 + 1] = p3 - p4;
 80026f2:	ee28 4a4b 	vnmul.f32	s8, s16, s22
            pSrc[2 * i2 + 1] = p3 - p4;
 80026f6:	ee26 0a6a 	vnmul.f32	s0, s12, s21
            pSrc[2 * i2]     = p1 + p2;
 80026fa:	eeef 1a06 	vfma.f32	s3, s30, s12
         } while (i1 < fftLen);
 80026fe:	441a      	add	r2, r3
            pSrc[2 * i8 + 1] = p3 - p4;
 8002700:	eeab 4a83 	vfma.f32	s8, s23, s6
            p2 = si8 * s5;
 8002704:	ee6b 2a03 	vmul.f32	s5, s22, s6
            p2 = si4 * t2;
 8002708:	ee29 6aa7 	vmul.f32	s12, s19, s15
            pSrc[2 * i4 + 1] = p3 - p4;
 800270c:	ee27 3a69 	vnmul.f32	s6, s14, s19
            pSrc[2 * i2 + 1] = p3 - p4;
 8002710:	eeaf 0a01 	vfma.f32	s0, s30, s2
            p2 = si6 * s6;
 8002714:	ee68 5aa6 	vmul.f32	s11, s17, s13
            pSrc[2 * i6 + 1] = p3 - p4;
 8002718:	ee24 1ae8 	vnmul.f32	s2, s9, s17
            pSrc[2 * i4]     = p1 + p2;
 800271c:	eeae 6a07 	vfma.f32	s12, s28, s14
            pSrc[2 * i4 + 1] = p3 - p4;
 8002720:	eeb0 7a43 	vmov.f32	s14, s6
            pSrc[2 * i7 + 1] = p3 - p4;
 8002724:	eeec 3aaf 	vfma.f32	s7, s25, s31
            pSrc[2 * i8]     = p1 + p2;
 8002728:	eeeb 2a88 	vfma.f32	s5, s23, s16
            pSrc[2 * i6]     = p1 + p2;
 800272c:	eeed 5a24 	vfma.f32	s11, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
 8002730:	eead 1a26 	vfma.f32	s2, s26, s13
            pSrc[2 * i4 + 1] = p3 - p4;
 8002734:	eeae 7a27 	vfma.f32	s14, s28, s15
            pSrc[2 * i3]     = p1 + p2;
 8002738:	ed0c 2a01 	vstr	s4, [ip, #-4]
            pSrc[2 * i3 + 1] = p3 - p4;
 800273c:	edcc 0a00 	vstr	s1, [ip]
            pSrc[2 * i7]     = p1 + p2;
 8002740:	ed84 5a00 	vstr	s10, [r4]
            pSrc[2 * i7 + 1] = p3 - p4;
 8002744:	edc4 3a01 	vstr	s7, [r4, #4]
         } while (i1 < fftLen);
 8002748:	449c      	add	ip, r3
            pSrc[2 * i2]     = p1 + p2;
 800274a:	edc1 1a00 	vstr	s3, [r1]
            pSrc[2 * i2 + 1] = p3 - p4;
 800274e:	ed81 0a01 	vstr	s0, [r1, #4]
         } while (i1 < fftLen);
 8002752:	441c      	add	r4, r3
            pSrc[2 * i8]     = p1 + p2;
 8002754:	edc6 2a00 	vstr	s5, [r6]
            pSrc[2 * i8 + 1] = p3 - p4;
 8002758:	ed86 4a01 	vstr	s8, [r6, #4]
         } while (i1 < fftLen);
 800275c:	4419      	add	r1, r3
            pSrc[2 * i6]     = p1 + p2;
 800275e:	edc0 5a00 	vstr	s11, [r0]
            pSrc[2 * i6 + 1] = p3 - p4;
 8002762:	ed80 1a01 	vstr	s2, [r0, #4]
         } while (i1 < fftLen);
 8002766:	441e      	add	r6, r3
            pSrc[2 * i4]     = p1 + p2;
 8002768:	ed85 6a00 	vstr	s12, [r5]
         } while (i1 < fftLen);
 800276c:	4418      	add	r0, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 800276e:	ed85 7a01 	vstr	s14, [r5, #4]
         } while (i1 < fftLen);
 8002772:	441d      	add	r5, r3
 8002774:	f63f aef4 	bhi.w	8002560 <arm_radix8_butterfly_f32+0x308>

         j++;
      } while (j < n2);
 8002778:	9a08      	ldr	r2, [sp, #32]
 800277a:	3208      	adds	r2, #8
 800277c:	9208      	str	r2, [sp, #32]
 800277e:	9a07      	ldr	r2, [sp, #28]
 8002780:	3208      	adds	r2, #8
 8002782:	9207      	str	r2, [sp, #28]
 8002784:	9a06      	ldr	r2, [sp, #24]
 8002786:	3208      	adds	r2, #8
 8002788:	9206      	str	r2, [sp, #24]
 800278a:	9a05      	ldr	r2, [sp, #20]
 800278c:	3208      	adds	r2, #8
 800278e:	9205      	str	r2, [sp, #20]
 8002790:	9a04      	ldr	r2, [sp, #16]
 8002792:	3208      	adds	r2, #8
 8002794:	9204      	str	r2, [sp, #16]
 8002796:	9a03      	ldr	r2, [sp, #12]
 8002798:	3208      	adds	r2, #8
 800279a:	9203      	str	r2, [sp, #12]
 800279c:	9a02      	ldr	r2, [sp, #8]
 800279e:	3208      	adds	r2, #8
 80027a0:	9202      	str	r2, [sp, #8]
 80027a2:	9a01      	ldr	r2, [sp, #4]
 80027a4:	3208      	adds	r2, #8
 80027a6:	9201      	str	r2, [sp, #4]
 80027a8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
         j++;
 80027aa:	f109 0901 	add.w	r9, r9, #1
      } while (j < n2);
 80027ae:	454a      	cmp	r2, r9
 80027b0:	f47f ae8c 	bne.w	80024cc <arm_radix8_butterfly_f32+0x274>

      twidCoefModifier <<= 3;
 80027b4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80027b6:	00db      	lsls	r3, r3, #3
 80027b8:	b29b      	uxth	r3, r3
 80027ba:	930a      	str	r3, [sp, #40]	@ 0x28
      n2 = n2 >> 3;
 80027bc:	4693      	mov	fp, r2
 80027be:	e55a      	b.n	8002276 <arm_radix8_butterfly_f32+0x1e>
   } while (n2 > 7);
}
 80027c0:	b00f      	add	sp, #60	@ 0x3c
 80027c2:	ecbd 8b10 	vpop	{d8-d15}
 80027c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80027ca:	bf00      	nop

080027cc <arm_rfft_fast_f32>:
ARM_DSP_ATTRIBUTE void arm_rfft_fast_f32(
  const arm_rfft_fast_instance_f32 * S,
  float32_t * p,
  float32_t * pOut,
  uint8_t ifftFlag)
{
 80027cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80027d0:	4615      	mov	r5, r2
 80027d2:	4607      	mov	r7, r0
 80027d4:	460c      	mov	r4, r1
   const arm_cfft_instance_f32 * Sint = &(S->Sint);

   /* Calculation of Real FFT */
   if (ifftFlag)
 80027d6:	461a      	mov	r2, r3
 80027d8:	2b00      	cmp	r3, #0
 80027da:	d056      	beq.n	800288a <arm_rfft_fast_f32+0xbe>
   xAR = pA[0];
 80027dc:	edd1 7a00 	vldr	s15, [r1]
   xAI = pA[1];
 80027e0:	edd1 6a01 	vldr	s13, [r1, #4]
 80027e4:	8800      	ldrh	r0, [r0, #0]
 80027e6:	6979      	ldr	r1, [r7, #20]
   *pOut++ = 0.5f * ( xAR + xAI );
 80027e8:	ee37 7aa6 	vadd.f32	s14, s15, s13
   *pOut++ = 0.5f * ( xAR - xAI );
 80027ec:	ee77 7ae6 	vsub.f32	s15, s15, s13
   *pOut++ = 0.5f * ( xAR + xAI );
 80027f0:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
   k = (S->Sint).fftLen - 1;
 80027f4:	1e43      	subs	r3, r0, #1
   *pOut++ = 0.5f * ( xAR + xAI );
 80027f6:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( xAR - xAI );
 80027fa:	ee67 7a84 	vmul.f32	s15, s15, s8
   while (k > 0)
 80027fe:	2b00      	cmp	r3, #0
   *pOut++ = 0.5f * ( xAR + xAI );
 8002800:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( xAR - xAI );
 8002804:	edc5 7a01 	vstr	s15, [r5, #4]
   pB  =  p + 2*k ;
 8002808:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
   while (k > 0)
 800280c:	dd36      	ble.n	800287c <arm_rfft_fast_f32+0xb0>
 800280e:	f101 0e10 	add.w	lr, r1, #16
 8002812:	ebac 00c0 	sub.w	r0, ip, r0, lsl #3
 8002816:	f104 0110 	add.w	r1, r4, #16
 800281a:	f1ac 0c08 	sub.w	ip, ip, #8
 800281e:	f105 0610 	add.w	r6, r5, #16
      xBI =   pB[1]    ;
 8002822:	eddc 6a03 	vldr	s13, [ip, #12]
      xBR =   pB[0]    ;
 8002826:	eddc 7a02 	vldr	s15, [ip, #8]
      xAR =  pA[0];
 800282a:	ed11 7a02 	vldr	s14, [r1, #-8]
      xAI =  pA[1];
 800282e:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 8002832:	ed1e 6a02 	vldr	s12, [lr, #-8]
      twI = *pCoeff++;
 8002836:	ed5e 5a01 	vldr	s11, [lr, #-4]
      t1a = xAR - xBR ;
 800283a:	ee77 4a67 	vsub.f32	s9, s14, s15
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 800283e:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 8002842:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 8002846:	eee6 7a64 	vfms.f32	s15, s12, s9
   while (k > 0)
 800284a:	f1ac 0c08 	sub.w	ip, ip, #8
 800284e:	3608      	adds	r6, #8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 8002850:	eea5 7aa4 	vfma.f32	s14, s11, s9
   while (k > 0)
 8002854:	4560      	cmp	r0, ip
 8002856:	f10e 0e08 	add.w	lr, lr, #8
      t1b = xAI + xBI ;
 800285a:	ee76 6a85 	vadd.f32	s13, s13, s10
   while (k > 0)
 800285e:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 8002862:	eee5 7ae6 	vfms.f32	s15, s11, s13
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 8002866:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 800286a:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 800286e:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 8002872:	ed46 7a04 	vstr	s15, [r6, #-16]
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 8002876:	ed06 7a03 	vstr	s14, [r6, #-12]
   while (k > 0)
 800287a:	d1d2      	bne.n	8002822 <arm_rfft_fast_f32+0x56>
   {
      /*  Real FFT compression */
      merge_rfft_f32(S, p, pOut);
      /* Complex radix-4 IFFT process */
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 800287c:	4629      	mov	r1, r5
 800287e:	4638      	mov	r0, r7
 8002880:	2301      	movs	r3, #1
      arm_cfft_f32( Sint, p, ifftFlag, 1);

      /*  Real FFT extraction */
      stage_rfft_f32(S, p, pOut);
   }
}
 8002882:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 8002886:	f7ff b951 	b.w	8001b2c <arm_cfft_f32>
      arm_cfft_f32( Sint, p, ifftFlag, 1);
 800288a:	2301      	movs	r3, #1
 800288c:	f7ff f94e 	bl	8001b2c <arm_cfft_f32>
   t1b = xBI + xAI  ;
 8002890:	edd4 7a01 	vldr	s15, [r4, #4]
   xBR = pB[0];
 8002894:	ed94 6a00 	vldr	s12, [r4]
   k = (S->Sint).fftLen - 1;
 8002898:	883e      	ldrh	r6, [r7, #0]
 800289a:	6978      	ldr	r0, [r7, #20]
   t1b = xBI + xAI  ;
 800289c:	ee77 7aa7 	vadd.f32	s15, s15, s15
   *pOut++ = 0.5f * ( t1a + t1b );
 80028a0:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 80028a4:	eeb0 7a67 	vmov.f32	s14, s15
 80028a8:	eea6 7a26 	vfma.f32	s14, s12, s13
   k = (S->Sint).fftLen - 1;
 80028ac:	3e01      	subs	r6, #1
   *pOut++ = 0.5f * ( t1a + t1b );
 80028ae:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
   *pOut++ = 0.5f * ( t1a - t1b );
 80028b2:	eed6 7a26 	vfnms.f32	s15, s12, s13
 80028b6:	3010      	adds	r0, #16
 80028b8:	f105 0210 	add.w	r2, r5, #16
   *pOut++ = 0.5f * ( t1a + t1b );
 80028bc:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 80028c0:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( t1a - t1b );
 80028c4:	ee67 7a84 	vmul.f32	s15, s15, s8
   *pOut++ = 0.5f * ( t1a + t1b );
 80028c8:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( t1a - t1b );
 80028cc:	edc5 7a01 	vstr	s15, [r5, #4]
   pA += 2;
 80028d0:	f104 0110 	add.w	r1, r4, #16
 80028d4:	3b08      	subs	r3, #8
      xAR = pA[0];
 80028d6:	ed11 7a02 	vldr	s14, [r1, #-8]
      xBI = pB[1];
 80028da:	edd3 6a03 	vldr	s13, [r3, #12]
      xBR = pB[0];
 80028de:	edd3 7a02 	vldr	s15, [r3, #8]
      xAI = pA[1];
 80028e2:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 80028e6:	ed10 6a02 	vldr	s12, [r0, #-8]
      twI = *pCoeff++;
 80028ea:	ed50 5a01 	vldr	s11, [r0, #-4]
      t1a = xBR - xAR ;
 80028ee:	ee77 4ac7 	vsub.f32	s9, s15, s14
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80028f2:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 80028f6:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80028fa:	eee6 7a24 	vfma.f32	s15, s12, s9
      k--;
 80028fe:	3e01      	subs	r6, #1
   } while (k > 0);
 8002900:	3208      	adds	r2, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 8002902:	eea5 7aa4 	vfma.f32	s14, s11, s9
   } while (k > 0);
 8002906:	2e00      	cmp	r6, #0
 8002908:	f100 0008 	add.w	r0, r0, #8
      t1b = xBI + xAI ;
 800290c:	ee76 6a85 	vadd.f32	s13, s13, s10
   } while (k > 0);
 8002910:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002914:	eee5 7aa6 	vfma.f32	s15, s11, s13
   } while (k > 0);
 8002918:	f1a3 0308 	sub.w	r3, r3, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 800291c:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002920:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 8002924:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002928:	ed42 7a04 	vstr	s15, [r2, #-16]
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 800292c:	ed02 7a03 	vstr	s14, [r2, #-12]
   } while (k > 0);
 8002930:	dcd1      	bgt.n	80028d6 <arm_rfft_fast_f32+0x10a>
}
 8002932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002936:	bf00      	nop

08002938 <arm_rfft_fast_init_256_f32>:
#else
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {

  arm_status status;

  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 8002938:	b150      	cbz	r0, 8002950 <arm_rfft_fast_init_256_f32+0x18>
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {
 800293a:	b510      	push	{r4, lr}
 800293c:	4604      	mov	r4, r0

  status=arm_cfft_init_128_f32(&(S->Sint));
 800293e:	f7ff fc7b 	bl	8002238 <arm_cfft_init_128_f32>
  if (status != ARM_MATH_SUCCESS)
 8002942:	b920      	cbnz	r0, 800294e <arm_rfft_fast_init_256_f32+0x16>
  {
    return(status);
  }
  S->fftLenRFFT = 256U;

  S->pTwiddleRFFT    = (float32_t *) twiddleCoef_rfft_256;
 8002944:	4b04      	ldr	r3, [pc, #16]	@ (8002958 <arm_rfft_fast_init_256_f32+0x20>)
 8002946:	6163      	str	r3, [r4, #20]
  S->fftLenRFFT = 256U;
 8002948:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800294c:	8222      	strh	r2, [r4, #16]

  return ARM_MATH_SUCCESS;
}
 800294e:	bd10      	pop	{r4, pc}
  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 8002950:	f04f 30ff 	mov.w	r0, #4294967295
}
 8002954:	4770      	bx	lr
 8002956:	bf00      	nop
 8002958:	08002e2c 	.word	0x08002e2c

0800295c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800295c:	4a03      	ldr	r2, [pc, #12]	@ (800296c <HAL_IncTick+0x10>)
 800295e:	4b04      	ldr	r3, [pc, #16]	@ (8002970 <HAL_IncTick+0x14>)
 8002960:	6811      	ldr	r1, [r2, #0]
 8002962:	781b      	ldrb	r3, [r3, #0]
 8002964:	440b      	add	r3, r1
 8002966:	6013      	str	r3, [r2, #0]
}
 8002968:	4770      	bx	lr
 800296a:	bf00      	nop
 800296c:	200016a4 	.word	0x200016a4
 8002970:	20000000 	.word	0x20000000

08002974 <uart2_set_fcpu>:

unsigned long f_cpu;

/** Functions ----------------------------------------------------------------*/
void uart2_set_fcpu(unsigned long freq)
{
 8002974:	b480      	push	{r7}
 8002976:	b083      	sub	sp, #12
 8002978:	af00      	add	r7, sp, #0
 800297a:	6078      	str	r0, [r7, #4]
	f_cpu = freq;
 800297c:	4a04      	ldr	r2, [pc, #16]	@ (8002990 <uart2_set_fcpu+0x1c>)
 800297e:	687b      	ldr	r3, [r7, #4]
 8002980:	6013      	str	r3, [r2, #0]
}
 8002982:	bf00      	nop
 8002984:	370c      	adds	r7, #12
 8002986:	46bd      	mov	sp, r7
 8002988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800298c:	4770      	bx	lr
 800298e:	bf00      	nop
 8002990:	200016a8 	.word	0x200016a8

08002994 <uart2_dma1_config>:

	return USART_OK;
}

uart_err_type_t uart2_dma1_config(uint32_t baud, uart_data_type_t ndata, uart_stop_type_t nstop)
{
 8002994:	b5b0      	push	{r4, r5, r7, lr}
 8002996:	b086      	sub	sp, #24
 8002998:	af00      	add	r7, sp, #0
 800299a:	60f8      	str	r0, [r7, #12]
 800299c:	460b      	mov	r3, r1
 800299e:	72fb      	strb	r3, [r7, #11]
 80029a0:	4613      	mov	r3, r2
 80029a2:	72bb      	strb	r3, [r7, #10]
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;	// enable UART2 clock
 80029a4:	4b85      	ldr	r3, [pc, #532]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029a6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80029a8:	4a84      	ldr	r2, [pc, #528]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029aa:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80029ae:	6413      	str	r3, [r2, #64]	@ 0x40
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;	// enable GPIOA clock
 80029b0:	4b82      	ldr	r3, [pc, #520]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029b2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80029b4:	4a81      	ldr	r2, [pc, #516]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029b6:	f043 0301 	orr.w	r3, r3, #1
 80029ba:	6313      	str	r3, [r2, #48]	@ 0x30
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;		// enable DMA1 clock
 80029bc:	4b7f      	ldr	r3, [pc, #508]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80029c0:	4a7e      	ldr	r2, [pc, #504]	@ (8002bbc <uart2_dma1_config+0x228>)
 80029c2:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80029c6:	6313      	str	r3, [r2, #48]	@ 0x30

	/* Setup DMA1 for transmission */
	// disable DMA1 to configure
	DMA1_Stream6->CR &= ~DMA_SxCR_EN;
 80029c8:	4b7d      	ldr	r3, [pc, #500]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029ca:	681b      	ldr	r3, [r3, #0]
 80029cc:	4a7c      	ldr	r2, [pc, #496]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029ce:	f023 0301 	bic.w	r3, r3, #1
 80029d2:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 80029d4:	bf00      	nop
 80029d6:	4b7a      	ldr	r3, [pc, #488]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029d8:	681b      	ldr	r3, [r3, #0]
 80029da:	f003 0301 	and.w	r3, r3, #1
 80029de:	2b00      	cmp	r3, #0
 80029e0:	d1f9      	bne.n	80029d6 <uart2_dma1_config+0x42>

	// select stream 6, channel 4 for USART2_TX
	DMA1_Stream6->CR &= ~DMA_SxCR_CHSEL;
 80029e2:	4b77      	ldr	r3, [pc, #476]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029e4:	681b      	ldr	r3, [r3, #0]
 80029e6:	4a76      	ldr	r2, [pc, #472]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029e8:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
 80029ec:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_CHSEL_2;
 80029ee:	4b74      	ldr	r3, [pc, #464]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029f0:	681b      	ldr	r3, [r3, #0]
 80029f2:	4a73      	ldr	r2, [pc, #460]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029f4:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80029f8:	6013      	str	r3, [r2, #0]

	// disable direct mode
	DMA1_Stream6->FCR |= DMA_SxFCR_DMDIS;
 80029fa:	4b71      	ldr	r3, [pc, #452]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 80029fc:	695b      	ldr	r3, [r3, #20]
 80029fe:	4a70      	ldr	r2, [pc, #448]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a00:	f043 0304 	orr.w	r3, r3, #4
 8002a04:	6153      	str	r3, [r2, #20]

	// normal mode, low priority, 1 byte data size (memory and peripheral)
	DMA1_Stream6->CR &= ~(DMA_SxCR_DBM | DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE);
 8002a06:	4b6e      	ldr	r3, [pc, #440]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a08:	681b      	ldr	r3, [r3, #0]
 8002a0a:	4a6d      	ldr	r2, [pc, #436]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a0c:	f423 23ef 	bic.w	r3, r3, #489472	@ 0x77800
 8002a10:	6013      	str	r3, [r2, #0]

	// memory increment mode
	DMA1_Stream6->CR |= DMA_SxCR_MINC;
 8002a12:	4b6b      	ldr	r3, [pc, #428]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a14:	681b      	ldr	r3, [r3, #0]
 8002a16:	4a6a      	ldr	r2, [pc, #424]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a18:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8002a1c:	6013      	str	r3, [r2, #0]

	// fixed peripheral pointer
	DMA1_Stream6->CR &= ~DMA_SxCR_PINC;
 8002a1e:	4b68      	ldr	r3, [pc, #416]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a20:	681b      	ldr	r3, [r3, #0]
 8002a22:	4a67      	ldr	r2, [pc, #412]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a24:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8002a28:	6013      	str	r3, [r2, #0]

	// disable circular mode
	DMA1_Stream6->CR &= ~DMA_SxCR_CIRC;
 8002a2a:	4b65      	ldr	r3, [pc, #404]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a2c:	681b      	ldr	r3, [r3, #0]
 8002a2e:	4a64      	ldr	r2, [pc, #400]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a30:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8002a34:	6013      	str	r3, [r2, #0]

	// memory to peripheral mode
	DMA1_Stream6->CR &= ~DMA_SxCR_DIR_1;
 8002a36:	4b62      	ldr	r3, [pc, #392]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a38:	681b      	ldr	r3, [r3, #0]
 8002a3a:	4a61      	ldr	r2, [pc, #388]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a3c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002a40:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_DIR_0;
 8002a42:	4b5f      	ldr	r3, [pc, #380]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a44:	681b      	ldr	r3, [r3, #0]
 8002a46:	4a5e      	ldr	r2, [pc, #376]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a48:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8002a4c:	6013      	str	r3, [r2, #0]

	// peripheral address is USART2_DR
	DMA1_Stream6->PAR = (uint32_t)&(USART2->DR);
 8002a4e:	4b5c      	ldr	r3, [pc, #368]	@ (8002bc0 <uart2_dma1_config+0x22c>)
 8002a50:	4a5c      	ldr	r2, [pc, #368]	@ (8002bc4 <uart2_dma1_config+0x230>)
 8002a52:	609a      	str	r2, [r3, #8]

	/* Setup UART2 for transmission using DMA1 */
	// alternate function mode on TX (PA2) and RX (PA3)
	GPIOA->MODER |= GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;
 8002a54:	4b5c      	ldr	r3, [pc, #368]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a56:	681b      	ldr	r3, [r3, #0]
 8002a58:	4a5b      	ldr	r2, [pc, #364]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a5a:	f043 03a0 	orr.w	r3, r3, #160	@ 0xa0
 8002a5e:	6013      	str	r3, [r2, #0]
	GPIOA->MODER &= ~(GPIO_MODER_MODER2_0 | GPIO_MODER_MODER3_0);
 8002a60:	4b59      	ldr	r3, [pc, #356]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a62:	681b      	ldr	r3, [r3, #0]
 8002a64:	4a58      	ldr	r2, [pc, #352]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a66:	f023 0350 	bic.w	r3, r3, #80	@ 0x50
 8002a6a:	6013      	str	r3, [r2, #0]

	// select alternate function mode 7 for each
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL2 | GPIO_AFRL_AFRL3);
 8002a6c:	4b56      	ldr	r3, [pc, #344]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a6e:	6a1b      	ldr	r3, [r3, #32]
 8002a70:	4a55      	ldr	r2, [pc, #340]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a72:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8002a76:	6213      	str	r3, [r2, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL2_0 | GPIO_AFRL_AFRL3_0 |
 8002a78:	4b53      	ldr	r3, [pc, #332]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a7a:	6a1b      	ldr	r3, [r3, #32]
 8002a7c:	4a52      	ldr	r2, [pc, #328]	@ (8002bc8 <uart2_dma1_config+0x234>)
 8002a7e:	f443 43ee 	orr.w	r3, r3, #30464	@ 0x7700
 8002a82:	6213      	str	r3, [r2, #32]
					GPIO_AFRL_AFRL2_1 | GPIO_AFRL_AFRL3_1 |
					GPIO_AFRL_AFRL2_2 | GPIO_AFRL_AFRL3_2;

	USART2->CR1 |= USART_CR1_UE;			// UART2 enable
 8002a84:	4b51      	ldr	r3, [pc, #324]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002a86:	68db      	ldr	r3, [r3, #12]
 8002a88:	4a50      	ldr	r2, [pc, #320]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002a8a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002a8e:	60d3      	str	r3, [r2, #12]

	if (ndata == USART_DATA_8)
 8002a90:	7afb      	ldrb	r3, [r7, #11]
 8002a92:	2b00      	cmp	r3, #0
 8002a94:	d106      	bne.n	8002aa4 <uart2_dma1_config+0x110>
	{
		USART2->CR1 &= ~USART_CR1_M;		// 1 start, 8 data, n stop
 8002a96:	4b4d      	ldr	r3, [pc, #308]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002a98:	68db      	ldr	r3, [r3, #12]
 8002a9a:	4a4c      	ldr	r2, [pc, #304]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002a9c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8002aa0:	60d3      	str	r3, [r2, #12]
 8002aa2:	e00b      	b.n	8002abc <uart2_dma1_config+0x128>
	}
	else if (ndata == USART_DATA_9)
 8002aa4:	7afb      	ldrb	r3, [r7, #11]
 8002aa6:	2b01      	cmp	r3, #1
 8002aa8:	d106      	bne.n	8002ab8 <uart2_dma1_config+0x124>
	{
		USART2->CR1 |= USART_CR1_M;			// 1 start, 9 data, n stop
 8002aaa:	4b48      	ldr	r3, [pc, #288]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002aac:	68db      	ldr	r3, [r3, #12]
 8002aae:	4a47      	ldr	r2, [pc, #284]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ab0:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8002ab4:	60d3      	str	r3, [r2, #12]
 8002ab6:	e001      	b.n	8002abc <uart2_dma1_config+0x128>
	}
	else
	{
		return USART_INVALID_NDATA;
 8002ab8:	2302      	movs	r3, #2
 8002aba:	e07b      	b.n	8002bb4 <uart2_dma1_config+0x220>
	}

	if (nstop == USART_STOP_1)
 8002abc:	7abb      	ldrb	r3, [r7, #10]
 8002abe:	2b00      	cmp	r3, #0
 8002ac0:	d106      	bne.n	8002ad0 <uart2_dma1_config+0x13c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 1 stop bit
 8002ac2:	4b42      	ldr	r3, [pc, #264]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ac4:	691b      	ldr	r3, [r3, #16]
 8002ac6:	4a41      	ldr	r2, [pc, #260]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ac8:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002acc:	6113      	str	r3, [r2, #16]
 8002ace:	e021      	b.n	8002b14 <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_HALF)
 8002ad0:	7abb      	ldrb	r3, [r7, #10]
 8002ad2:	2b01      	cmp	r3, #1
 8002ad4:	d10c      	bne.n	8002af0 <uart2_dma1_config+0x15c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// half stop bit
 8002ad6:	4b3d      	ldr	r3, [pc, #244]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ad8:	691b      	ldr	r3, [r3, #16]
 8002ada:	4a3c      	ldr	r2, [pc, #240]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002adc:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002ae0:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_0;
 8002ae2:	4b3a      	ldr	r3, [pc, #232]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ae4:	691b      	ldr	r3, [r3, #16]
 8002ae6:	4a39      	ldr	r2, [pc, #228]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ae8:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8002aec:	6113      	str	r3, [r2, #16]
 8002aee:	e011      	b.n	8002b14 <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_2)
 8002af0:	7abb      	ldrb	r3, [r7, #10]
 8002af2:	2b02      	cmp	r3, #2
 8002af4:	d10c      	bne.n	8002b10 <uart2_dma1_config+0x17c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 2 stop bits
 8002af6:	4b35      	ldr	r3, [pc, #212]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002af8:	691b      	ldr	r3, [r3, #16]
 8002afa:	4a34      	ldr	r2, [pc, #208]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002afc:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002b00:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_1;
 8002b02:	4b32      	ldr	r3, [pc, #200]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b04:	691b      	ldr	r3, [r3, #16]
 8002b06:	4a31      	ldr	r2, [pc, #196]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b08:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002b0c:	6113      	str	r3, [r2, #16]
 8002b0e:	e001      	b.n	8002b14 <uart2_dma1_config+0x180>
	}
	else
	{
		return USART_INVALID_NSTOP;
 8002b10:	2301      	movs	r3, #1
 8002b12:	e04f      	b.n	8002bb4 <uart2_dma1_config+0x220>
	}

	// pg. 519 STM32F401RE reference
	float usart_div = f_cpu / (2 * 16.0 * baud);		// APB1 bus is 1/2 clock speed of f_cpu
 8002b14:	4b2e      	ldr	r3, [pc, #184]	@ (8002bd0 <uart2_dma1_config+0x23c>)
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	4618      	mov	r0, r3
 8002b1a:	f7fd fc9f 	bl	800045c <__aeabi_ui2d>
 8002b1e:	4604      	mov	r4, r0
 8002b20:	460d      	mov	r5, r1
 8002b22:	68f8      	ldr	r0, [r7, #12]
 8002b24:	f7fd fc9a 	bl	800045c <__aeabi_ui2d>
 8002b28:	f04f 0200 	mov.w	r2, #0
 8002b2c:	4b29      	ldr	r3, [pc, #164]	@ (8002bd4 <uart2_dma1_config+0x240>)
 8002b2e:	f7fd fd0f 	bl	8000550 <__aeabi_dmul>
 8002b32:	4602      	mov	r2, r0
 8002b34:	460b      	mov	r3, r1
 8002b36:	4620      	mov	r0, r4
 8002b38:	4629      	mov	r1, r5
 8002b3a:	f7fd fe33 	bl	80007a4 <__aeabi_ddiv>
 8002b3e:	4602      	mov	r2, r0
 8002b40:	460b      	mov	r3, r1
 8002b42:	4610      	mov	r0, r2
 8002b44:	4619      	mov	r1, r3
 8002b46:	f7fd ff9d 	bl	8000a84 <__aeabi_d2f>
 8002b4a:	4603      	mov	r3, r0
 8002b4c:	617b      	str	r3, [r7, #20]
	uint16_t mantissa = (uint16_t) usart_div;
 8002b4e:	edd7 7a05 	vldr	s15, [r7, #20]
 8002b52:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8002b56:	ee17 3a90 	vmov	r3, s15
 8002b5a:	827b      	strh	r3, [r7, #18]
	uint8_t fraction = (uint8_t) ((usart_div - mantissa) * 16);
 8002b5c:	8a7b      	ldrh	r3, [r7, #18]
 8002b5e:	ee07 3a90 	vmov	s15, r3
 8002b62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002b66:	ed97 7a05 	vldr	s14, [r7, #20]
 8002b6a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8002b6e:	eeb3 7a00 	vmov.f32	s14, #48	@ 0x41800000  16.0
 8002b72:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002b76:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8002b7a:	edc7 7a01 	vstr	s15, [r7, #4]
 8002b7e:	793b      	ldrb	r3, [r7, #4]
 8002b80:	747b      	strb	r3, [r7, #17]
	USART2->BRR = mantissa << 4 | fraction;
 8002b82:	8a7b      	ldrh	r3, [r7, #18]
 8002b84:	011a      	lsls	r2, r3, #4
 8002b86:	7c7b      	ldrb	r3, [r7, #17]
 8002b88:	431a      	orrs	r2, r3
 8002b8a:	4b10      	ldr	r3, [pc, #64]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b8c:	609a      	str	r2, [r3, #8]

	USART2->CR3 |= USART_CR3_DMAT;		// enable DMA transmitter
 8002b8e:	4b0f      	ldr	r3, [pc, #60]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b90:	695b      	ldr	r3, [r3, #20]
 8002b92:	4a0e      	ldr	r2, [pc, #56]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b94:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002b98:	6153      	str	r3, [r2, #20]

	USART2->CR1 |= USART_CR1_TE;		// transmitter enable
 8002b9a:	4b0c      	ldr	r3, [pc, #48]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002b9c:	68db      	ldr	r3, [r3, #12]
 8002b9e:	4a0b      	ldr	r2, [pc, #44]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ba0:	f043 0308 	orr.w	r3, r3, #8
 8002ba4:	60d3      	str	r3, [r2, #12]
	USART2->CR1 |= USART_CR1_RE;		// receiver enable
 8002ba6:	4b09      	ldr	r3, [pc, #36]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002ba8:	68db      	ldr	r3, [r3, #12]
 8002baa:	4a08      	ldr	r2, [pc, #32]	@ (8002bcc <uart2_dma1_config+0x238>)
 8002bac:	f043 0304 	orr.w	r3, r3, #4
 8002bb0:	60d3      	str	r3, [r2, #12]

	return USART_OK;
 8002bb2:	2300      	movs	r3, #0
}
 8002bb4:	4618      	mov	r0, r3
 8002bb6:	3718      	adds	r7, #24
 8002bb8:	46bd      	mov	sp, r7
 8002bba:	bdb0      	pop	{r4, r5, r7, pc}
 8002bbc:	40023800 	.word	0x40023800
 8002bc0:	400260a0 	.word	0x400260a0
 8002bc4:	40004404 	.word	0x40004404
 8002bc8:	40020000 	.word	0x40020000
 8002bcc:	40004400 	.word	0x40004400
 8002bd0:	200016a8 	.word	0x200016a8
 8002bd4:	40400000 	.word	0x40400000

08002bd8 <uart2_dma1_write>:

	return USART_OK;
}

void uart2_dma1_write(uint16_t n, uint8_t * data)
{
 8002bd8:	b480      	push	{r7}
 8002bda:	b083      	sub	sp, #12
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	4603      	mov	r3, r0
 8002be0:	6039      	str	r1, [r7, #0]
 8002be2:	80fb      	strh	r3, [r7, #6]
	while (!(USART2->SR & USART_SR_TXE));	// wait for transmit data register empty
 8002be4:	bf00      	nop
 8002be6:	4b18      	ldr	r3, [pc, #96]	@ (8002c48 <uart2_dma1_write+0x70>)
 8002be8:	681b      	ldr	r3, [r3, #0]
 8002bea:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002bee:	2b00      	cmp	r3, #0
 8002bf0:	d0f9      	beq.n	8002be6 <uart2_dma1_write+0xe>
	USART2->SR &= ~USART_SR_TC;				// clear flag
 8002bf2:	4b15      	ldr	r3, [pc, #84]	@ (8002c48 <uart2_dma1_write+0x70>)
 8002bf4:	681b      	ldr	r3, [r3, #0]
 8002bf6:	4a14      	ldr	r2, [pc, #80]	@ (8002c48 <uart2_dma1_write+0x70>)
 8002bf8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8002bfc:	6013      	str	r3, [r2, #0]

	DMA1_Stream6->CR &= ~DMA_SxCR_EN;		// disable DMA stream
 8002bfe:	4b13      	ldr	r3, [pc, #76]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c00:	681b      	ldr	r3, [r3, #0]
 8002c02:	4a12      	ldr	r2, [pc, #72]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c04:	f023 0301 	bic.w	r3, r3, #1
 8002c08:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 8002c0a:	bf00      	nop
 8002c0c:	4b0f      	ldr	r3, [pc, #60]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c0e:	681b      	ldr	r3, [r3, #0]
 8002c10:	f003 0301 	and.w	r3, r3, #1
 8002c14:	2b00      	cmp	r3, #0
 8002c16:	d1f9      	bne.n	8002c0c <uart2_dma1_write+0x34>

	// clear flags
	DMA1->HIFCR |= DMA_HIFCR_CTCIF6 | DMA_HIFCR_CHTIF6 | DMA_HIFCR_CTEIF6 | DMA_HIFCR_CDMEIF6 | DMA_HIFCR_CFEIF6;
 8002c18:	4b0d      	ldr	r3, [pc, #52]	@ (8002c50 <uart2_dma1_write+0x78>)
 8002c1a:	68db      	ldr	r3, [r3, #12]
 8002c1c:	4a0c      	ldr	r2, [pc, #48]	@ (8002c50 <uart2_dma1_write+0x78>)
 8002c1e:	f443 1374 	orr.w	r3, r3, #3997696	@ 0x3d0000
 8002c22:	60d3      	str	r3, [r2, #12]

	DMA1_Stream6->NDTR = n;					// set # of data items to transfer
 8002c24:	4a09      	ldr	r2, [pc, #36]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c26:	88fb      	ldrh	r3, [r7, #6]
 8002c28:	6053      	str	r3, [r2, #4]
	DMA1_Stream6->M0AR = (uint32_t) data;	// pointer to data
 8002c2a:	4a08      	ldr	r2, [pc, #32]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c2c:	683b      	ldr	r3, [r7, #0]
 8002c2e:	60d3      	str	r3, [r2, #12]
	DMA1_Stream6->CR |= DMA_SxCR_EN;		// enable DMA stream
 8002c30:	4b06      	ldr	r3, [pc, #24]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c32:	681b      	ldr	r3, [r3, #0]
 8002c34:	4a05      	ldr	r2, [pc, #20]	@ (8002c4c <uart2_dma1_write+0x74>)
 8002c36:	f043 0301 	orr.w	r3, r3, #1
 8002c3a:	6013      	str	r3, [r2, #0]
}
 8002c3c:	bf00      	nop
 8002c3e:	370c      	adds	r7, #12
 8002c40:	46bd      	mov	sp, r7
 8002c42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c46:	4770      	bx	lr
 8002c48:	40004400 	.word	0x40004400
 8002c4c:	400260a0 	.word	0x400260a0
 8002c50:	40026000 	.word	0x40026000

08002c54 <memset>:
 8002c54:	4402      	add	r2, r0
 8002c56:	4603      	mov	r3, r0
 8002c58:	4293      	cmp	r3, r2
 8002c5a:	d100      	bne.n	8002c5e <memset+0xa>
 8002c5c:	4770      	bx	lr
 8002c5e:	f803 1b01 	strb.w	r1, [r3], #1
 8002c62:	e7f9      	b.n	8002c58 <memset+0x4>

08002c64 <__libc_init_array>:
 8002c64:	b570      	push	{r4, r5, r6, lr}
 8002c66:	4d0d      	ldr	r5, [pc, #52]	@ (8002c9c <__libc_init_array+0x38>)
 8002c68:	4c0d      	ldr	r4, [pc, #52]	@ (8002ca0 <__libc_init_array+0x3c>)
 8002c6a:	1b64      	subs	r4, r4, r5
 8002c6c:	10a4      	asrs	r4, r4, #2
 8002c6e:	2600      	movs	r6, #0
 8002c70:	42a6      	cmp	r6, r4
 8002c72:	d109      	bne.n	8002c88 <__libc_init_array+0x24>
 8002c74:	4d0b      	ldr	r5, [pc, #44]	@ (8002ca4 <__libc_init_array+0x40>)
 8002c76:	4c0c      	ldr	r4, [pc, #48]	@ (8002ca8 <__libc_init_array+0x44>)
 8002c78:	f000 f818 	bl	8002cac <_init>
 8002c7c:	1b64      	subs	r4, r4, r5
 8002c7e:	10a4      	asrs	r4, r4, #2
 8002c80:	2600      	movs	r6, #0
 8002c82:	42a6      	cmp	r6, r4
 8002c84:	d105      	bne.n	8002c92 <__libc_init_array+0x2e>
 8002c86:	bd70      	pop	{r4, r5, r6, pc}
 8002c88:	f855 3b04 	ldr.w	r3, [r5], #4
 8002c8c:	4798      	blx	r3
 8002c8e:	3601      	adds	r6, #1
 8002c90:	e7ee      	b.n	8002c70 <__libc_init_array+0xc>
 8002c92:	f855 3b04 	ldr.w	r3, [r5], #4
 8002c96:	4798      	blx	r3
 8002c98:	3601      	adds	r6, #1
 8002c9a:	e7f2      	b.n	8002c82 <__libc_init_array+0x1e>
 8002c9c:	080037dc 	.word	0x080037dc
 8002ca0:	080037dc 	.word	0x080037dc
 8002ca4:	080037dc 	.word	0x080037dc
 8002ca8:	080037e0 	.word	0x080037e0

08002cac <_init>:
 8002cac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002cae:	bf00      	nop
 8002cb0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002cb2:	bc08      	pop	{r3}
 8002cb4:	469e      	mov	lr, r3
 8002cb6:	4770      	bx	lr

08002cb8 <_fini>:
 8002cb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002cba:	bf00      	nop
 8002cbc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002cbe:	bc08      	pop	{r3}
 8002cc0:	469e      	mov	lr, r3
 8002cc2:	4770      	bx	lr
