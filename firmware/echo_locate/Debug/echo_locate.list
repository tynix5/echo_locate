
echo_locate.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000028bc  08000198  08000198  00001198  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b18  08002a54  08002a54  00003a54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800356c  0800356c  00005004  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  0800356c  0800356c  00005004  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  0800356c  0800356c  00005004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800356c  0800356c  0000456c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08003570  08003570  00004570  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000004  20000000  08003574  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000016a8  20000004  08003578  00005004  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200016ac  08003578  000056ac  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00005004  2**0
                  CONTENTS, READONLY
 12 .debug_info   00007e57  00000000  00000000  00005034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000019a8  00000000  00000000  0000ce8b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 00003225  00000000  00000000  0000e833  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000458  00000000  00000000  00011a58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000057e  00000000  00000000  00011eb0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000265bf  00000000  00000000  0001242e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000af10  00000000  00000000  000389ed  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000860bd  00000000  00000000  000438fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  000c99ba  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000c04  00000000  00000000  000c9a00  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000070  00000000  00000000  000ca604  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000004 	.word	0x20000004
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08002a3c 	.word	0x08002a3c

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000008 	.word	0x20000008
 80001d4:	08002a3c 	.word	0x08002a3c

080001d8 <__aeabi_drsub>:
 80001d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80001dc:	e002      	b.n	80001e4 <__adddf3>
 80001de:	bf00      	nop

080001e0 <__aeabi_dsub>:
 80001e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080001e4 <__adddf3>:
 80001e4:	b530      	push	{r4, r5, lr}
 80001e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80001ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80001ee:	ea94 0f05 	teq	r4, r5
 80001f2:	bf08      	it	eq
 80001f4:	ea90 0f02 	teqeq	r0, r2
 80001f8:	bf1f      	itttt	ne
 80001fa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80001fe:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000202:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000206:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800020a:	f000 80e2 	beq.w	80003d2 <__adddf3+0x1ee>
 800020e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000212:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000216:	bfb8      	it	lt
 8000218:	426d      	neglt	r5, r5
 800021a:	dd0c      	ble.n	8000236 <__adddf3+0x52>
 800021c:	442c      	add	r4, r5
 800021e:	ea80 0202 	eor.w	r2, r0, r2
 8000222:	ea81 0303 	eor.w	r3, r1, r3
 8000226:	ea82 0000 	eor.w	r0, r2, r0
 800022a:	ea83 0101 	eor.w	r1, r3, r1
 800022e:	ea80 0202 	eor.w	r2, r0, r2
 8000232:	ea81 0303 	eor.w	r3, r1, r3
 8000236:	2d36      	cmp	r5, #54	@ 0x36
 8000238:	bf88      	it	hi
 800023a:	bd30      	pophi	{r4, r5, pc}
 800023c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000240:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000244:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000248:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800024c:	d002      	beq.n	8000254 <__adddf3+0x70>
 800024e:	4240      	negs	r0, r0
 8000250:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000254:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000258:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800025c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000260:	d002      	beq.n	8000268 <__adddf3+0x84>
 8000262:	4252      	negs	r2, r2
 8000264:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000268:	ea94 0f05 	teq	r4, r5
 800026c:	f000 80a7 	beq.w	80003be <__adddf3+0x1da>
 8000270:	f1a4 0401 	sub.w	r4, r4, #1
 8000274:	f1d5 0e20 	rsbs	lr, r5, #32
 8000278:	db0d      	blt.n	8000296 <__adddf3+0xb2>
 800027a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800027e:	fa22 f205 	lsr.w	r2, r2, r5
 8000282:	1880      	adds	r0, r0, r2
 8000284:	f141 0100 	adc.w	r1, r1, #0
 8000288:	fa03 f20e 	lsl.w	r2, r3, lr
 800028c:	1880      	adds	r0, r0, r2
 800028e:	fa43 f305 	asr.w	r3, r3, r5
 8000292:	4159      	adcs	r1, r3
 8000294:	e00e      	b.n	80002b4 <__adddf3+0xd0>
 8000296:	f1a5 0520 	sub.w	r5, r5, #32
 800029a:	f10e 0e20 	add.w	lr, lr, #32
 800029e:	2a01      	cmp	r2, #1
 80002a0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002a4:	bf28      	it	cs
 80002a6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002aa:	fa43 f305 	asr.w	r3, r3, r5
 80002ae:	18c0      	adds	r0, r0, r3
 80002b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80002b8:	d507      	bpl.n	80002ca <__adddf3+0xe6>
 80002ba:	f04f 0e00 	mov.w	lr, #0
 80002be:	f1dc 0c00 	rsbs	ip, ip, #0
 80002c2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002c6:	eb6e 0101 	sbc.w	r1, lr, r1
 80002ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80002ce:	d31b      	bcc.n	8000308 <__adddf3+0x124>
 80002d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80002d4:	d30c      	bcc.n	80002f0 <__adddf3+0x10c>
 80002d6:	0849      	lsrs	r1, r1, #1
 80002d8:	ea5f 0030 	movs.w	r0, r0, rrx
 80002dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80002e0:	f104 0401 	add.w	r4, r4, #1
 80002e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80002e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80002ec:	f080 809a 	bcs.w	8000424 <__adddf3+0x240>
 80002f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80002f4:	bf08      	it	eq
 80002f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80002fa:	f150 0000 	adcs.w	r0, r0, #0
 80002fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000302:	ea41 0105 	orr.w	r1, r1, r5
 8000306:	bd30      	pop	{r4, r5, pc}
 8000308:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800030c:	4140      	adcs	r0, r0
 800030e:	eb41 0101 	adc.w	r1, r1, r1
 8000312:	3c01      	subs	r4, #1
 8000314:	bf28      	it	cs
 8000316:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800031a:	d2e9      	bcs.n	80002f0 <__adddf3+0x10c>
 800031c:	f091 0f00 	teq	r1, #0
 8000320:	bf04      	itt	eq
 8000322:	4601      	moveq	r1, r0
 8000324:	2000      	moveq	r0, #0
 8000326:	fab1 f381 	clz	r3, r1
 800032a:	bf08      	it	eq
 800032c:	3320      	addeq	r3, #32
 800032e:	f1a3 030b 	sub.w	r3, r3, #11
 8000332:	f1b3 0220 	subs.w	r2, r3, #32
 8000336:	da0c      	bge.n	8000352 <__adddf3+0x16e>
 8000338:	320c      	adds	r2, #12
 800033a:	dd08      	ble.n	800034e <__adddf3+0x16a>
 800033c:	f102 0c14 	add.w	ip, r2, #20
 8000340:	f1c2 020c 	rsb	r2, r2, #12
 8000344:	fa01 f00c 	lsl.w	r0, r1, ip
 8000348:	fa21 f102 	lsr.w	r1, r1, r2
 800034c:	e00c      	b.n	8000368 <__adddf3+0x184>
 800034e:	f102 0214 	add.w	r2, r2, #20
 8000352:	bfd8      	it	le
 8000354:	f1c2 0c20 	rsble	ip, r2, #32
 8000358:	fa01 f102 	lsl.w	r1, r1, r2
 800035c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000360:	bfdc      	itt	le
 8000362:	ea41 010c 	orrle.w	r1, r1, ip
 8000366:	4090      	lslle	r0, r2
 8000368:	1ae4      	subs	r4, r4, r3
 800036a:	bfa2      	ittt	ge
 800036c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000370:	4329      	orrge	r1, r5
 8000372:	bd30      	popge	{r4, r5, pc}
 8000374:	ea6f 0404 	mvn.w	r4, r4
 8000378:	3c1f      	subs	r4, #31
 800037a:	da1c      	bge.n	80003b6 <__adddf3+0x1d2>
 800037c:	340c      	adds	r4, #12
 800037e:	dc0e      	bgt.n	800039e <__adddf3+0x1ba>
 8000380:	f104 0414 	add.w	r4, r4, #20
 8000384:	f1c4 0220 	rsb	r2, r4, #32
 8000388:	fa20 f004 	lsr.w	r0, r0, r4
 800038c:	fa01 f302 	lsl.w	r3, r1, r2
 8000390:	ea40 0003 	orr.w	r0, r0, r3
 8000394:	fa21 f304 	lsr.w	r3, r1, r4
 8000398:	ea45 0103 	orr.w	r1, r5, r3
 800039c:	bd30      	pop	{r4, r5, pc}
 800039e:	f1c4 040c 	rsb	r4, r4, #12
 80003a2:	f1c4 0220 	rsb	r2, r4, #32
 80003a6:	fa20 f002 	lsr.w	r0, r0, r2
 80003aa:	fa01 f304 	lsl.w	r3, r1, r4
 80003ae:	ea40 0003 	orr.w	r0, r0, r3
 80003b2:	4629      	mov	r1, r5
 80003b4:	bd30      	pop	{r4, r5, pc}
 80003b6:	fa21 f004 	lsr.w	r0, r1, r4
 80003ba:	4629      	mov	r1, r5
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	f094 0f00 	teq	r4, #0
 80003c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80003c6:	bf06      	itte	eq
 80003c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80003cc:	3401      	addeq	r4, #1
 80003ce:	3d01      	subne	r5, #1
 80003d0:	e74e      	b.n	8000270 <__adddf3+0x8c>
 80003d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003d6:	bf18      	it	ne
 80003d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003dc:	d029      	beq.n	8000432 <__adddf3+0x24e>
 80003de:	ea94 0f05 	teq	r4, r5
 80003e2:	bf08      	it	eq
 80003e4:	ea90 0f02 	teqeq	r0, r2
 80003e8:	d005      	beq.n	80003f6 <__adddf3+0x212>
 80003ea:	ea54 0c00 	orrs.w	ip, r4, r0
 80003ee:	bf04      	itt	eq
 80003f0:	4619      	moveq	r1, r3
 80003f2:	4610      	moveq	r0, r2
 80003f4:	bd30      	pop	{r4, r5, pc}
 80003f6:	ea91 0f03 	teq	r1, r3
 80003fa:	bf1e      	ittt	ne
 80003fc:	2100      	movne	r1, #0
 80003fe:	2000      	movne	r0, #0
 8000400:	bd30      	popne	{r4, r5, pc}
 8000402:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000406:	d105      	bne.n	8000414 <__adddf3+0x230>
 8000408:	0040      	lsls	r0, r0, #1
 800040a:	4149      	adcs	r1, r1
 800040c:	bf28      	it	cs
 800040e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000412:	bd30      	pop	{r4, r5, pc}
 8000414:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000418:	bf3c      	itt	cc
 800041a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 800041e:	bd30      	popcc	{r4, r5, pc}
 8000420:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000424:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000428:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800042c:	f04f 0000 	mov.w	r0, #0
 8000430:	bd30      	pop	{r4, r5, pc}
 8000432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000436:	bf1a      	itte	ne
 8000438:	4619      	movne	r1, r3
 800043a:	4610      	movne	r0, r2
 800043c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000440:	bf1c      	itt	ne
 8000442:	460b      	movne	r3, r1
 8000444:	4602      	movne	r2, r0
 8000446:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800044a:	bf06      	itte	eq
 800044c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000450:	ea91 0f03 	teqeq	r1, r3
 8000454:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000458:	bd30      	pop	{r4, r5, pc}
 800045a:	bf00      	nop

0800045c <__aeabi_ui2d>:
 800045c:	f090 0f00 	teq	r0, #0
 8000460:	bf04      	itt	eq
 8000462:	2100      	moveq	r1, #0
 8000464:	4770      	bxeq	lr
 8000466:	b530      	push	{r4, r5, lr}
 8000468:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800046c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000470:	f04f 0500 	mov.w	r5, #0
 8000474:	f04f 0100 	mov.w	r1, #0
 8000478:	e750      	b.n	800031c <__adddf3+0x138>
 800047a:	bf00      	nop

0800047c <__aeabi_i2d>:
 800047c:	f090 0f00 	teq	r0, #0
 8000480:	bf04      	itt	eq
 8000482:	2100      	moveq	r1, #0
 8000484:	4770      	bxeq	lr
 8000486:	b530      	push	{r4, r5, lr}
 8000488:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800048c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000490:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000494:	bf48      	it	mi
 8000496:	4240      	negmi	r0, r0
 8000498:	f04f 0100 	mov.w	r1, #0
 800049c:	e73e      	b.n	800031c <__adddf3+0x138>
 800049e:	bf00      	nop

080004a0 <__aeabi_f2d>:
 80004a0:	0042      	lsls	r2, r0, #1
 80004a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004a6:	ea4f 0131 	mov.w	r1, r1, rrx
 80004aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ae:	bf1f      	itttt	ne
 80004b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80004b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80004b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80004bc:	4770      	bxne	lr
 80004be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80004c2:	bf08      	it	eq
 80004c4:	4770      	bxeq	lr
 80004c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80004ca:	bf04      	itt	eq
 80004cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80004d0:	4770      	bxeq	lr
 80004d2:	b530      	push	{r4, r5, lr}
 80004d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80004e0:	e71c      	b.n	800031c <__adddf3+0x138>
 80004e2:	bf00      	nop

080004e4 <__aeabi_ul2d>:
 80004e4:	ea50 0201 	orrs.w	r2, r0, r1
 80004e8:	bf08      	it	eq
 80004ea:	4770      	bxeq	lr
 80004ec:	b530      	push	{r4, r5, lr}
 80004ee:	f04f 0500 	mov.w	r5, #0
 80004f2:	e00a      	b.n	800050a <__aeabi_l2d+0x16>

080004f4 <__aeabi_l2d>:
 80004f4:	ea50 0201 	orrs.w	r2, r0, r1
 80004f8:	bf08      	it	eq
 80004fa:	4770      	bxeq	lr
 80004fc:	b530      	push	{r4, r5, lr}
 80004fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000502:	d502      	bpl.n	800050a <__aeabi_l2d+0x16>
 8000504:	4240      	negs	r0, r0
 8000506:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800050a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800050e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000512:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000516:	f43f aed8 	beq.w	80002ca <__adddf3+0xe6>
 800051a:	f04f 0203 	mov.w	r2, #3
 800051e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000522:	bf18      	it	ne
 8000524:	3203      	addne	r2, #3
 8000526:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800052a:	bf18      	it	ne
 800052c:	3203      	addne	r2, #3
 800052e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000532:	f1c2 0320 	rsb	r3, r2, #32
 8000536:	fa00 fc03 	lsl.w	ip, r0, r3
 800053a:	fa20 f002 	lsr.w	r0, r0, r2
 800053e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000542:	ea40 000e 	orr.w	r0, r0, lr
 8000546:	fa21 f102 	lsr.w	r1, r1, r2
 800054a:	4414      	add	r4, r2
 800054c:	e6bd      	b.n	80002ca <__adddf3+0xe6>
 800054e:	bf00      	nop

08000550 <__aeabi_dmul>:
 8000550:	b570      	push	{r4, r5, r6, lr}
 8000552:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000556:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 800055a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800055e:	bf1d      	ittte	ne
 8000560:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000564:	ea94 0f0c 	teqne	r4, ip
 8000568:	ea95 0f0c 	teqne	r5, ip
 800056c:	f000 f8de 	bleq	800072c <__aeabi_dmul+0x1dc>
 8000570:	442c      	add	r4, r5
 8000572:	ea81 0603 	eor.w	r6, r1, r3
 8000576:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800057a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800057e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000582:	bf18      	it	ne
 8000584:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000588:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 800058c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000590:	d038      	beq.n	8000604 <__aeabi_dmul+0xb4>
 8000592:	fba0 ce02 	umull	ip, lr, r0, r2
 8000596:	f04f 0500 	mov.w	r5, #0
 800059a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800059e:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 80005a2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005a6:	f04f 0600 	mov.w	r6, #0
 80005aa:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ae:	f09c 0f00 	teq	ip, #0
 80005b2:	bf18      	it	ne
 80005b4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005b8:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 80005bc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 80005c0:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 80005c4:	d204      	bcs.n	80005d0 <__aeabi_dmul+0x80>
 80005c6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ca:	416d      	adcs	r5, r5
 80005cc:	eb46 0606 	adc.w	r6, r6, r6
 80005d0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005d4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005d8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005dc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80005e0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80005e4:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80005e8:	bf88      	it	hi
 80005ea:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80005ee:	d81e      	bhi.n	800062e <__aeabi_dmul+0xde>
 80005f0:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80005f4:	bf08      	it	eq
 80005f6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80005fa:	f150 0000 	adcs.w	r0, r0, #0
 80005fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000602:	bd70      	pop	{r4, r5, r6, pc}
 8000604:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8000608:	ea46 0101 	orr.w	r1, r6, r1
 800060c:	ea40 0002 	orr.w	r0, r0, r2
 8000610:	ea81 0103 	eor.w	r1, r1, r3
 8000614:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000618:	bfc2      	ittt	gt
 800061a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800061e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000622:	bd70      	popgt	{r4, r5, r6, pc}
 8000624:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000628:	f04f 0e00 	mov.w	lr, #0
 800062c:	3c01      	subs	r4, #1
 800062e:	f300 80ab 	bgt.w	8000788 <__aeabi_dmul+0x238>
 8000632:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 8000636:	bfde      	ittt	le
 8000638:	2000      	movle	r0, #0
 800063a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 800063e:	bd70      	pople	{r4, r5, r6, pc}
 8000640:	f1c4 0400 	rsb	r4, r4, #0
 8000644:	3c20      	subs	r4, #32
 8000646:	da35      	bge.n	80006b4 <__aeabi_dmul+0x164>
 8000648:	340c      	adds	r4, #12
 800064a:	dc1b      	bgt.n	8000684 <__aeabi_dmul+0x134>
 800064c:	f104 0414 	add.w	r4, r4, #20
 8000650:	f1c4 0520 	rsb	r5, r4, #32
 8000654:	fa00 f305 	lsl.w	r3, r0, r5
 8000658:	fa20 f004 	lsr.w	r0, r0, r4
 800065c:	fa01 f205 	lsl.w	r2, r1, r5
 8000660:	ea40 0002 	orr.w	r0, r0, r2
 8000664:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000668:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800066c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000670:	fa21 f604 	lsr.w	r6, r1, r4
 8000674:	eb42 0106 	adc.w	r1, r2, r6
 8000678:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800067c:	bf08      	it	eq
 800067e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f1c4 040c 	rsb	r4, r4, #12
 8000688:	f1c4 0520 	rsb	r5, r4, #32
 800068c:	fa00 f304 	lsl.w	r3, r0, r4
 8000690:	fa20 f005 	lsr.w	r0, r0, r5
 8000694:	fa01 f204 	lsl.w	r2, r1, r4
 8000698:	ea40 0002 	orr.w	r0, r0, r2
 800069c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006a0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006a4:	f141 0100 	adc.w	r1, r1, #0
 80006a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006ac:	bf08      	it	eq
 80006ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006b2:	bd70      	pop	{r4, r5, r6, pc}
 80006b4:	f1c4 0520 	rsb	r5, r4, #32
 80006b8:	fa00 f205 	lsl.w	r2, r0, r5
 80006bc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006c0:	fa20 f304 	lsr.w	r3, r0, r4
 80006c4:	fa01 f205 	lsl.w	r2, r1, r5
 80006c8:	ea43 0302 	orr.w	r3, r3, r2
 80006cc:	fa21 f004 	lsr.w	r0, r1, r4
 80006d0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006d4:	fa21 f204 	lsr.w	r2, r1, r4
 80006d8:	ea20 0002 	bic.w	r0, r0, r2
 80006dc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80006e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006e4:	bf08      	it	eq
 80006e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f094 0f00 	teq	r4, #0
 80006f0:	d10f      	bne.n	8000712 <__aeabi_dmul+0x1c2>
 80006f2:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80006f6:	0040      	lsls	r0, r0, #1
 80006f8:	eb41 0101 	adc.w	r1, r1, r1
 80006fc:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000700:	bf08      	it	eq
 8000702:	3c01      	subeq	r4, #1
 8000704:	d0f7      	beq.n	80006f6 <__aeabi_dmul+0x1a6>
 8000706:	ea41 0106 	orr.w	r1, r1, r6
 800070a:	f095 0f00 	teq	r5, #0
 800070e:	bf18      	it	ne
 8000710:	4770      	bxne	lr
 8000712:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 8000716:	0052      	lsls	r2, r2, #1
 8000718:	eb43 0303 	adc.w	r3, r3, r3
 800071c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8000720:	bf08      	it	eq
 8000722:	3d01      	subeq	r5, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1c6>
 8000726:	ea43 0306 	orr.w	r3, r3, r6
 800072a:	4770      	bx	lr
 800072c:	ea94 0f0c 	teq	r4, ip
 8000730:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000734:	bf18      	it	ne
 8000736:	ea95 0f0c 	teqne	r5, ip
 800073a:	d00c      	beq.n	8000756 <__aeabi_dmul+0x206>
 800073c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000740:	bf18      	it	ne
 8000742:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000746:	d1d1      	bne.n	80006ec <__aeabi_dmul+0x19c>
 8000748:	ea81 0103 	eor.w	r1, r1, r3
 800074c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000750:	f04f 0000 	mov.w	r0, #0
 8000754:	bd70      	pop	{r4, r5, r6, pc}
 8000756:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800075a:	bf06      	itte	eq
 800075c:	4610      	moveq	r0, r2
 800075e:	4619      	moveq	r1, r3
 8000760:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000764:	d019      	beq.n	800079a <__aeabi_dmul+0x24a>
 8000766:	ea94 0f0c 	teq	r4, ip
 800076a:	d102      	bne.n	8000772 <__aeabi_dmul+0x222>
 800076c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000770:	d113      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000772:	ea95 0f0c 	teq	r5, ip
 8000776:	d105      	bne.n	8000784 <__aeabi_dmul+0x234>
 8000778:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800077c:	bf1c      	itt	ne
 800077e:	4610      	movne	r0, r2
 8000780:	4619      	movne	r1, r3
 8000782:	d10a      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000784:	ea81 0103 	eor.w	r1, r1, r3
 8000788:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800078c:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000790:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000794:	f04f 0000 	mov.w	r0, #0
 8000798:	bd70      	pop	{r4, r5, r6, pc}
 800079a:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 800079e:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 80007a2:	bd70      	pop	{r4, r5, r6, pc}

080007a4 <__aeabi_ddiv>:
 80007a4:	b570      	push	{r4, r5, r6, lr}
 80007a6:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80007aa:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80007ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007b2:	bf1d      	ittte	ne
 80007b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007b8:	ea94 0f0c 	teqne	r4, ip
 80007bc:	ea95 0f0c 	teqne	r5, ip
 80007c0:	f000 f8a7 	bleq	8000912 <__aeabi_ddiv+0x16e>
 80007c4:	eba4 0405 	sub.w	r4, r4, r5
 80007c8:	ea81 0e03 	eor.w	lr, r1, r3
 80007cc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007d4:	f000 8088 	beq.w	80008e8 <__aeabi_ddiv+0x144>
 80007d8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007dc:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 80007e0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80007e4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80007e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80007ec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80007f0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80007f4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80007f8:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80007fc:	429d      	cmp	r5, r3
 80007fe:	bf08      	it	eq
 8000800:	4296      	cmpeq	r6, r2
 8000802:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 8000806:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 800080a:	d202      	bcs.n	8000812 <__aeabi_ddiv+0x6e>
 800080c:	085b      	lsrs	r3, r3, #1
 800080e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000812:	1ab6      	subs	r6, r6, r2
 8000814:	eb65 0503 	sbc.w	r5, r5, r3
 8000818:	085b      	lsrs	r3, r3, #1
 800081a:	ea4f 0232 	mov.w	r2, r2, rrx
 800081e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8000822:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 8000826:	ebb6 0e02 	subs.w	lr, r6, r2
 800082a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800082e:	bf22      	ittt	cs
 8000830:	1ab6      	subcs	r6, r6, r2
 8000832:	4675      	movcs	r5, lr
 8000834:	ea40 000c 	orrcs.w	r0, r0, ip
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000842:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000846:	bf22      	ittt	cs
 8000848:	1ab6      	subcs	r6, r6, r2
 800084a:	4675      	movcs	r5, lr
 800084c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000850:	085b      	lsrs	r3, r3, #1
 8000852:	ea4f 0232 	mov.w	r2, r2, rrx
 8000856:	ebb6 0e02 	subs.w	lr, r6, r2
 800085a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800085e:	bf22      	ittt	cs
 8000860:	1ab6      	subcs	r6, r6, r2
 8000862:	4675      	movcs	r5, lr
 8000864:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000868:	085b      	lsrs	r3, r3, #1
 800086a:	ea4f 0232 	mov.w	r2, r2, rrx
 800086e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000872:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000876:	bf22      	ittt	cs
 8000878:	1ab6      	subcs	r6, r6, r2
 800087a:	4675      	movcs	r5, lr
 800087c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000880:	ea55 0e06 	orrs.w	lr, r5, r6
 8000884:	d018      	beq.n	80008b8 <__aeabi_ddiv+0x114>
 8000886:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800088a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800088e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000892:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000896:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800089a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800089e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008a2:	d1c0      	bne.n	8000826 <__aeabi_ddiv+0x82>
 80008a4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008a8:	d10b      	bne.n	80008c2 <__aeabi_ddiv+0x11e>
 80008aa:	ea41 0100 	orr.w	r1, r1, r0
 80008ae:	f04f 0000 	mov.w	r0, #0
 80008b2:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 80008b6:	e7b6      	b.n	8000826 <__aeabi_ddiv+0x82>
 80008b8:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008bc:	bf04      	itt	eq
 80008be:	4301      	orreq	r1, r0
 80008c0:	2000      	moveq	r0, #0
 80008c2:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80008c6:	bf88      	it	hi
 80008c8:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80008cc:	f63f aeaf 	bhi.w	800062e <__aeabi_dmul+0xde>
 80008d0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008d4:	bf04      	itt	eq
 80008d6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008de:	f150 0000 	adcs.w	r0, r0, #0
 80008e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80008e6:	bd70      	pop	{r4, r5, r6, pc}
 80008e8:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 80008ec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80008f0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80008f4:	bfc2      	ittt	gt
 80008f6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80008fa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80008fe:	bd70      	popgt	{r4, r5, r6, pc}
 8000900:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000904:	f04f 0e00 	mov.w	lr, #0
 8000908:	3c01      	subs	r4, #1
 800090a:	e690      	b.n	800062e <__aeabi_dmul+0xde>
 800090c:	ea45 0e06 	orr.w	lr, r5, r6
 8000910:	e68d      	b.n	800062e <__aeabi_dmul+0xde>
 8000912:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000916:	ea94 0f0c 	teq	r4, ip
 800091a:	bf08      	it	eq
 800091c:	ea95 0f0c 	teqeq	r5, ip
 8000920:	f43f af3b 	beq.w	800079a <__aeabi_dmul+0x24a>
 8000924:	ea94 0f0c 	teq	r4, ip
 8000928:	d10a      	bne.n	8000940 <__aeabi_ddiv+0x19c>
 800092a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800092e:	f47f af34 	bne.w	800079a <__aeabi_dmul+0x24a>
 8000932:	ea95 0f0c 	teq	r5, ip
 8000936:	f47f af25 	bne.w	8000784 <__aeabi_dmul+0x234>
 800093a:	4610      	mov	r0, r2
 800093c:	4619      	mov	r1, r3
 800093e:	e72c      	b.n	800079a <__aeabi_dmul+0x24a>
 8000940:	ea95 0f0c 	teq	r5, ip
 8000944:	d106      	bne.n	8000954 <__aeabi_ddiv+0x1b0>
 8000946:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800094a:	f43f aefd 	beq.w	8000748 <__aeabi_dmul+0x1f8>
 800094e:	4610      	mov	r0, r2
 8000950:	4619      	mov	r1, r3
 8000952:	e722      	b.n	800079a <__aeabi_dmul+0x24a>
 8000954:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000958:	bf18      	it	ne
 800095a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800095e:	f47f aec5 	bne.w	80006ec <__aeabi_dmul+0x19c>
 8000962:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000966:	f47f af0d 	bne.w	8000784 <__aeabi_dmul+0x234>
 800096a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800096e:	f47f aeeb 	bne.w	8000748 <__aeabi_dmul+0x1f8>
 8000972:	e712      	b.n	800079a <__aeabi_dmul+0x24a>

08000974 <__gedf2>:
 8000974:	f04f 3cff 	mov.w	ip, #4294967295
 8000978:	e006      	b.n	8000988 <__cmpdf2+0x4>
 800097a:	bf00      	nop

0800097c <__ledf2>:
 800097c:	f04f 0c01 	mov.w	ip, #1
 8000980:	e002      	b.n	8000988 <__cmpdf2+0x4>
 8000982:	bf00      	nop

08000984 <__cmpdf2>:
 8000984:	f04f 0c01 	mov.w	ip, #1
 8000988:	f84d cd04 	str.w	ip, [sp, #-4]!
 800098c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000990:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000994:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000998:	bf18      	it	ne
 800099a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800099e:	d01b      	beq.n	80009d8 <__cmpdf2+0x54>
 80009a0:	b001      	add	sp, #4
 80009a2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80009a6:	bf0c      	ite	eq
 80009a8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80009ac:	ea91 0f03 	teqne	r1, r3
 80009b0:	bf02      	ittt	eq
 80009b2:	ea90 0f02 	teqeq	r0, r2
 80009b6:	2000      	moveq	r0, #0
 80009b8:	4770      	bxeq	lr
 80009ba:	f110 0f00 	cmn.w	r0, #0
 80009be:	ea91 0f03 	teq	r1, r3
 80009c2:	bf58      	it	pl
 80009c4:	4299      	cmppl	r1, r3
 80009c6:	bf08      	it	eq
 80009c8:	4290      	cmpeq	r0, r2
 80009ca:	bf2c      	ite	cs
 80009cc:	17d8      	asrcs	r0, r3, #31
 80009ce:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80009d2:	f040 0001 	orr.w	r0, r0, #1
 80009d6:	4770      	bx	lr
 80009d8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80009dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009e0:	d102      	bne.n	80009e8 <__cmpdf2+0x64>
 80009e2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80009e6:	d107      	bne.n	80009f8 <__cmpdf2+0x74>
 80009e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80009ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009f0:	d1d6      	bne.n	80009a0 <__cmpdf2+0x1c>
 80009f2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80009f6:	d0d3      	beq.n	80009a0 <__cmpdf2+0x1c>
 80009f8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <__aeabi_cdrcmple>:
 8000a00:	4684      	mov	ip, r0
 8000a02:	4610      	mov	r0, r2
 8000a04:	4662      	mov	r2, ip
 8000a06:	468c      	mov	ip, r1
 8000a08:	4619      	mov	r1, r3
 8000a0a:	4663      	mov	r3, ip
 8000a0c:	e000      	b.n	8000a10 <__aeabi_cdcmpeq>
 8000a0e:	bf00      	nop

08000a10 <__aeabi_cdcmpeq>:
 8000a10:	b501      	push	{r0, lr}
 8000a12:	f7ff ffb7 	bl	8000984 <__cmpdf2>
 8000a16:	2800      	cmp	r0, #0
 8000a18:	bf48      	it	mi
 8000a1a:	f110 0f00 	cmnmi.w	r0, #0
 8000a1e:	bd01      	pop	{r0, pc}

08000a20 <__aeabi_dcmpeq>:
 8000a20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a24:	f7ff fff4 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a28:	bf0c      	ite	eq
 8000a2a:	2001      	moveq	r0, #1
 8000a2c:	2000      	movne	r0, #0
 8000a2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a32:	bf00      	nop

08000a34 <__aeabi_dcmplt>:
 8000a34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a38:	f7ff ffea 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a3c:	bf34      	ite	cc
 8000a3e:	2001      	movcc	r0, #1
 8000a40:	2000      	movcs	r0, #0
 8000a42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a46:	bf00      	nop

08000a48 <__aeabi_dcmple>:
 8000a48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a4c:	f7ff ffe0 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a50:	bf94      	ite	ls
 8000a52:	2001      	movls	r0, #1
 8000a54:	2000      	movhi	r0, #0
 8000a56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a5a:	bf00      	nop

08000a5c <__aeabi_dcmpge>:
 8000a5c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a60:	f7ff ffce 	bl	8000a00 <__aeabi_cdrcmple>
 8000a64:	bf94      	ite	ls
 8000a66:	2001      	movls	r0, #1
 8000a68:	2000      	movhi	r0, #0
 8000a6a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dcmpgt>:
 8000a70:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a74:	f7ff ffc4 	bl	8000a00 <__aeabi_cdrcmple>
 8000a78:	bf34      	ite	cc
 8000a7a:	2001      	movcc	r0, #1
 8000a7c:	2000      	movcs	r0, #0
 8000a7e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a82:	bf00      	nop

08000a84 <__aeabi_d2f>:
 8000a84:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a88:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000a8c:	bf24      	itt	cs
 8000a8e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000a92:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000a96:	d90d      	bls.n	8000ab4 <__aeabi_d2f+0x30>
 8000a98:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000a9c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000aa0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000aa4:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000aa8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000aac:	bf08      	it	eq
 8000aae:	f020 0001 	biceq.w	r0, r0, #1
 8000ab2:	4770      	bx	lr
 8000ab4:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000ab8:	d121      	bne.n	8000afe <__aeabi_d2f+0x7a>
 8000aba:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000abe:	bfbc      	itt	lt
 8000ac0:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000ac4:	4770      	bxlt	lr
 8000ac6:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000aca:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000ace:	f1c2 0218 	rsb	r2, r2, #24
 8000ad2:	f1c2 0c20 	rsb	ip, r2, #32
 8000ad6:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ada:	fa20 f002 	lsr.w	r0, r0, r2
 8000ade:	bf18      	it	ne
 8000ae0:	f040 0001 	orrne.w	r0, r0, #1
 8000ae4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ae8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000aec:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000af0:	ea40 000c 	orr.w	r0, r0, ip
 8000af4:	fa23 f302 	lsr.w	r3, r3, r2
 8000af8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000afc:	e7cc      	b.n	8000a98 <__aeabi_d2f+0x14>
 8000afe:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b02:	d107      	bne.n	8000b14 <__aeabi_d2f+0x90>
 8000b04:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b08:	bf1e      	ittt	ne
 8000b0a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000b0e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000b12:	4770      	bxne	lr
 8000b14:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000b18:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000b1c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000b20:	4770      	bx	lr
 8000b22:	bf00      	nop

08000b24 <sysclock_init>:
}

void sysclock_init(void)
{
	// 16 MHz HSI oscillator is default on reset, but select anyways
	RCC->CR |= RCC_CR_HSION;
 8000b24:	4a1b      	ldr	r2, [pc, #108]	@ (8000b94 <sysclock_init+0x70>)
 8000b26:	6813      	ldr	r3, [r2, #0]
 8000b28:	f043 0301 	orr.w	r3, r3, #1
{
 8000b2c:	b410      	push	{r4}
	RCC->CR |= RCC_CR_HSION;
 8000b2e:	6013      	str	r3, [r2, #0]
	// wait for HSI to be ready
	while (!((RCC->CR) & RCC_CR_HSIRDY));
 8000b30:	6813      	ldr	r3, [r2, #0]
 8000b32:	0799      	lsls	r1, r3, #30
 8000b34:	d5fc      	bpl.n	8000b30 <sysclock_init+0xc>

	// enable power interface clock for APB1
	RCC->APB1ENR = RCC_APB1ENR_PWREN;

	// configure VCO to scale 2 per CubeMX
	PWR->CR |= PWR_CR_VOS_1;
 8000b36:	4b18      	ldr	r3, [pc, #96]	@ (8000b98 <sysclock_init+0x74>)
	// configure FLASH
	// instruction cache, prefetch enable, and data cache enabled
	uint32_t flash;
	flash = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN;
	flash |= 2;		// 2 wait states for flash
	FLASH->ACR = flash;
 8000b38:	4818      	ldr	r0, [pc, #96]	@ (8000b9c <sysclock_init+0x78>)
	RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000b3a:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
 8000b3e:	6411      	str	r1, [r2, #64]	@ 0x40
	PWR->CR |= PWR_CR_VOS_1;
 8000b40:	6819      	ldr	r1, [r3, #0]
 8000b42:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 8000b46:	6019      	str	r1, [r3, #0]
	PWR->CR &= ~PWR_CR_VOS_0;
 8000b48:	6819      	ldr	r1, [r3, #0]
 8000b4a:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
 8000b4e:	6019      	str	r1, [r3, #0]
	FLASH->ACR = flash;
 8000b50:	f240 7402 	movw	r4, #1794	@ 0x702
	// configure bus prescalers
	uint32_t cfgr = 0;
	cfgr &= ~RCC_CFGR_PPRE2_2;		// APB2 prescaler of 1 (84MHz)
	cfgr |= RCC_CFGR_PPRE1_2;		// APB1 prescaler of 2 (42MHZ)
	cfgr &= ~RCC_CFGR_HPRE;			// AHB prescaler of 1 (84MHz)
	RCC->CFGR = cfgr;
 8000b54:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
	FLASH->ACR = flash;
 8000b58:	6004      	str	r4, [r0, #0]
	RCC->CFGR = cfgr;
 8000b5a:	6093      	str	r3, [r2, #8]

	// configure main PLL
	uint32_t pll_cfg = RCC->PLLCFGR;
 8000b5c:	6851      	ldr	r1, [r2, #4]
	pll_cfg &= ~RCC_PLLCFGR_PLLP;	// main PLL division factor of 2

	pll_cfg &= ~RCC_PLLCFGR_PLLN;
	pll_cfg |= 168UL << 6;	// pll multiplication factor for VCO (x168)

	pll_cfg &= ~RCC_PLLCFGR_PLLM;
 8000b5e:	4810      	ldr	r0, [pc, #64]	@ (8000ba0 <sysclock_init+0x7c>)
	pll_cfg |= 16UL << 0;	// pll division factor for main PLL and audio PLL (/16)
 8000b60:	4b10      	ldr	r3, [pc, #64]	@ (8000ba4 <sysclock_init+0x80>)
 8000b62:	4001      	ands	r1, r0
 8000b64:	430b      	orrs	r3, r1

	RCC->PLLCFGR = pll_cfg;
 8000b66:	6053      	str	r3, [r2, #4]

	// enable PLL and wait for ready
	RCC->CR |= RCC_CR_PLLON;
 8000b68:	6813      	ldr	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b6a:	490a      	ldr	r1, [pc, #40]	@ (8000b94 <sysclock_init+0x70>)
	RCC->CR |= RCC_CR_PLLON;
 8000b6c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8000b70:	6013      	str	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b72:	680b      	ldr	r3, [r1, #0]
 8000b74:	019a      	lsls	r2, r3, #6
 8000b76:	d5fc      	bpl.n	8000b72 <sysclock_init+0x4e>

	// select clock source
	cfgr = RCC->CFGR;
 8000b78:	688b      	ldr	r3, [r1, #8]
	cfgr |= RCC_CFGR_SW_1;		// select PLL as system clock
	cfgr &= ~RCC_CFGR_SW_0;
	RCC->CFGR = cfgr;

	// wait for PLL clock source to become active
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b7a:	4a06      	ldr	r2, [pc, #24]	@ (8000b94 <sysclock_init+0x70>)
 8000b7c:	f023 0301 	bic.w	r3, r3, #1
	cfgr &= ~RCC_CFGR_SW_0;
 8000b80:	f043 0302 	orr.w	r3, r3, #2
	RCC->CFGR = cfgr;
 8000b84:	608b      	str	r3, [r1, #8]
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b86:	6893      	ldr	r3, [r2, #8]
 8000b88:	071b      	lsls	r3, r3, #28
 8000b8a:	d5fc      	bpl.n	8000b86 <sysclock_init+0x62>
}
 8000b8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop
 8000b94:	40023800 	.word	0x40023800
 8000b98:	40007000 	.word	0x40007000
 8000b9c:	40023c00 	.word	0x40023c00
 8000ba0:	f0fc8000 	.word	0xf0fc8000
 8000ba4:	04002a10 	.word	0x04002a10

08000ba8 <spi1_dma2_init>:

void spi1_dma2_init(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000ba8:	495b      	ldr	r1, [pc, #364]	@ (8000d18 <spi1_dma2_init+0x170>)
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock

	// PA4 is SPI1_NSS (select alternate function)
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000baa:	4b5c      	ldr	r3, [pc, #368]	@ (8000d1c <spi1_dma2_init+0x174>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bac:	6c48      	ldr	r0, [r1, #68]	@ 0x44

	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);

	// initialize SPI slave
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000bae:	4a5c      	ldr	r2, [pc, #368]	@ (8000d20 <spi1_dma2_init+0x178>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb0:	f440 5080 	orr.w	r0, r0, #4096	@ 0x1000
{
 8000bb4:	b410      	push	{r4}
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb6:	6448      	str	r0, [r1, #68]	@ 0x44
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock
 8000bb8:	6b08      	ldr	r0, [r1, #48]	@ 0x30
 8000bba:	f040 0001 	orr.w	r0, r0, #1
 8000bbe:	6308      	str	r0, [r1, #48]	@ 0x30
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000bc0:	6818      	ldr	r0, [r3, #0]
 8000bc2:	f440 7000 	orr.w	r0, r0, #512	@ 0x200
 8000bc6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER4_0;
 8000bc8:	6818      	ldr	r0, [r3, #0]
 8000bca:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
 8000bce:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER5_1;
 8000bd0:	6818      	ldr	r0, [r3, #0]
 8000bd2:	f440 6000 	orr.w	r0, r0, #2048	@ 0x800
 8000bd6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER5_0;
 8000bd8:	6818      	ldr	r0, [r3, #0]
 8000bda:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
 8000bde:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER7_1;
 8000be0:	6818      	ldr	r0, [r3, #0]
 8000be2:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
 8000be6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER7_0;
 8000be8:	6818      	ldr	r0, [r3, #0]
 8000bea:	f420 4080 	bic.w	r0, r0, #16384	@ 0x4000
 8000bee:	6018      	str	r0, [r3, #0]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL4_0 | GPIO_AFRL_AFRL4_2;
 8000bf0:	6a18      	ldr	r0, [r3, #32]
 8000bf2:	f440 20a0 	orr.w	r0, r0, #327680	@ 0x50000
 8000bf6:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_3);
 8000bf8:	6a18      	ldr	r0, [r3, #32]
 8000bfa:	f420 2020 	bic.w	r0, r0, #655360	@ 0xa0000
 8000bfe:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL5_0 | GPIO_AFRL_AFRL5_2;
 8000c00:	6a18      	ldr	r0, [r3, #32]
 8000c02:	f440 00a0 	orr.w	r0, r0, #5242880	@ 0x500000
 8000c06:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL5_1 | GPIO_AFRL_AFRL5_3);
 8000c08:	6a18      	ldr	r0, [r3, #32]
 8000c0a:	f420 0020 	bic.w	r0, r0, #10485760	@ 0xa00000
 8000c0e:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
 8000c10:	6a18      	ldr	r0, [r3, #32]
 8000c12:	f040 40a0 	orr.w	r0, r0, #1342177280	@ 0x50000000
 8000c16:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);
 8000c18:	6a18      	ldr	r0, [r3, #32]
 8000c1a:	f020 4020 	bic.w	r0, r0, #2684354560	@ 0xa0000000
 8000c1e:	6218      	str	r0, [r3, #32]
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000c20:	6810      	ldr	r0, [r2, #0]
 8000c22:	f440 6040 	orr.w	r0, r0, #3072	@ 0xc00
 8000c26:	6010      	str	r0, [r2, #0]
	SPI1->CR1 &= ~(SPI_CR1_LSBFIRST | SPI_CR1_SSM | 	// MSb first, disable software slave management
 8000c28:	6810      	ldr	r0, [r2, #0]
 8000c2a:	f420 4002 	bic.w	r0, r0, #33280	@ 0x8200
 8000c2e:	f020 00c7 	bic.w	r0, r0, #199	@ 0xc7
 8000c32:	6010      	str	r0, [r2, #0]
					SPI_CR1_SPE | SPI_CR1_MSTR | 		// disable SPI, slave mode
					SPI_CR1_BIDIMODE |					// not using bidirectional mode
					SPI_CR1_CPOL | SPI_CR1_CPHA);		// SPI mode = [0, 0]

	SPI1->CR2 &= ~(SPI_CR2_SSOE | SPI_CR2_FRF);			// disable slave select output and select Motorola mode
 8000c34:	6850      	ldr	r0, [r2, #4]
 8000c36:	f020 0014 	bic.w	r0, r0, #20
 8000c3a:	6050      	str	r0, [r2, #4]
	SPI1->CR2 |= SPI_CR2_RXDMAEN;						// enable DMA requests when data is received
 8000c3c:	6850      	ldr	r0, [r2, #4]
 8000c3e:	f040 0001 	orr.w	r0, r0, #1
 8000c42:	6050      	str	r0, [r2, #4]


	/* DMA2 Channel 3, Stream 0 --> SPI1 RX */
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c44:	6b0a      	ldr	r2, [r1, #48]	@ 0x30

	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c46:	f503 43c8 	add.w	r3, r3, #25600	@ 0x6400
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c4a:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8000c4e:	630a      	str	r2, [r1, #48]	@ 0x30
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c50:	691a      	ldr	r2, [r3, #16]
 8000c52:	f022 0201 	bic.w	r2, r2, #1
 8000c56:	611a      	str	r2, [r3, #16]
	while (DMA2_Stream0->CR & DMA_SxCR_EN);	// wait for stream to disable
 8000c58:	691a      	ldr	r2, [r3, #16]
 8000c5a:	07d2      	lsls	r2, r2, #31
 8000c5c:	d4fc      	bmi.n	8000c58 <spi1_dma2_init+0xb0>

	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c5e:	4c31      	ldr	r4, [pc, #196]	@ (8000d24 <spi1_dma2_init+0x17c>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c60:	4931      	ldr	r1, [pc, #196]	@ (8000d28 <spi1_dma2_init+0x180>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c62:	4832      	ldr	r0, [pc, #200]	@ (8000d2c <spi1_dma2_init+0x184>)
	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c64:	619c      	str	r4, [r3, #24]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c66:	f44f 62b4 	mov.w	r2, #1440	@ 0x5a0
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c6a:	61d8      	str	r0, [r3, #28]
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c6c:	6219      	str	r1, [r3, #32]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c6e:	615a      	str	r2, [r3, #20]

	// select channel 3 for SPI1 RX
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c70:	691a      	ldr	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;


	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream

	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000c72:	492b      	ldr	r1, [pc, #172]	@ (8000d20 <spi1_dma2_init+0x178>)
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c74:	f022 6260 	bic.w	r2, r2, #234881024	@ 0xe000000
 8000c78:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CHSEL_0 | DMA_SxCR_CHSEL_1;
 8000c7a:	691a      	ldr	r2, [r3, #16]
 8000c7c:	f042 62c0 	orr.w	r2, r2, #100663296	@ 0x6000000
 8000c80:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PFCTRL;	// DMA is the flow controller
 8000c82:	691a      	ldr	r2, [r3, #16]
 8000c84:	f022 0220 	bic.w	r2, r2, #32
 8000c88:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PL_0;
 8000c8a:	691a      	ldr	r2, [r3, #16]
 8000c8c:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8000c90:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PL_1;
 8000c92:	691a      	ldr	r2, [r3, #16]
 8000c94:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8000c98:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->FCR |= DMA_SxFCR_DMDIS;
 8000c9a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000c9c:	f042 0204 	orr.w	r2, r2, #4
 8000ca0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR |= DMA_SxFCR_FTH_0;
 8000ca2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000ca4:	f042 0201 	orr.w	r2, r2, #1
 8000ca8:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR &= ~DMA_SxFCR_FTH_1;
 8000caa:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000cac:	f022 0202 	bic.w	r2, r2, #2
 8000cb0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->CR |= DMA_SxCR_MSIZE_0;
 8000cb2:	691a      	ldr	r2, [r3, #16]
 8000cb4:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8000cb8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_MSIZE_1;
 8000cba:	691a      	ldr	r2, [r3, #16]
 8000cbc:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8000cc0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PSIZE_0;
 8000cc2:	691a      	ldr	r2, [r3, #16]
 8000cc4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8000cc8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PSIZE_1;
 8000cca:	691a      	ldr	r2, [r3, #16]
 8000ccc:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8000cd0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_MINC;
 8000cd2:	691a      	ldr	r2, [r3, #16]
 8000cd4:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8000cd8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PINC;
 8000cda:	691a      	ldr	r2, [r3, #16]
 8000cdc:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8000ce0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce2:	691a      	ldr	r2, [r3, #16]
}
 8000ce4:	f85d 4b04 	ldr.w	r4, [sp], #4
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce8:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8000cec:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CIRC;
 8000cee:	691a      	ldr	r2, [r3, #16]
 8000cf0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8000cf4:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_DBM;
 8000cf6:	691a      	ldr	r2, [r3, #16]
 8000cf8:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8000cfc:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;
 8000cfe:	691a      	ldr	r2, [r3, #16]
 8000d00:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 8000d04:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream
 8000d06:	691a      	ldr	r2, [r3, #16]
 8000d08:	f042 0201 	orr.w	r2, r2, #1
 8000d0c:	611a      	str	r2, [r3, #16]
	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000d0e:	680b      	ldr	r3, [r1, #0]
 8000d10:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8000d14:	600b      	str	r3, [r1, #0]
}
 8000d16:	4770      	bx	lr
 8000d18:	40023800 	.word	0x40023800
 8000d1c:	40020000 	.word	0x40020000
 8000d20:	40013000 	.word	0x40013000
 8000d24:	4001300c 	.word	0x4001300c
 8000d28:	20000024 	.word	0x20000024
 8000d2c:	20000b64 	.word	0x20000b64

08000d30 <compute_event_pos>:
		}
	}
}

uint8_t compute_event_pos(float32_t * x, float32_t * y, struct MicCoord * mics_xy, float32_t mic1_delay, float32_t mic2_delay)
{
 8000d30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	const float32_t max_step = 0.2f;			// maximum dx/dy change per iteration in meters

	// distances from mic1 and mic2 to mic0
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000d34:	eddf 7a90 	vldr	s15, [pc, #576]	@ 8000f78 <compute_event_pos+0x248>
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;

	float32_t lambda = 1e-3f;

	float32_t old_res1 = 0, old_res2 = 0;
 8000d38:	eddf 4a90 	vldr	s9, [pc, #576]	@ 8000f7c <compute_event_pos+0x24c>
{
 8000d3c:	ed2d 8b0e 	vpush	{d8-d14}
		*y += dy;

		old_res1 = res1;
		old_res2 = res2;

		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000d40:	a78b      	add	r7, pc, #556	@ (adr r7, 8000f70 <compute_event_pos+0x240>)
 8000d42:	e9d7 6700 	ldrd	r6, r7, [r7]
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000d46:	ee60 8a27 	vmul.f32	s17, s0, s15
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;
 8000d4a:	ee20 8aa7 	vmul.f32	s16, s1, s15
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000d4e:	edd1 ba00 	vldr	s23, [r1]
	float32_t lambda = 1e-3f;
 8000d52:	ed9f da8b 	vldr	s26, [pc, #556]	@ 8000f80 <compute_event_pos+0x250>
		if (cost < 1e-8f)	return 1;
 8000d56:	ed9f 9a8b 	vldr	s18, [pc, #556]	@ 8000f84 <compute_event_pos+0x254>
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8000d5a:	eddf aa8b 	vldr	s21, [pc, #556]	@ 8000f88 <compute_event_pos+0x258>
		if (fabsf(det) < 1e-12f)
 8000d5e:	eddf 9a8b 	vldr	s19, [pc, #556]	@ 8000f8c <compute_event_pos+0x25c>
float32_t clamp(float32_t in, float32_t abs_max)
{
	// clamp in between [-abs_max, abs_max]
	if (in > abs_max)
		return abs_max;
	else if (in < -abs_max)
 8000d62:	ed9f ea8b 	vldr	s28, [pc, #556]	@ 8000f90 <compute_event_pos+0x260>
 8000d66:	eddf da8b 	vldr	s27, [pc, #556]	@ 8000f94 <compute_event_pos+0x264>
{
 8000d6a:	4689      	mov	r9, r1
	float32_t old_res1 = 0, old_res2 = 0;
 8000d6c:	eeb0 4a64 	vmov.f32	s8, s9
{
 8000d70:	4680      	mov	r8, r0
 8000d72:	4614      	mov	r4, r2
		else						lambda *= 5.0f;			// punish bad step
 8000d74:	eeb1 aa04 	vmov.f32	s20, #20	@ 0x40a00000  5.0
			lambda *= 10.0f;
 8000d78:	eeb2 ba04 	vmov.f32	s22, #36	@ 0x41200000  10.0
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000d7c:	2532      	movs	r5, #50	@ 0x32
 8000d7e:	e057      	b.n	8000e30 <compute_event_pos+0x100>
		float32_t g2 = j12 * res1 + j22 * res2;
 8000d80:	ee6c 7a27 	vmul.f32	s15, s24, s15
		float32_t g1 = j11 * res1 + j21 * res2;
 8000d84:	ee2c 7a07 	vmul.f32	s14, s24, s14
		float32_t g2 = j12 * res1 + j22 * res2;
 8000d88:	eeec 7aa3 	vfma.f32	s15, s25, s7
		float32_t g1 = j11 * res1 + j21 * res2;
 8000d8c:	eeac 7a85 	vfma.f32	s14, s25, s10
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000d90:	ee23 5a27 	vmul.f32	s10, s6, s15
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000d94:	ee67 7ae5 	vnmul.f32	s15, s15, s11
 8000d98:	eef0 5a45 	vmov.f32	s11, s10
 8000d9c:	eee6 5a47 	vfms.f32	s11, s12, s14
 8000da0:	eee3 7a07 	vfma.f32	s15, s6, s14
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000da4:	ee85 6aa2 	vdiv.f32	s12, s11, s5
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000da8:	ee87 7aa2 	vdiv.f32	s14, s15, s5
	else if (in < -abs_max)
 8000dac:	eeb4 6ace 	vcmpe.f32	s12, s28
 8000db0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000db4:	bfb8      	it	lt
 8000db6:	eeb0 6a4e 	vmovlt.f32	s12, s28
 8000dba:	eeb4 6aed 	vcmpe.f32	s12, s27
 8000dbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000dc2:	eeb4 7ace 	vcmpe.f32	s14, s28
 8000dc6:	bf88      	it	hi
 8000dc8:	eeb0 6a6d 	vmovhi.f32	s12, s27
 8000dcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000dd0:	bfb8      	it	lt
 8000dd2:	eeb0 7a4e 	vmovlt.f32	s14, s28
 8000dd6:	eeb4 7aed 	vcmpe.f32	s14, s27
 8000dda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000dde:	bf88      	it	hi
 8000de0:	eeb0 7a6d 	vmovhi.f32	s14, s27
		*x += dx;
 8000de4:	ee76 7a86 	vadd.f32	s15, s13, s12
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000de8:	ee67 6a07 	vmul.f32	s13, s14, s14
		*x += dx;
 8000dec:	edc8 7a00 	vstr	s15, [r8]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000df0:	eef0 7a66 	vmov.f32	s15, s13
 8000df4:	eee6 7a06 	vfma.f32	s15, s12, s12
		*y += dy;
 8000df8:	edd9 5a00 	vldr	s11, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000dfc:	eef1 7ae7 	vsqrt.f32	s15, s15
		*y += dy;
 8000e00:	ee77 ba25 	vadd.f32	s23, s14, s11
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000e04:	ee17 0a90 	vmov	r0, s15
		*y += dy;
 8000e08:	edc9 ba00 	vstr	s23, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000e0c:	f7ff fb48 	bl	80004a0 <__aeabi_f2d>
 8000e10:	4632      	mov	r2, r6
 8000e12:	463b      	mov	r3, r7
 8000e14:	f7ff fe0e 	bl	8000a34 <__aeabi_dcmplt>
 8000e18:	2800      	cmp	r0, #0
 8000e1a:	f040 80a2 	bne.w	8000f62 <compute_event_pos+0x232>
	for (uint8_t i = 0; i < 50; i++)
 8000e1e:	1e6b      	subs	r3, r5, #1
 8000e20:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
		old_res2 = res2;
 8000e24:	eef0 4a6c 	vmov.f32	s9, s25
		old_res1 = res1;
 8000e28:	eeb0 4a4c 	vmov.f32	s8, s24
	for (uint8_t i = 0; i < 50; i++)
 8000e2c:	f000 8094 	beq.w	8000f58 <compute_event_pos+0x228>
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e30:	edd4 2a01 	vldr	s5, [r4, #4]
 8000e34:	edd8 6a00 	vldr	s13, [r8]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e38:	ed94 6a03 	vldr	s12, [r4, #12]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e3c:	ed94 7a05 	vldr	s14, [r4, #20]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e40:	ed94 2a00 	vldr	s4, [r4]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e44:	edd4 5a02 	vldr	s11, [r4, #8]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e48:	ed94 5a04 	vldr	s10, [r4, #16]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e4c:	ee7b 7ae2 	vsub.f32	s15, s23, s5
 8000e50:	ee76 1ac2 	vsub.f32	s3, s13, s4
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e54:	ee3b 6ac6 	vsub.f32	s12, s23, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e58:	ee3b 7ac7 	vsub.f32	s14, s23, s14
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e5c:	ee67 7aa7 	vmul.f32	s15, s15, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e60:	ee76 5ae5 	vsub.f32	s11, s13, s11
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e64:	eee1 7aa1 	vfma.f32	s15, s3, s3
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e68:	ee66 3a06 	vmul.f32	s7, s12, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e6c:	ee36 5ac5 	vsub.f32	s10, s13, s10
 8000e70:	ee27 3a07 	vmul.f32	s6, s14, s14
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e74:	eee5 3aa5 	vfma.f32	s7, s11, s11
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e78:	eea5 3a05 	vfma.f32	s6, s10, s10
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8000e7c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8000e80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000e84:	eef1 1ae7 	vsqrt.f32	s3, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000e88:	eeb1 1ae3 	vsqrt.f32	s2, s7
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000e8c:	eef1 0ac3 	vsqrt.f32	s1, s6
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8000e90:	d067      	beq.n	8000f62 <compute_event_pos+0x232>
 8000e92:	eef5 3a40 	vcmp.f32	s7, #0.0
 8000e96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000e9a:	d062      	beq.n	8000f62 <compute_event_pos+0x232>
 8000e9c:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8000ea0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000ea4:	d05d      	beq.n	8000f62 <compute_event_pos+0x232>
		float32_t res2 = r2 - r0 - d20;
 8000ea6:	ee70 cac8 	vsub.f32	s25, s1, s16
		float32_t res1 = r1 - r0 - d10;
 8000eaa:	ee31 ca68 	vsub.f32	s24, s2, s17
		float32_t res2 = r2 - r0 - d20;
 8000eae:	ee7c cae1 	vsub.f32	s25, s25, s3
		float32_t res1 = r1 - r0 - d10;
 8000eb2:	ee3c ca61 	vsub.f32	s24, s24, s3
		float32_t cost = res1 * res1 + res2 * res2;
 8000eb6:	ee6c 3aac 	vmul.f32	s7, s25, s25
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 8000eba:	ee64 7aa4 	vmul.f32	s15, s9, s9
		float32_t cost = res1 * res1 + res2 * res2;
 8000ebe:	eeec 3a0c 	vfma.f32	s7, s24, s24
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 8000ec2:	eee4 7a04 	vfma.f32	s15, s8, s8
		if (cost < 1e-8f)	return 1;
 8000ec6:	eef4 3ac9 	vcmpe.f32	s7, s18
 8000eca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000ece:	d448      	bmi.n	8000f62 <compute_event_pos+0x232>
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8000ed0:	ee32 2a66 	vsub.f32	s4, s4, s13
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8000ed4:	ee72 2aeb 	vsub.f32	s5, s5, s23
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8000ed8:	eef4 3ae7 	vcmpe.f32	s7, s15
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8000edc:	ee82 3aa1 	vdiv.f32	s6, s5, s3
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8000ee0:	ee82 0a21 	vdiv.f32	s0, s4, s3
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8000ee4:	eec5 2a20 	vdiv.f32	s5, s10, s1
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8000ee8:	eec7 3a20 	vdiv.f32	s7, s14, s1
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8000eec:	eec6 7a01 	vdiv.f32	s15, s12, s2
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8000ef0:	ee85 7a81 	vdiv.f32	s14, s11, s2
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8000ef4:	ee32 5a80 	vadd.f32	s10, s5, s0
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8000ef8:	ee73 3a83 	vadd.f32	s7, s7, s6
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8000efc:	ee77 7a83 	vadd.f32	s15, s15, s6
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8000f00:	ee37 7a00 	vadd.f32	s14, s14, s0
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 8000f04:	ee65 5a05 	vmul.f32	s11, s10, s10
		float32_t prod12 = j11 * j12 + j21 * j22;
 8000f08:	ee25 3a23 	vmul.f32	s6, s10, s7
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 8000f0c:	ee23 6aa3 	vmul.f32	s12, s7, s7
 8000f10:	eee7 5a07 	vfma.f32	s11, s14, s14
		float32_t prod12 = j11 * j12 + j21 * j22;
 8000f14:	eea7 3a27 	vfma.f32	s6, s14, s15
 8000f18:	eea7 6aa7 	vfma.f32	s12, s15, s15
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8000f1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f20:	bf4c      	ite	mi
 8000f22:	ee2d da2a 	vmulmi.f32	s26, s26, s21
		else						lambda *= 5.0f;			// punish bad step
 8000f26:	ee2d da0a 	vmulpl.f32	s26, s26, s20
		float32_t det = prod11 * prod22 - prod12 * prod21;
 8000f2a:	ee63 2a43 	vnmul.f32	s5, s6, s6
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 8000f2e:	ee7d 5a25 	vadd.f32	s11, s26, s11
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 8000f32:	ee3d 6a06 	vadd.f32	s12, s26, s12
		float32_t det = prod11 * prod22 - prod12 * prod21;
 8000f36:	eee5 2a86 	vfma.f32	s5, s11, s12
		if (fabsf(det) < 1e-12f)
 8000f3a:	eeb0 2ae2 	vabs.f32	s4, s5
 8000f3e:	eeb4 2ae9 	vcmpe.f32	s4, s19
 8000f42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f46:	f57f af1b 	bpl.w	8000d80 <compute_event_pos+0x50>
	for (uint8_t i = 0; i < 50; i++)
 8000f4a:	1e6b      	subs	r3, r5, #1
 8000f4c:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
			lambda *= 10.0f;
 8000f50:	ee2d da0b 	vmul.f32	s26, s26, s22
	for (uint8_t i = 0; i < 50; i++)
 8000f54:	f47f af6c 	bne.w	8000e30 <compute_event_pos+0x100>
}
 8000f58:	ecbd 8b0e 	vpop	{d8-d14}
 8000f5c:	4628      	mov	r0, r5
 8000f5e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000f62:	ecbd 8b0e 	vpop	{d8-d14}
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8000f66:	2501      	movs	r5, #1
}
 8000f68:	4628      	mov	r0, r5
 8000f6a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000f6e:	bf00      	nop
 8000f70:	88e368f1 	.word	0x88e368f1
 8000f74:	3ee4f8b5 	.word	0x3ee4f8b5
 8000f78:	43ab8000 	.word	0x43ab8000
 8000f7c:	00000000 	.word	0x00000000
 8000f80:	3a83126f 	.word	0x3a83126f
 8000f84:	322bcc77 	.word	0x322bcc77
 8000f88:	3e99999a 	.word	0x3e99999a
 8000f8c:	2b8cbccc 	.word	0x2b8cbccc
 8000f90:	be4ccccd 	.word	0xbe4ccccd
 8000f94:	3e4ccccd 	.word	0x3e4ccccd

08000f98 <compute_envelope>:
	else
		return in;
}

void compute_envelope(struct MicProc * mics)
{
 8000f98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000f9c:	f500 51fb 	add.w	r1, r0, #8032	@ 0x1f60
 8000fa0:	4605      	mov	r5, r0
 8000fa2:	f500 4059 	add.w	r0, r0, #55552	@ 0xd900
 8000fa6:	3118      	adds	r1, #24
 8000fa8:	3060      	adds	r0, #96	@ 0x60
	// square signals and multiply with gain of 2
	for (uint32_t i = 0; i < N_MICS; i++)
 8000faa:	f643 54f8 	movw	r4, #15864	@ 0x3df8
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8000fae:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
{
 8000fb2:	460a      	mov	r2, r1
			mics[i].envelope[j] = mics[i].samples[j] * mics[i].samples[j] * 2;
 8000fb4:	ecf3 7a01 	vldmia	r3!, {s15}
 8000fb8:	ee67 7aa7 	vmul.f32	s15, s15, s15
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8000fbc:	428b      	cmp	r3, r1
			mics[i].envelope[j] = mics[i].samples[j] * mics[i].samples[j] * 2;
 8000fbe:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8000fc2:	ece2 7a01 	vstmia	r2!, {s15}
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8000fc6:	d1f5      	bne.n	8000fb4 <compute_envelope+0x1c>
	for (uint32_t i = 0; i < N_MICS; i++)
 8000fc8:	1919      	adds	r1, r3, r4
 8000fca:	4281      	cmp	r1, r0
 8000fcc:	d1ef      	bne.n	8000fae <compute_envelope+0x16>
 8000fce:	f505 463a 	add.w	r6, r5, #47616	@ 0xba00
 8000fd2:	f105 0424 	add.w	r4, r5, #36	@ 0x24
 8000fd6:	360c      	adds	r6, #12

	// Lowpass filter to remove high frequencies accumulated during scaling
	for (uint32_t i = 0; i < N_MICS; i++)
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8000fd8:	f641 7854 	movw	r8, #8020	@ 0x1f54
	for (uint32_t i = 0; i < N_MICS; i++)
 8000fdc:	f643 57f8 	movw	r7, #15864	@ 0x3df8
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8000fe0:	eb04 0208 	add.w	r2, r4, r8
 8000fe4:	4620      	mov	r0, r4
 8000fe6:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 8000fea:	4611      	mov	r1, r2
	for (uint32_t i = 0; i < N_MICS; i++)
 8000fec:	443c      	add	r4, r7
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8000fee:	f000 fbc5 	bl	800177c <arm_fir_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 8000ff2:	42b4      	cmp	r4, r6
 8000ff4:	d1f4      	bne.n	8000fe0 <compute_envelope+0x48>
 8000ff6:	f505 511b 	add.w	r1, r5, #9920	@ 0x26c0
 8000ffa:	f505 4560 	add.w	r5, r5, #57344	@ 0xe000
 */
__STATIC_FORCEINLINE arm_status arm_sqrt_f32(
  const float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8000ffe:	2000      	movs	r0, #0
 8001000:	3138      	adds	r1, #56	@ 0x38
 8001002:	35e0      	adds	r5, #224	@ 0xe0

	// square root output
	for (uint32_t i = 0; i < N_MICS; i++)
 8001004:	f643 54f8 	movw	r4, #15864	@ 0x3df8
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8001008:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
 800100c:	e005      	b.n	800101a <compute_envelope+0x82>
 800100e:	428b      	cmp	r3, r1
      *pOut = _sqrtf(in);
#elif defined(__GNUC_PYTHON__)
      *pOut = sqrtf(in);
#elif defined ( __GNUC__ )
  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 8001010:	eef1 7ae7 	vsqrt.f32	s15, s15
 8001014:	edc2 7a00 	vstr	s15, [r2]
 8001018:	d00b      	beq.n	8001032 <compute_envelope+0x9a>
 800101a:	461a      	mov	r2, r3
			arm_sqrt_f32(mics[i].envelope[j], &mics[i].envelope[j]);
 800101c:	ecf3 7a01 	vldmia	r3!, {s15}
    if (in >= 0.0f)
 8001020:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8001024:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001028:	daf1      	bge.n	800100e <compute_envelope+0x76>
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 800102a:	428b      	cmp	r3, r1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 800102c:	f843 0c04 	str.w	r0, [r3, #-4]
 8001030:	d1f3      	bne.n	800101a <compute_envelope+0x82>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001032:	1919      	adds	r1, r3, r4
 8001034:	42a9      	cmp	r1, r5
 8001036:	d1e7      	bne.n	8001008 <compute_envelope+0x70>
}
 8001038:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800103c <main>:
{
 800103c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001040:	ed2d 8b06 	vpush	{d8-d10}
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 8001044:	4dca      	ldr	r5, [pc, #808]	@ (8001370 <main+0x334>)
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 8001046:	4fcb      	ldr	r7, [pc, #812]	@ (8001374 <main+0x338>)
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 8001048:	4ecb      	ldr	r6, [pc, #812]	@ (8001378 <main+0x33c>)
{
 800104a:	f5ad 4d4a 	sub.w	sp, sp, #51712	@ 0xca00
 800104e:	b09f      	sub	sp, #124	@ 0x7c
	sysclock_init();
 8001050:	f7ff fd68 	bl	8000b24 <sysclock_init>
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 8001054:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001056:	ac12      	add	r4, sp, #72	@ 0x48
 8001058:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800105a:	e895 0003 	ldmia.w	r5, {r0, r1}
 800105e:	e884 0003 	stmia.w	r4, {r0, r1}
 8001062:	f50d 5484 	add.w	r4, sp, #4224	@ 0x1080
 8001066:	3410      	adds	r4, #16
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 8001068:	4620      	mov	r0, r4
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 800106a:	f44f 75f0 	mov.w	r5, #480	@ 0x1e0
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 800106e:	f001 fb2b 	bl	80026c8 <arm_rfft_fast_init_256_f32>
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 8001072:	f104 0330 	add.w	r3, r4, #48	@ 0x30
 8001076:	f104 0018 	add.w	r0, r4, #24
 800107a:	463a      	mov	r2, r7
 800107c:	212a      	movs	r1, #42	@ 0x2a
 800107e:	9500      	str	r5, [sp, #0]
 8001080:	f000 fbb6 	bl	80017f0 <arm_fir_init_f32>
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 8001084:	f604 0354 	addw	r3, r4, #2132	@ 0x854
 8001088:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 800108c:	9500      	str	r5, [sp, #0]
 800108e:	4632      	mov	r2, r6
 8001090:	212a      	movs	r1, #42	@ 0x2a
 8001092:	f000 fbad 	bl	80017f0 <arm_fir_init_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001096:	f504 5477 	add.w	r4, r4, #15808	@ 0x3dc0
 800109a:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 800109e:	3438      	adds	r4, #56	@ 0x38
 80010a0:	3378      	adds	r3, #120	@ 0x78
 80010a2:	42a3      	cmp	r3, r4
 80010a4:	d1e0      	bne.n	8001068 <main+0x2c>
	arm_rfft_fast_init_256_f32(&xcorr_01_freq_hfft);
 80010a6:	a818      	add	r0, sp, #96	@ 0x60
 80010a8:	f001 fb0e 	bl	80026c8 <arm_rfft_fast_init_256_f32>
	arm_rfft_fast_init_256_f32(&xcorr_02_freq_hfft);
 80010ac:	a81e      	add	r0, sp, #120	@ 0x78
 80010ae:	f001 fb0b 	bl	80026c8 <arm_rfft_fast_init_256_f32>
	uart2_set_fcpu(84000000);
 80010b2:	48b2      	ldr	r0, [pc, #712]	@ (800137c <main+0x340>)
 80010b4:	4db2      	ldr	r5, [pc, #712]	@ (8001380 <main+0x344>)
 80010b6:	4cb3      	ldr	r4, [pc, #716]	@ (8001384 <main+0x348>)
			float32_t mic01_delay = (float32_t) (max_ind_01 - (N_FFT / 2)) * T_SAMPLE;
 80010b8:	ed9f 9ab3 	vldr	s18, [pc, #716]	@ 8001388 <main+0x34c>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 80010bc:	eddf 8ab3 	vldr	s17, [pc, #716]	@ 800138c <main+0x350>
			xcorr_01_freq[0] = xcorr_01_freq[1] = xcorr_02_freq[0] = xcorr_02_freq[1] = 0;
 80010c0:	ed9f 8ab3 	vldr	s16, [pc, #716]	@ 8001390 <main+0x354>
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 80010c4:	ed9f aab3 	vldr	s20, [pc, #716]	@ 8001394 <main+0x358>
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 80010c8:	eddf 9ab3 	vldr	s19, [pc, #716]	@ 8001398 <main+0x35c>
	uart2_set_fcpu(84000000);
 80010cc:	f001 fb1a 	bl	8002704 <uart2_set_fcpu>
	uart2_dma1_config(115200, USART_DATA_8, USART_STOP_1);
 80010d0:	2200      	movs	r2, #0
 80010d2:	4611      	mov	r1, r2
 80010d4:	f44f 30e1 	mov.w	r0, #115200	@ 0x1c200
 80010d8:	f001 fb24 	bl	8002724 <uart2_dma1_config>
	spi1_dma2_init();
 80010dc:	f7ff fd64 	bl	8000ba8 <spi1_dma2_init>
	uint32_t last_trigger_sample = 0;
 80010e0:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 80010e4:	3210      	adds	r2, #16
 80010e6:	f502 5267 	add.w	r2, r2, #14784	@ 0x39c0
 80010ea:	3238      	adds	r2, #56	@ 0x38
 80010ec:	9203      	str	r2, [sp, #12]
 80010ee:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 80010f2:	3210      	adds	r2, #16
 80010f4:	2300      	movs	r3, #0
 80010f6:	f502 5b77 	add.w	fp, r2, #15808	@ 0x3dc0
 80010fa:	9309      	str	r3, [sp, #36]	@ 0x24
 80010fc:	f10b 0b38 	add.w	fp, fp, #56	@ 0x38
	uint32_t samples = 0;
 8001100:	9306      	str	r3, [sp, #24]
	uint32_t ref_sample = 0;
 8001102:	930b      	str	r3, [sp, #44]	@ 0x2c
	uint8_t triggered = 0;									// has a microphone detected an event?
 8001104:	9307      	str	r3, [sp, #28]
	uint8_t window_ind = 0;
 8001106:	9304      	str	r3, [sp, #16]
 8001108:	f105 0802 	add.w	r8, r5, #2
 800110c:	1d2f      	adds	r7, r5, #4
 800110e:	1ca6      	adds	r6, r4, #2
 8001110:	f104 0904 	add.w	r9, r4, #4
		while (!!(DMA2_Stream0->CR & DMA_SxCR_CT) == dma_tgt);		// wait for stream to complete
 8001114:	4ba1      	ldr	r3, [pc, #644]	@ (800139c <main+0x360>)
 8001116:	49a2      	ldr	r1, [pc, #648]	@ (80013a0 <main+0x364>)
 8001118:	781a      	ldrb	r2, [r3, #0]
 800111a:	690b      	ldr	r3, [r1, #16]
 800111c:	f3c3 43c0 	ubfx	r3, r3, #19, #1
 8001120:	4293      	cmp	r3, r2
 8001122:	d0fa      	beq.n	800111a <main+0xde>
		dma_tgt = !dma_tgt;											// switch DMA targets
 8001124:	489d      	ldr	r0, [pc, #628]	@ (800139c <main+0x360>)
		uint32_t ind = i / 3;
 8001126:	f8df e280 	ldr.w	lr, [pc, #640]	@ 80013a8 <main+0x36c>
		dma_tgt = !dma_tgt;											// switch DMA targets
 800112a:	2a00      	cmp	r2, #0
 800112c:	bf0c      	ite	eq
 800112e:	2301      	moveq	r3, #1
 8001130:	2300      	movne	r3, #0
 8001132:	7003      	strb	r3, [r0, #0]
		DMA2->LIFCR |= DMA_LIFCR_CTCIF0 | DMA_LIFCR_CHTIF0;			// clear transfer complete and half complete flag
 8001134:	688b      	ldr	r3, [r1, #8]
 8001136:	f043 0330 	orr.w	r3, r3, #48	@ 0x30
 800113a:	608b      	str	r3, [r1, #8]
		samples += N_SAMPLE;
 800113c:	9b06      	ldr	r3, [sp, #24]
 800113e:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
 8001142:	9305      	str	r3, [sp, #20]
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 8001144:	f50d 53d3 	add.w	r3, sp, #6752	@ 0x1a60
 8001148:	f103 0318 	add.w	r3, r3, #24
 800114c:	f503 5050 	add.w	r0, r3, #13312	@ 0x3400
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8001150:	f503 41e4 	add.w	r1, r3, #29184	@ 0x7200
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 8001154:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 8001158:	f100 0010 	add.w	r0, r0, #16
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 800115c:	f101 0108 	add.w	r1, r1, #8
 8001160:	f000 80ca 	beq.w	80012f8 <main+0x2bc>
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8001164:	2200      	movs	r2, #0
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 8001166:	f6a3 1ce8 	subw	ip, r3, #2536	@ 0x9e8
 800116a:	f835 3012 	ldrh.w	r3, [r5, r2, lsl #1]
 800116e:	ee06 3a90 	vmov	s13, r3
 8001172:	f838 3012 	ldrh.w	r3, [r8, r2, lsl #1]
 8001176:	ee07 3a10 	vmov	s14, r3
 800117a:	f837 3012 	ldrh.w	r3, [r7, r2, lsl #1]
 800117e:	ee07 3a90 	vmov	s15, r3
 8001182:	eef8 6a66 	vcvt.f32.u32	s13, s13
		uint32_t ind = i / 3;
 8001186:	fbae a302 	umull	sl, r3, lr, r2
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 800118a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800118e:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8001192:	085b      	lsrs	r3, r3, #1
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 8001194:	f203 431e 	addw	r3, r3, #1054	@ 0x41e
 8001198:	ee76 6ac6 	vsub.f32	s13, s13, s12
 800119c:	eb0c 0a83 	add.w	sl, ip, r3, lsl #2
 80011a0:	ee37 7a46 	vsub.f32	s14, s14, s12
 80011a4:	ee77 7ac6 	vsub.f32	s15, s15, s12
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 80011a8:	3203      	adds	r2, #3
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 80011aa:	edca 6a00 	vstr	s13, [sl]
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 80011ae:	f5b2 6fb4 	cmp.w	r2, #1440	@ 0x5a0
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 80011b2:	eb00 0a83 	add.w	sl, r0, r3, lsl #2
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 80011b6:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				mics[j].raw[ind] = (float32_t) stream1[i + j] - 2048.0 * (1.0f / 2048.0f);
 80011ba:	ed8a 7a00 	vstr	s14, [sl]
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 80011be:	edc3 7a00 	vstr	s15, [r3]
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 80011c2:	d1d2      	bne.n	800116a <main+0x12e>
			arm_fir_f32(&mics[i].bp_hfir, mics[i].raw, mics[i].samples, N_SAMPLE);
 80011c4:	f50d 5384 	add.w	r3, sp, #4224	@ 0x1080
 80011c8:	3310      	adds	r3, #16
 80011ca:	f50d 518b 	add.w	r1, sp, #4448	@ 0x1160
 80011ce:	f50d 508b 	add.w	r0, sp, #4448	@ 0x1160
 80011d2:	f503 52bf 	add.w	r2, r3, #6112	@ 0x17e0
 80011d6:	3118      	adds	r1, #24
 80011d8:	3018      	adds	r0, #24
 80011da:	3218      	adds	r2, #24
 80011dc:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 80011e0:	f501 6179 	add.w	r1, r1, #3984	@ 0xf90
 80011e4:	38d0      	subs	r0, #208	@ 0xd0
 80011e6:	f000 fac9 	bl	800177c <arm_fir_f32>
 80011ea:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 80011ee:	f50d 5184 	add.w	r1, sp, #4224	@ 0x1080
 80011f2:	f50d 5084 	add.w	r0, sp, #4224	@ 0x1080
 80011f6:	3210      	adds	r2, #16
 80011f8:	3110      	adds	r1, #16
 80011fa:	3010      	adds	r0, #16
 80011fc:	f502 42ab 	add.w	r2, r2, #21888	@ 0x5580
 8001200:	f501 419c 	add.w	r1, r1, #19968	@ 0x4e00
 8001204:	f500 5078 	add.w	r0, r0, #15872	@ 0x3e00
 8001208:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800120c:	3270      	adds	r2, #112	@ 0x70
 800120e:	3170      	adds	r1, #112	@ 0x70
 8001210:	3010      	adds	r0, #16
 8001212:	f000 fab3 	bl	800177c <arm_fir_f32>
 8001216:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 800121a:	3210      	adds	r2, #16
 800121c:	f502 410c 	add.w	r1, r2, #35840	@ 0x8c00
 8001220:	f502 40f8 	add.w	r0, r2, #31744	@ 0x7c00
 8001224:	f50d 528b 	add.w	r2, sp, #4448	@ 0x1160
 8001228:	3218      	adds	r2, #24
 800122a:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800122e:	3168      	adds	r1, #104	@ 0x68
 8001230:	f502 4213 	add.w	r2, r2, #37632	@ 0x9300
 8001234:	3008      	adds	r0, #8
 8001236:	f000 faa1 	bl	800177c <arm_fir_f32>
		compute_envelope(mics);
 800123a:	f50d 5084 	add.w	r0, sp, #4224	@ 0x1080
 800123e:	3010      	adds	r0, #16
 8001240:	f7ff feaa 	bl	8000f98 <compute_envelope>
			arm_copy_f32(mics[i].envelope, mics[i].buffer + window_ind * N_SAMPLE, N_SAMPLE); 		// copy envelope to buffer for processing later
 8001244:	f50d 5384 	add.w	r3, sp, #4224	@ 0x1080
 8001248:	3310      	adds	r3, #16
 800124a:	9804      	ldr	r0, [sp, #16]
 800124c:	f503 511b 	add.w	r1, r3, #9920	@ 0x26c0
 8001250:	f503 53fb 	add.w	r3, r3, #8032	@ 0x1f60
 8001254:	3318      	adds	r3, #24
 8001256:	ebc0 1a00 	rsb	sl, r0, r0, lsl #4
 800125a:	9308      	str	r3, [sp, #32]
 800125c:	4618      	mov	r0, r3
 800125e:	9b04      	ldr	r3, [sp, #16]
 8001260:	3138      	adds	r1, #56	@ 0x38
 8001262:	eb01 11ca 	add.w	r1, r1, sl, lsl #7
 8001266:	011b      	lsls	r3, r3, #4
 8001268:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800126c:	930a      	str	r3, [sp, #40]	@ 0x28
 800126e:	f000 faf3 	bl	8001858 <arm_copy_f32>
 8001272:	f50d 5384 	add.w	r3, sp, #4224	@ 0x1080
 8001276:	3310      	adds	r3, #16
 8001278:	f503 41c9 	add.w	r1, r3, #25728	@ 0x6480
 800127c:	f503 40ba 	add.w	r0, r3, #23808	@ 0x5d00
 8001280:	ea4f 1aca 	mov.w	sl, sl, lsl #7
 8001284:	3170      	adds	r1, #112	@ 0x70
 8001286:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800128a:	4451      	add	r1, sl
 800128c:	3070      	adds	r0, #112	@ 0x70
 800128e:	f000 fae3 	bl	8001858 <arm_copy_f32>
 8001292:	f50d 538b 	add.w	r3, sp, #4448	@ 0x1160
 8001296:	3318      	adds	r3, #24
 8001298:	f503 4122 	add.w	r1, r3, #41472	@ 0xa200
 800129c:	f50d 402b 	add.w	r0, sp, #43776	@ 0xab00
 80012a0:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 80012a4:	4451      	add	r1, sl
 80012a6:	30f8      	adds	r0, #248	@ 0xf8
 80012a8:	f000 fad6 	bl	8001858 <arm_copy_f32>
		if (!triggered && samples - last_trigger_sample > N_UPDATE_DELAY)			// wait for event detection after N_UPDATE_DELAY samples since last event
 80012ac:	9b07      	ldr	r3, [sp, #28]
 80012ae:	b9d3      	cbnz	r3, 80012e6 <main+0x2aa>
 80012b0:	9b05      	ldr	r3, [sp, #20]
 80012b2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80012b4:	1a9a      	subs	r2, r3, r2
 80012b6:	f5b2 7ffa 	cmp.w	r2, #500	@ 0x1f4
 80012ba:	9b08      	ldr	r3, [sp, #32]
 80012bc:	d84c      	bhi.n	8001358 <main+0x31c>
		if (++window_ind == N_WINDOW)
 80012be:	9b04      	ldr	r3, [sp, #16]
 80012c0:	3301      	adds	r3, #1
 80012c2:	b2db      	uxtb	r3, r3
			window_ind = 0;
 80012c4:	2b02      	cmp	r3, #2
 80012c6:	bf08      	it	eq
 80012c8:	2300      	moveq	r3, #0
 80012ca:	9304      	str	r3, [sp, #16]
 80012cc:	9b05      	ldr	r3, [sp, #20]
 80012ce:	9306      	str	r3, [sp, #24]
 80012d0:	e720      	b.n	8001114 <main+0xd8>
				if (thresh_ind_sorted[i] != -1)
 80012d2:	4613      	mov	r3, r2
					ref_sample = thresh_ind_sorted[i] + window_ind * N_SAMPLE;				// calculate reference sample location in buffer
 80012d4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80012d6:	9904      	ldr	r1, [sp, #16]
 80012d8:	1a52      	subs	r2, r2, r1
 80012da:	eb03 1242 	add.w	r2, r3, r2, lsl #5
 80012de:	920b      	str	r2, [sp, #44]	@ 0x2c
					last_trigger_sample = samples - (N_SAMPLE - thresh_ind_sorted[i]);		// compute global sample value
 80012e0:	9a06      	ldr	r2, [sp, #24]
 80012e2:	441a      	add	r2, r3
 80012e4:	9209      	str	r2, [sp, #36]	@ 0x24
		if (triggered && samples > last_trigger_sample + N_SAMPLES_AFTER)		// wait until enough samples have been taken after peak is detected
 80012e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80012e8:	9a05      	ldr	r2, [sp, #20]
 80012ea:	33e5      	adds	r3, #229	@ 0xe5
 80012ec:	4293      	cmp	r3, r2
 80012ee:	f0c0 8093 	bcc.w	8001418 <main+0x3dc>
 80012f2:	2301      	movs	r3, #1
 80012f4:	9307      	str	r3, [sp, #28]
 80012f6:	e7e2      	b.n	80012be <main+0x282>
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 80012f8:	f6a3 1ce8 	subw	ip, r3, #2536	@ 0x9e8
 80012fc:	f834 3012 	ldrh.w	r3, [r4, r2, lsl #1]
 8001300:	ee06 3a90 	vmov	s13, r3
 8001304:	f836 3012 	ldrh.w	r3, [r6, r2, lsl #1]
 8001308:	ee07 3a10 	vmov	s14, r3
 800130c:	f839 3012 	ldrh.w	r3, [r9, r2, lsl #1]
 8001310:	ee07 3a90 	vmov	s15, r3
 8001314:	eef8 6a66 	vcvt.f32.u32	s13, s13
		uint32_t ind = i / 3;
 8001318:	fbae a302 	umull	sl, r3, lr, r2
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 800131c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8001320:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8001324:	085b      	lsrs	r3, r3, #1
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8001326:	f203 431e 	addw	r3, r3, #1054	@ 0x41e
 800132a:	ee76 6ac6 	vsub.f32	s13, s13, s12
 800132e:	eb0c 0a83 	add.w	sl, ip, r3, lsl #2
 8001332:	ee37 7a46 	vsub.f32	s14, s14, s12
 8001336:	ee77 7ac6 	vsub.f32	s15, s15, s12
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 800133a:	3203      	adds	r2, #3
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 800133c:	edca 6a00 	vstr	s13, [sl]
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8001340:	f5b2 6fb4 	cmp.w	r2, #1440	@ 0x5a0
				mics[j].raw[ind] = (float32_t) stream0[i + j] - 2048.0 * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8001344:	eb00 0a83 	add.w	sl, r0, r3, lsl #2
 8001348:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 800134c:	ed8a 7a00 	vstr	s14, [sl]
 8001350:	edc3 7a00 	vstr	s15, [r3]
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8001354:	d1d2      	bne.n	80012fc <main+0x2c0>
 8001356:	e735      	b.n	80011c4 <main+0x188>

int32_t thresh_search(float32_t * src, uint32_t len, float32_t thresh)
{
	for (uint32_t i = 0; i < len; i++)
	{
		if (src[i] > thresh)
 8001358:	ed9f 7a12 	vldr	s14, [pc, #72]	@ 80013a4 <main+0x368>
 800135c:	461a      	mov	r2, r3
 800135e:	f50d 6149 	add.w	r1, sp, #3216	@ 0xc90
 8001362:	f60d 4c9c 	addw	ip, sp, #3228	@ 0xc9c
			for (uint32_t i = 0; i < N_MICS; i++)
 8001366:	f643 50f8 	movw	r0, #15864	@ 0x3df8
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 800136a:	4696      	mov	lr, r2
	for (uint32_t i = 0; i < len; i++)
 800136c:	2300      	movs	r3, #0
 800136e:	e023      	b.n	80013b8 <main+0x37c>
 8001370:	08002a54 	.word	0x08002a54
 8001374:	08002b14 	.word	0x08002b14
 8001378:	08002a6c 	.word	0x08002a6c
 800137c:	0501bd00 	.word	0x0501bd00
 8001380:	20000024 	.word	0x20000024
 8001384:	20000b64 	.word	0x20000b64
 8001388:	37d1b717 	.word	0x37d1b717
 800138c:	3f99999a 	.word	0x3f99999a
 8001390:	00000000 	.word	0x00000000
 8001394:	3eaaaaab 	.word	0x3eaaaaab
 8001398:	3f2aaaab 	.word	0x3f2aaaab
 800139c:	20000020 	.word	0x20000020
 80013a0:	40026400 	.word	0x40026400
 80013a4:	45fa0000 	.word	0x45fa0000
 80013a8:	aaaaaaab 	.word	0xaaaaaaab
 80013ac:	be4ccccd 	.word	0xbe4ccccd
 80013b0:	3301      	adds	r3, #1
 80013b2:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 80013b6:	d027      	beq.n	8001408 <main+0x3cc>
		if (src[i] > thresh)
 80013b8:	ecfe 7a01 	vldmia	lr!, {s15}
 80013bc:	eef4 7ac7 	vcmpe.f32	s15, s14
 80013c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80013c4:	ddf4      	ble.n	80013b0 <main+0x374>
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, ENERGY_THRESH);
 80013c6:	f841 3b04 	str.w	r3, [r1], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 80013ca:	458c      	cmp	ip, r1
 80013cc:	4402      	add	r2, r0
 80013ce:	d1cc      	bne.n	800136a <main+0x32e>
}

void simple_sort3(int32_t * src, int32_t * dst)
{

	if (src[0] <= src[1] && src[0] <= src[2])
 80013d0:	f50d 6249 	add.w	r2, sp, #3216	@ 0xc90
 80013d4:	e9d2 1300 	ldrd	r1, r3, [r2]
 80013d8:	4299      	cmp	r1, r3
 80013da:	6892      	ldr	r2, [r2, #8]
 80013dc:	f340 816f 	ble.w	80016be <main+0x682>
		{
			dst[1] = src[2];
			dst[2] = src[1];
		}
	}
	else if (src[1] <= src[0] && src[1] <= src[2])
 80013e0:	4293      	cmp	r3, r2
 80013e2:	f300 8177 	bgt.w	80016d4 <main+0x698>
	{
		dst[0] = src[1];

		if (src[0] <= src[2])
 80013e6:	4291      	cmp	r1, r2
 80013e8:	4610      	mov	r0, r2
		dst[0] = src[1];
 80013ea:	461a      	mov	r2, r3
		if (src[0] <= src[2])
 80013ec:	f340 8174 	ble.w	80016d8 <main+0x69c>
			dst[2] = src[2];
		}
		else
		{
			dst[1] = src[2];
			dst[2] = src[0];
 80013f0:	460b      	mov	r3, r1
			dst[1] = src[2];
 80013f2:	4601      	mov	r1, r0
				if (thresh_ind_sorted[i] != -1)
 80013f4:	1c50      	adds	r0, r2, #1
 80013f6:	f47f af6c 	bne.w	80012d2 <main+0x296>
 80013fa:	1c48      	adds	r0, r1, #1
 80013fc:	f040 816e 	bne.w	80016dc <main+0x6a0>
 8001400:	1c5a      	adds	r2, r3, #1
 8001402:	f43f af5c 	beq.w	80012be <main+0x282>
 8001406:	e765      	b.n	80012d4 <main+0x298>
	return -1;
 8001408:	f04f 33ff 	mov.w	r3, #4294967295
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, ENERGY_THRESH);
 800140c:	f841 3b04 	str.w	r3, [r1], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 8001410:	458c      	cmp	ip, r1
 8001412:	4402      	add	r2, r0
 8001414:	d1a9      	bne.n	800136a <main+0x32e>
 8001416:	e7db      	b.n	80013d0 <main+0x394>
			int32_t start_sample = ref_sample - N_SAMPLES_BEFORE;
 8001418:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800141a:	f1a2 031a 	sub.w	r3, r2, #26
			if (start_sample > 0 && stop_sample < N_BUFFER)					// if N_FFT is not wrapped in buffer...
 800141e:	2b00      	cmp	r3, #0
			int32_t stop_sample = ref_sample + N_SAMPLES_AFTER;
 8001420:	f102 02e5 	add.w	r2, r2, #229	@ 0xe5
			if (start_sample > 0 && stop_sample < N_BUFFER)					// if N_FFT is not wrapped in buffer...
 8001424:	f340 810b 	ble.w	800163e <main+0x602>
 8001428:	f5b2 7f70 	cmp.w	r2, #960	@ 0x3c0
 800142c:	f280 810b 	bge.w	8001646 <main+0x60a>
					arm_copy_f32(mics[i].buffer + start_sample, mics[i].fft_window, N_FFT);
 8001430:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 8001434:	3210      	adds	r2, #16
 8001436:	f502 501b 	add.w	r0, r2, #9920	@ 0x26c0
 800143a:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 800143e:	3038      	adds	r0, #56	@ 0x38
 8001440:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8001444:	3138      	adds	r1, #56	@ 0x38
 8001446:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800144a:	ea4f 0a83 	mov.w	sl, r3, lsl #2
 800144e:	f000 fa03 	bl	8001858 <arm_copy_f32>
 8001452:	f50d 5384 	add.w	r3, sp, #4224	@ 0x1080
 8001456:	3310      	adds	r3, #16
 8001458:	f503 40c9 	add.w	r0, r3, #25728	@ 0x6480
 800145c:	f503 41e7 	add.w	r1, r3, #29568	@ 0x7380
 8001460:	3070      	adds	r0, #112	@ 0x70
 8001462:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001466:	4450      	add	r0, sl
 8001468:	3170      	adds	r1, #112	@ 0x70
 800146a:	f000 f9f5 	bl	8001858 <arm_copy_f32>
 800146e:	f50d 538b 	add.w	r3, sp, #4448	@ 0x1160
 8001472:	3318      	adds	r3, #24
 8001474:	f503 4022 	add.w	r0, r3, #41472	@ 0xa200
 8001478:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800147c:	4450      	add	r0, sl
 800147e:	f503 4131 	add.w	r1, r3, #45312	@ 0xb100
 8001482:	f000 f9e9 	bl	8001858 <arm_copy_f32>
				for (uint32_t i = 0; i < N_FFT; i++)
 8001486:	f50d 5a84 	add.w	sl, sp, #4224	@ 0x1080
 800148a:	f10a 0a10 	add.w	sl, sl, #16
				arm_rfft_fast_f32(&mics[i].hfft, mics[i].fft_window, mics[i].fft, 0);
 800148e:	f50a 5267 	add.w	r2, sl, #14784	@ 0x39c0
 8001492:	f50a 5157 	add.w	r1, sl, #13760	@ 0x35c0
 8001496:	2300      	movs	r3, #0
 8001498:	4650      	mov	r0, sl
 800149a:	3238      	adds	r2, #56	@ 0x38
 800149c:	3138      	adds	r1, #56	@ 0x38
 800149e:	f001 f85d 	bl	800255c <arm_rfft_fast_f32>
			for (uint32_t i = 0; i < N_MICS; i++)
 80014a2:	f50a 5a77 	add.w	sl, sl, #15808	@ 0x3dc0
 80014a6:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 80014aa:	f10a 0a38 	add.w	sl, sl, #56	@ 0x38
 80014ae:	3378      	adds	r3, #120	@ 0x78
 80014b0:	4553      	cmp	r3, sl
 80014b2:	d1ec      	bne.n	800148e <main+0x452>
 80014b4:	f50d 5384 	add.w	r3, sp, #4224	@ 0x1080
 80014b8:	3310      	adds	r3, #16
 80014ba:	f503 42ef 	add.w	r2, r3, #30592	@ 0x7780
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 80014be:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 80014c2:	3278      	adds	r2, #120	@ 0x78
 80014c4:	f503 5368 	add.w	r3, r3, #14848	@ 0x3a00
 80014c8:	f50d 6009 	add.w	r0, sp, #2192	@ 0x890
 80014cc:	f50d 6149 	add.w	r1, sp, #3216	@ 0xc90
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 80014d0:	f647 3af0 	movw	sl, #31728	@ 0x7bf0
 80014d4:	f647 3ef4 	movw	lr, #31732	@ 0x7bf4
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014d8:	edd3 6a00 	vldr	s13, [r3]
 80014dc:	edd2 7a01 	vldr	s15, [r2, #4]
 80014e0:	ed93 6a01 	vldr	s12, [r3, #4]
 80014e4:	edd2 5a00 	vldr	s11, [r2]
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 80014e8:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014ec:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 80014f0:	eea5 7a86 	vfma.f32	s14, s11, s12
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 80014f4:	eb03 0c0e 	add.w	ip, r3, lr
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80014f8:	3208      	adds	r2, #8
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014fa:	eee6 7aa5 	vfma.f32	s15, s13, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80014fe:	3008      	adds	r0, #8
 8001500:	3108      	adds	r1, #8
				float32_t mag_01 = sqrtf(re_01 * re_01 + im_01 * im_01);
 8001502:	ee67 5a07 	vmul.f32	s11, s14, s14
 8001506:	eee7 5aa7 	vfma.f32	s11, s15, s15
 800150a:	eef1 4ae5 	vsqrt.f32	s9, s11
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800150e:	eec5 5a24 	vdiv.f32	s11, s10, s9
 8001512:	ee65 7aa7 	vmul.f32	s15, s11, s15
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001516:	ee65 5a87 	vmul.f32	s11, s11, s14
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800151a:	edc0 7a00 	vstr	s15, [r0]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800151e:	eddc 7a00 	vldr	s15, [ip]
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001522:	edc0 5a01 	vstr	s11, [r0, #4]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 8001526:	eb03 0c0a 	add.w	ip, r3, sl
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 800152a:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800152e:	eddc 5a00 	vldr	s11, [ip]
 8001532:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 8001536:	eea6 7a25 	vfma.f32	s14, s12, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 800153a:	3308      	adds	r3, #8
 800153c:	455b      	cmp	r3, fp
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800153e:	eee6 7aa5 	vfma.f32	s15, s13, s11
				float32_t mag_02 = sqrtf(re_02 * re_02 + im_02 * im_02);
 8001542:	ee67 6a07 	vmul.f32	s13, s14, s14
 8001546:	eee7 6aa7 	vfma.f32	s13, s15, s15
 800154a:	eeb1 6ae6 	vsqrt.f32	s12, s13
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 800154e:	eec5 6a06 	vdiv.f32	s13, s10, s12
 8001552:	ee66 7aa7 	vmul.f32	s15, s13, s15
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 8001556:	ee66 6a87 	vmul.f32	s13, s13, s14
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 800155a:	edc1 7a00 	vstr	s15, [r1]
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 800155e:	edc1 6a01 	vstr	s13, [r1, #4]
			for (uint32_t i = 2; i < N_FFT; i += 2)
 8001562:	d1b9      	bne.n	80014d8 <main+0x49c>
			xcorr_01_freq[0] = xcorr_01_freq[1] = xcorr_02_freq[0] = xcorr_02_freq[1] = 0;
 8001564:	f50d 6349 	add.w	r3, sp, #3216	@ 0xc90
 8001568:	ed83 8a01 	vstr	s16, [r3, #4]
 800156c:	ed83 8a00 	vstr	s16, [r3]
 8001570:	f50d 6309 	add.w	r3, sp, #2192	@ 0x890
 8001574:	ed83 8a01 	vstr	s16, [r3, #4]
 8001578:	ed83 8a00 	vstr	s16, [r3]
			arm_rfft_fast_f32(&xcorr_01_freq_hfft, xcorr_01_freq, xcorr_01_time, 1);
 800157c:	aa24      	add	r2, sp, #144	@ 0x90
 800157e:	2301      	movs	r3, #1
 8001580:	f50d 6109 	add.w	r1, sp, #2192	@ 0x890
 8001584:	a818      	add	r0, sp, #96	@ 0x60
 8001586:	f000 ffe9 	bl	800255c <arm_rfft_fast_f32>
			arm_rfft_fast_f32(&xcorr_02_freq_hfft, xcorr_02_freq, xcorr_02_time, 1);
 800158a:	2301      	movs	r3, #1
 800158c:	f50d 6292 	add.w	r2, sp, #1168	@ 0x490
 8001590:	f50d 6149 	add.w	r1, sp, #3216	@ 0xc90
 8001594:	a81e      	add	r0, sp, #120	@ 0x78
 8001596:	f000 ffe1 	bl	800255c <arm_rfft_fast_f32>
			arm_max_f32(xcorr_01_time, N_FFT, &dummy, &max_ind_01);
 800159a:	ab0e      	add	r3, sp, #56	@ 0x38
 800159c:	aa0d      	add	r2, sp, #52	@ 0x34
 800159e:	f44f 7180 	mov.w	r1, #256	@ 0x100
 80015a2:	a824      	add	r0, sp, #144	@ 0x90
 80015a4:	f000 f934 	bl	8001810 <arm_max_f32>
			arm_max_f32(xcorr_02_time, N_FFT, &dummy, &max_ind_02);
 80015a8:	ab0f      	add	r3, sp, #60	@ 0x3c
 80015aa:	aa0d      	add	r2, sp, #52	@ 0x34
 80015ac:	f44f 7180 	mov.w	r1, #256	@ 0x100
 80015b0:	f50d 6092 	add.w	r0, sp, #1168	@ 0x490
 80015b4:	f000 f92c 	bl	8001810 <arm_max_f32>
			float32_t mic01_delay = (float32_t) (max_ind_01 - (N_FFT / 2)) * T_SAMPLE;
 80015b8:	ab0e      	add	r3, sp, #56	@ 0x38
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 80015ba:	f10d 0a40 	add.w	sl, sp, #64	@ 0x40
			float32_t mic01_delay = (float32_t) (max_ind_01 - (N_FFT / 2)) * T_SAMPLE;
 80015be:	681b      	ldr	r3, [r3, #0]
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 80015c0:	ed8a aa00 	vstr	s20, [sl]
			float32_t mic01_delay = (float32_t) (max_ind_01 - (N_FFT / 2)) * T_SAMPLE;
 80015c4:	3b80      	subs	r3, #128	@ 0x80
 80015c6:	ee07 3a90 	vmov	s15, r3
			float32_t mic02_delay = (float32_t) (max_ind_02 - (N_FFT / 2)) * T_SAMPLE;
 80015ca:	ab0f      	add	r3, sp, #60	@ 0x3c
			float32_t mic01_delay = (float32_t) (max_ind_01 - (N_FFT / 2)) * T_SAMPLE;
 80015cc:	eeb8 0a67 	vcvt.f32.u32	s0, s15
			float32_t mic02_delay = (float32_t) (max_ind_02 - (N_FFT / 2)) * T_SAMPLE;
 80015d0:	681b      	ldr	r3, [r3, #0]
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 80015d2:	edca 9a01 	vstr	s19, [sl, #4]
			float32_t mic02_delay = (float32_t) (max_ind_02 - (N_FFT / 2)) * T_SAMPLE;
 80015d6:	3b80      	subs	r3, #128	@ 0x80
 80015d8:	ee07 3a90 	vmov	s15, r3
 80015dc:	eef8 0a67 	vcvt.f32.u32	s1, s15
			uint8_t valid = compute_event_pos(&coords.xy[0], &coords.xy[1], mics_xy, mic01_delay, mic02_delay);
 80015e0:	ee20 0a09 	vmul.f32	s0, s0, s18
 80015e4:	ee60 0a89 	vmul.f32	s1, s1, s18
 80015e8:	aa12      	add	r2, sp, #72	@ 0x48
 80015ea:	a911      	add	r1, sp, #68	@ 0x44
 80015ec:	4650      	mov	r0, sl
 80015ee:	f7ff fb9f 	bl	8000d30 <compute_event_pos>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 80015f2:	b1c8      	cbz	r0, 8001628 <main+0x5ec>
 80015f4:	ed9a 7a00 	vldr	s14, [sl]
 80015f8:	eeb4 7ae8 	vcmpe.f32	s14, s17
 80015fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001600:	dc12      	bgt.n	8001628 <main+0x5ec>
 8001602:	ed5f 7a96 	vldr	s15, [pc, #-600]	@ 80013ac <main+0x370>
 8001606:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800160a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800160e:	d40b      	bmi.n	8001628 <main+0x5ec>
 8001610:	ed9a 7a01 	vldr	s14, [sl, #4]
 8001614:	eeb4 7ae8 	vcmpe.f32	s14, s17
 8001618:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800161c:	dc04      	bgt.n	8001628 <main+0x5ec>
 800161e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001626:	d55b      	bpl.n	80016e0 <main+0x6a4>
				coords.xy[0] = -1.0f;
 8001628:	ab10      	add	r3, sp, #64	@ 0x40
 800162a:	4a30      	ldr	r2, [pc, #192]	@ (80016ec <main+0x6b0>)
 800162c:	601a      	str	r2, [r3, #0]
				uart2_dma1_write(8, coords.ser);
 800162e:	4619      	mov	r1, r3
 8001630:	2008      	movs	r0, #8
				coords.xy[1] = -1.0f;
 8001632:	605a      	str	r2, [r3, #4]
				uart2_dma1_write(8, coords.ser);
 8001634:	f001 f998 	bl	8002968 <uart2_dma1_write>
			triggered = 0;
 8001638:	2300      	movs	r3, #0
 800163a:	9307      	str	r3, [sp, #28]
 800163c:	e63f      	b.n	80012be <main+0x282>
				if (start_sample < 0)
 800163e:	d002      	beq.n	8001646 <main+0x60a>
					curr_sample = (int32_t)N_BUFFER + start_sample;			// if start is on other end of buffer, move pointer back
 8001640:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8001642:	f203 33a6 	addw	r3, r3, #934	@ 0x3a6
				for (uint32_t i = 0; i < N_FFT; i++)
 8001646:	f50d 5284 	add.w	r2, sp, #4224	@ 0x1080
 800164a:	3210      	adds	r2, #16
 800164c:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 8001650:	f502 4ce7 	add.w	ip, r2, #29568	@ 0x7380
 8001654:	f50d 528b 	add.w	r2, sp, #4448	@ 0x1160
 8001658:	3218      	adds	r2, #24
 800165a:	f502 4e31 	add.w	lr, r2, #45312	@ 0xb100
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 800165e:	f50d 52d3 	add.w	r2, sp, #6752	@ 0x1a60
 8001662:	3218      	adds	r2, #24
 8001664:	3138      	adds	r1, #56	@ 0x38
 8001666:	f10c 0c70 	add.w	ip, ip, #112	@ 0x70
 800166a:	f6a2 10e8 	subw	r0, r2, #2536	@ 0x9e8
 800166e:	f642 0aba 	movw	sl, #10426	@ 0x28ba
 8001672:	f603 12be 	addw	r2, r3, #2494	@ 0x9be
 8001676:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800167a:	edd2 7a00 	vldr	s15, [r2]
 800167e:	f503 52c9 	add.w	r2, r3, #6432	@ 0x1920
 8001682:	321c      	adds	r2, #28
 8001684:	ece1 7a01 	vstmia	r1!, {s15}
 8001688:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800168c:	edd2 7a00 	vldr	s15, [r2]
 8001690:	eb03 020a 	add.w	r2, r3, sl
 8001694:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8001698:	ecec 7a01 	vstmia	ip!, {s15}
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 800169c:	3301      	adds	r3, #1
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 800169e:	6812      	ldr	r2, [r2, #0]
 80016a0:	f84e 2b04 	str.w	r2, [lr], #4
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 80016a4:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
 80016a8:	d003      	beq.n	80016b2 <main+0x676>
				for (uint32_t i = 0; i < N_FFT; i++)
 80016aa:	9a03      	ldr	r2, [sp, #12]
 80016ac:	4291      	cmp	r1, r2
 80016ae:	d1e0      	bne.n	8001672 <main+0x636>
 80016b0:	e6e9      	b.n	8001486 <main+0x44a>
 80016b2:	9b03      	ldr	r3, [sp, #12]
 80016b4:	4299      	cmp	r1, r3
 80016b6:	f43f aee6 	beq.w	8001486 <main+0x44a>
 80016ba:	2300      	movs	r3, #0
 80016bc:	e7d9      	b.n	8001672 <main+0x636>
	if (src[0] <= src[1] && src[0] <= src[2])
 80016be:	4291      	cmp	r1, r2
 80016c0:	f73f ae98 	bgt.w	80013f4 <main+0x3b8>
		if (src[1] <= src[2])
 80016c4:	4293      	cmp	r3, r2
 80016c6:	4610      	mov	r0, r2
		dst[0] = src[0];
 80016c8:	460a      	mov	r2, r1
		if (src[1] <= src[2])
 80016ca:	f73f ae92 	bgt.w	80013f2 <main+0x3b6>
			dst[1] = src[0];
			dst[2] = src[1];
		}
		else
		{
			dst[1] = src[1];
 80016ce:	4619      	mov	r1, r3
			dst[2] = src[0];
 80016d0:	4603      	mov	r3, r0
 80016d2:	e68f      	b.n	80013f4 <main+0x3b8>
	else if (src[1] <= src[0] && src[1] <= src[2])
 80016d4:	4608      	mov	r0, r1
 80016d6:	e7fa      	b.n	80016ce <main+0x692>
			dst[2] = src[2];
 80016d8:	4603      	mov	r3, r0
 80016da:	e68b      	b.n	80013f4 <main+0x3b8>
				if (thresh_ind_sorted[i] != -1)
 80016dc:	460b      	mov	r3, r1
 80016de:	e5f9      	b.n	80012d4 <main+0x298>
				uart2_dma1_write(8, coords.ser);
 80016e0:	a910      	add	r1, sp, #64	@ 0x40
 80016e2:	2008      	movs	r0, #8
 80016e4:	f001 f940 	bl	8002968 <uart2_dma1_write>
 80016e8:	e7a6      	b.n	8001638 <main+0x5fc>
 80016ea:	bf00      	nop
 80016ec:	bf800000 	.word	0xbf800000

080016f0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80016f0:	e7fe      	b.n	80016f0 <NMI_Handler>
 80016f2:	bf00      	nop

080016f4 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80016f4:	e7fe      	b.n	80016f4 <HardFault_Handler>
 80016f6:	bf00      	nop

080016f8 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80016f8:	e7fe      	b.n	80016f8 <MemManage_Handler>
 80016fa:	bf00      	nop

080016fc <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80016fc:	e7fe      	b.n	80016fc <BusFault_Handler>
 80016fe:	bf00      	nop

08001700 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001700:	e7fe      	b.n	8001700 <UsageFault_Handler>
 8001702:	bf00      	nop

08001704 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001704:	4770      	bx	lr
 8001706:	bf00      	nop

08001708 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 8001708:	4770      	bx	lr
 800170a:	bf00      	nop

0800170c <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 800170c:	4770      	bx	lr
 800170e:	bf00      	nop

08001710 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001710:	f000 bfec 	b.w	80026ec <HAL_IncTick>

08001714 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001714:	4a03      	ldr	r2, [pc, #12]	@ (8001724 <SystemInit+0x10>)
 8001716:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 800171a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800171e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001722:	4770      	bx	lr
 8001724:	e000ed00 	.word	0xe000ed00

08001728 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001728:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001760 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit  
 800172c:	f7ff fff2 	bl	8001714 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001730:	480c      	ldr	r0, [pc, #48]	@ (8001764 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001732:	490d      	ldr	r1, [pc, #52]	@ (8001768 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001734:	4a0d      	ldr	r2, [pc, #52]	@ (800176c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001736:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001738:	e002      	b.n	8001740 <LoopCopyDataInit>

0800173a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800173a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800173c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800173e:	3304      	adds	r3, #4

08001740 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001740:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001742:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001744:	d3f9      	bcc.n	800173a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001746:	4a0a      	ldr	r2, [pc, #40]	@ (8001770 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001748:	4c0a      	ldr	r4, [pc, #40]	@ (8001774 <LoopFillZerobss+0x22>)
  movs r3, #0
 800174a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800174c:	e001      	b.n	8001752 <LoopFillZerobss>

0800174e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800174e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001750:	3204      	adds	r2, #4

08001752 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001752:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001754:	d3fb      	bcc.n	800174e <FillZerobss>
 
/* Call static constructors */
    bl __libc_init_array
 8001756:	f001 f94d 	bl	80029f4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800175a:	f7ff fc6f 	bl	800103c <main>
  bx  lr    
 800175e:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001760:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 8001764:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001768:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 800176c:	08003574 	.word	0x08003574
  ldr r2, =_sbss
 8001770:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 8001774:	200016ac 	.word	0x200016ac

08001778 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001778:	e7fe      	b.n	8001778 <ADC_IRQHandler>
	...

0800177c <arm_fir_f32>:
ARM_DSP_ATTRIBUTE void arm_fir_f32(
  const arm_fir_instance_f32 * S,
  const float32_t * pSrc,
        float32_t * pDst,
        uint32_t blockSize)
{
 800177c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001780:	4690      	mov	r8, r2
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
        float32_t *pStateCurnt;                        /* Points to the current sample of the state */
        float32_t *px;                                 /* Temporary pointer for state buffer */
  const float32_t *pb;                                 /* Temporary pointer for coefficient buffer */
        float32_t acc0;                                /* Accumulator */
        uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
 8001782:	8802      	ldrh	r2, [r0, #0]
        float32_t *pState = S->pState;                 /* State pointer */
 8001784:	6846      	ldr	r6, [r0, #4]
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
 8001786:	f8d0 9008 	ldr.w	r9, [r0, #8]
        float32_t c0;                                           /* Temporary variable to hold coefficient value */
#endif

  /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
  /* pStateCurnt points to the location where the new input data should be written */
  pStateCurnt = &(S->pState[(numTaps - 1U)]);
 800178a:	f102 4080 	add.w	r0, r2, #1073741824	@ 0x40000000
 800178e:	3801      	subs	r0, #1
 8001790:	eb06 0580 	add.w	r5, r6, r0, lsl #2
  /* Initialize blkCnt with number of taps */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001794:	b33b      	cbz	r3, 80017e6 <arm_fir_f32+0x6a>
 8001796:	460f      	mov	r7, r1
 8001798:	461c      	mov	r4, r3
  blkCnt = blockSize;
 800179a:	4619      	mov	r1, r3
        float32_t *pState = S->pState;                 /* State pointer */
 800179c:	4633      	mov	r3, r6
  {
    /* Copy one sample at a time into state buffer */
    *pStateCurnt++ = *pSrc++;
 800179e:	f857 0b04 	ldr.w	r0, [r7], #4
 80017a2:	f845 0b04 	str.w	r0, [r5], #4

    /* Set the accumulator to zero */
    acc0 = 0.0f;
 80017a6:	eddf 7a11 	vldr	s15, [pc, #68]	@ 80017ec <arm_fir_f32+0x70>
    pb = pCoeffs;

    i = numTaps;

    /* Perform the multiply-accumulates */
    while (i > 0U)
 80017aa:	b152      	cbz	r2, 80017c2 <arm_fir_f32+0x46>
    i = numTaps;
 80017ac:	4610      	mov	r0, r2
    pb = pCoeffs;
 80017ae:	46ce      	mov	lr, r9
    px = pState;
 80017b0:	469c      	mov	ip, r3
    {
      /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
      acc0 += *px++ * *pb++;
 80017b2:	ecfc 6a01 	vldmia	ip!, {s13}
 80017b6:	ecbe 7a01 	vldmia	lr!, {s14}
    while (i > 0U)
 80017ba:	3801      	subs	r0, #1
      acc0 += *px++ * *pb++;
 80017bc:	eee6 7a87 	vfma.f32	s15, s13, s14
    while (i > 0U)
 80017c0:	d1f7      	bne.n	80017b2 <arm_fir_f32+0x36>
  while (blkCnt > 0U)
 80017c2:	3901      	subs	r1, #1

      i--;
    }

    /* Store result in destination buffer. */
    *pDst++ = acc0;
 80017c4:	ece8 7a01 	vstmia	r8!, {s15}

    /* Advance state pointer by 1 for the next sample */
    pState = pState + 1U;
 80017c8:	f103 0304 	add.w	r3, r3, #4
  while (blkCnt > 0U)
 80017cc:	d1e7      	bne.n	800179e <arm_fir_f32+0x22>
 80017ce:	eb06 0184 	add.w	r1, r6, r4, lsl #2
  tapCnt = (numTaps - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  /* Copy remaining data */
  while (tapCnt > 0U)
 80017d2:	1e53      	subs	r3, r2, #1
 80017d4:	d005      	beq.n	80017e2 <arm_fir_f32+0x66>
  {
    *pStateCurnt++ = *pState++;
 80017d6:	f851 2b04 	ldr.w	r2, [r1], #4
 80017da:	f846 2b04 	str.w	r2, [r6], #4
  while (tapCnt > 0U)
 80017de:	3b01      	subs	r3, #1
 80017e0:	d1f9      	bne.n	80017d6 <arm_fir_f32+0x5a>

    /* Decrement loop counter */
    tapCnt--;
  }

}
 80017e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        float32_t *pState = S->pState;                 /* State pointer */
 80017e6:	4631      	mov	r1, r6
 80017e8:	e7f3      	b.n	80017d2 <arm_fir_f32+0x56>
 80017ea:	bf00      	nop
 80017ec:	00000000 	.word	0x00000000

080017f0 <arm_fir_init_f32>:
        arm_fir_instance_f32 * S,
        uint16_t numTaps,
  const float32_t * pCoeffs,
        float32_t * pState,
        uint32_t blockSize)
{
 80017f0:	b510      	push	{r4, lr}
 80017f2:	4604      	mov	r4, r0

  /* Clear state buffer. The size is always (blockSize + numTaps - 1) */
#if defined(ARM_MATH_MVEF) && !defined(ARM_MATH_AUTOVECTORIZE)
  memset(pState, 0, (numTaps + (blockSize - 1U) + blockSize) * sizeof(float32_t));
#else
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80017f4:	9802      	ldr	r0, [sp, #8]
  S->numTaps = numTaps;
 80017f6:	8021      	strh	r1, [r4, #0]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80017f8:	f100 3cff 	add.w	ip, r0, #4294967295
 80017fc:	448c      	add	ip, r1
  S->pCoeffs = pCoeffs;
 80017fe:	60a2      	str	r2, [r4, #8]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 8001800:	2100      	movs	r1, #0
 8001802:	ea4f 028c 	mov.w	r2, ip, lsl #2
 8001806:	4618      	mov	r0, r3
 8001808:	f001 f8ec 	bl	80029e4 <memset>
#endif
  /* Assign state pointer */
  S->pState = pState;
 800180c:	6060      	str	r0, [r4, #4]
}
 800180e:	bd10      	pop	{r4, pc}

08001810 <arm_max_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = (blockSize - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001810:	2901      	cmp	r1, #1
{
 8001812:	b410      	push	{r4}
  out = *pSrc++;
 8001814:	ecf0 7a01 	vldmia	r0!, {s15}
  while (blkCnt > 0U)
 8001818:	d017      	beq.n	800184a <arm_max_f32+0x3a>
 800181a:	f04f 0c01 	mov.w	ip, #1
  outIndex = 0U;
 800181e:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal = *pSrc++;
 8001820:	ecb0 7a01 	vldmia	r0!, {s14}

    /* compare for the maximum value */
    if (out < maxVal)
    {
      /* Update the maximum value and it's index */
      out = maxVal;
 8001824:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001828:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800182c:	bf48      	it	mi
 800182e:	4664      	movmi	r4, ip
  while (blkCnt > 0U)
 8001830:	f10c 0c01 	add.w	ip, ip, #1
      out = maxVal;
 8001834:	bf48      	it	mi
 8001836:	eef0 7a47 	vmovmi.f32	s15, s14
  while (blkCnt > 0U)
 800183a:	4561      	cmp	r1, ip
 800183c:	d1f0      	bne.n	8001820 <arm_max_f32+0x10>
    /* Decrement loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 800183e:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 8001842:	601c      	str	r4, [r3, #0]
}
 8001844:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001848:	4770      	bx	lr
  outIndex = 0U;
 800184a:	2400      	movs	r4, #0
  *pResult = out;
 800184c:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 8001850:	601c      	str	r4, [r3, #0]
}
 8001852:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001856:	4770      	bx	lr

08001858 <arm_copy_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001858:	b12a      	cbz	r2, 8001866 <arm_copy_f32+0xe>
  {
    /* C = A */

    /* Copy and store result in destination buffer */
    *pDst++ = *pSrc++;
 800185a:	f850 3b04 	ldr.w	r3, [r0], #4
 800185e:	f841 3b04 	str.w	r3, [r1], #4
  while (blkCnt > 0U)
 8001862:	3a01      	subs	r2, #1
 8001864:	d1f9      	bne.n	800185a <arm_copy_f32+0x2>

    /* Decrement loop counter */
    blkCnt--;
  }
}
 8001866:	4770      	bx	lr

08001868 <arm_bitreversal_32>:
  const uint16_t bitRevLen,
  const uint16_t *pBitRevTab)
{
  uint32_t a, b, i, tmp;

  for (i = 0; i < bitRevLen; )
 8001868:	b331      	cbz	r1, 80018b8 <arm_bitreversal_32+0x50>
{
 800186a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  for (i = 0; i < bitRevLen; )
 800186e:	f04f 0e00 	mov.w	lr, #0
 8001872:	f102 0802 	add.w	r8, r2, #2
  {
     a = pBitRevTab[i    ] >> 2;
 8001876:	f832 c01e 	ldrh.w	ip, [r2, lr, lsl #1]
     b = pBitRevTab[i + 1] >> 2;
 800187a:	f838 301e 	ldrh.w	r3, [r8, lr, lsl #1]
     a = pBitRevTab[i    ] >> 2;
 800187e:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
     b = pBitRevTab[i + 1] >> 2;
 8001882:	089b      	lsrs	r3, r3, #2

     //real
     tmp = pSrc[a];
 8001884:	f850 702c 	ldr.w	r7, [r0, ip, lsl #2]
     pSrc[a] = pSrc[b];
 8001888:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]
 800188c:	f840 602c 	str.w	r6, [r0, ip, lsl #2]
     tmp = pSrc[a];
 8001890:	ea4f 058c 	mov.w	r5, ip, lsl #2
     pSrc[a] = pSrc[b];
 8001894:	009c      	lsls	r4, r3, #2
     pSrc[b] = tmp;
 8001896:	f840 7023 	str.w	r7, [r0, r3, lsl #2]

     //complex
     tmp = pSrc[a+1];
 800189a:	f105 0c04 	add.w	ip, r5, #4
     pSrc[a+1] = pSrc[b+1];
 800189e:	1d23      	adds	r3, r4, #4
     pSrc[b+1] = tmp;

    i += 2;
 80018a0:	f10e 0e02 	add.w	lr, lr, #2
     tmp = pSrc[a+1];
 80018a4:	f850 500c 	ldr.w	r5, [r0, ip]
     pSrc[a+1] = pSrc[b+1];
 80018a8:	58c4      	ldr	r4, [r0, r3]
 80018aa:	f840 400c 	str.w	r4, [r0, ip]
  for (i = 0; i < bitRevLen; )
 80018ae:	458e      	cmp	lr, r1
     pSrc[b+1] = tmp;
 80018b0:	50c5      	str	r5, [r0, r3]
  for (i = 0; i < bitRevLen; )
 80018b2:	d3e0      	bcc.n	8001876 <arm_bitreversal_32+0xe>
  }
}
 80018b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop

080018bc <arm_cfft_f32>:
ARM_DSP_ATTRIBUTE void arm_cfft_f32(
  const arm_cfft_instance_f32 * S,
        float32_t * p1,
        uint8_t ifftFlag,
        uint8_t bitReverseFlag)
{
 80018bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80018c0:	ed2d 8b0a 	vpush	{d8-d12}
 80018c4:	b08f      	sub	sp, #60	@ 0x3c
  uint32_t  L = S->fftLen, l;
  float32_t invL, * pSrc;

  if (ifftFlag == 1U)
 80018c6:	2a01      	cmp	r2, #1
  uint32_t  L = S->fftLen, l;
 80018c8:	8805      	ldrh	r5, [r0, #0]
{
 80018ca:	9202      	str	r2, [sp, #8]
 80018cc:	4683      	mov	fp, r0
 80018ce:	460c      	mov	r4, r1
 80018d0:	9301      	str	r3, [sp, #4]
  if (ifftFlag == 1U)
 80018d2:	f000 8138 	beq.w	8001b46 <arm_cfft_f32+0x28a>
      *pSrc = -*pSrc;
      pSrc += 2;
    }
  }

  switch (L)
 80018d6:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 80018da:	f000 8146 	beq.w	8001b6a <arm_cfft_f32+0x2ae>
 80018de:	d835      	bhi.n	800194c <arm_cfft_f32+0x90>
 80018e0:	2d40      	cmp	r5, #64	@ 0x40
 80018e2:	f000 8124 	beq.w	8001b2e <arm_cfft_f32+0x272>
 80018e6:	d84a      	bhi.n	800197e <arm_cfft_f32+0xc2>
 80018e8:	2d10      	cmp	r5, #16
 80018ea:	d04a      	beq.n	8001982 <arm_cfft_f32+0xc6>
 80018ec:	2d20      	cmp	r5, #32
 80018ee:	f000 813c 	beq.w	8001b6a <arm_cfft_f32+0x2ae>
  case 4096:
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
    break;
  }

  if ( bitReverseFlag )
 80018f2:	9b01      	ldr	r3, [sp, #4]
 80018f4:	b133      	cbz	r3, 8001904 <arm_cfft_f32+0x48>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 80018f6:	f8db 2008 	ldr.w	r2, [fp, #8]
 80018fa:	f8bb 100c 	ldrh.w	r1, [fp, #12]
 80018fe:	4620      	mov	r0, r4
 8001900:	f7ff ffb2 	bl	8001868 <arm_bitreversal_32>

  if (ifftFlag == 1U)
 8001904:	9b02      	ldr	r3, [sp, #8]
 8001906:	2b01      	cmp	r3, #1
 8001908:	d134      	bne.n	8001974 <arm_cfft_f32+0xb8>
  {
    invL = 1.0f / (float32_t)L;
 800190a:	ee07 5a90 	vmov	s15, r5
 800190e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8001912:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8001916:	eec7 6a27 	vdiv.f32	s13, s14, s15

    /* Conjugate and scale output data */
    pSrc = p1;
    for (l= 0; l < L; l++)
 800191a:	b35d      	cbz	r5, 8001974 <arm_cfft_f32+0xb8>
 800191c:	3408      	adds	r4, #8
 800191e:	2300      	movs	r3, #0
 8001920:	3301      	adds	r3, #1
 8001922:	429d      	cmp	r5, r3
 8001924:	f104 0408 	add.w	r4, r4, #8
    {
      *pSrc++ *=   invL ;
 8001928:	ed14 7a04 	vldr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 800192c:	ed54 7a03 	vldr	s15, [r4, #-12]
      *pSrc++ *=   invL ;
 8001930:	ee27 7a26 	vmul.f32	s14, s14, s13
      *pSrc    = -(*pSrc) * invL;
 8001934:	ee67 7ae6 	vnmul.f32	s15, s15, s13
      *pSrc++ *=   invL ;
 8001938:	ed04 7a04 	vstr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 800193c:	ed44 7a03 	vstr	s15, [r4, #-12]
    for (l= 0; l < L; l++)
 8001940:	d1ee      	bne.n	8001920 <arm_cfft_f32+0x64>
      pSrc++;
    }
  }
}
 8001942:	b00f      	add	sp, #60	@ 0x3c
 8001944:	ecbd 8b0a 	vpop	{d8-d12}
 8001948:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 800194c:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
 8001950:	f000 810b 	beq.w	8001b6a <arm_cfft_f32+0x2ae>
 8001954:	f200 80e7 	bhi.w	8001b26 <arm_cfft_f32+0x26a>
 8001958:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
 800195c:	f000 80e7 	beq.w	8001b2e <arm_cfft_f32+0x272>
 8001960:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
 8001964:	d00d      	beq.n	8001982 <arm_cfft_f32+0xc6>
  if ( bitReverseFlag )
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	2b00      	cmp	r3, #0
 800196a:	d1c4      	bne.n	80018f6 <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 800196c:	9b02      	ldr	r3, [sp, #8]
 800196e:	2b01      	cmp	r3, #1
 8001970:	f000 80d0 	beq.w	8001b14 <arm_cfft_f32+0x258>
}
 8001974:	b00f      	add	sp, #60	@ 0x3c
 8001976:	ecbd 8b0a 	vpop	{d8-d12}
 800197a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 800197e:	2d80      	cmp	r5, #128	@ 0x80
 8001980:	d1f1      	bne.n	8001966 <arm_cfft_f32+0xaa>
  L >>= 1;
 8001982:	0869      	lsrs	r1, r5, #1
  const float32_t * tw = (float32_t *) S->pTwiddle;
 8001984:	f8db 2004 	ldr.w	r2, [fp, #4]
  pMid1 = p1 + L;
 8001988:	0088      	lsls	r0, r1, #2
 800198a:	3010      	adds	r0, #16
  float32_t * p2 = p1 + L;
 800198c:	eb04 0685 	add.w	r6, r4, r5, lsl #2
  for (l = L >> 2; l > 0; l-- )
 8001990:	f104 0310 	add.w	r3, r4, #16
 8001994:	ea4f 0ed5 	mov.w	lr, r5, lsr #3
 8001998:	eb04 0c00 	add.w	ip, r4, r0
 800199c:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 80019a0:	4430      	add	r0, r6
 80019a2:	f102 0810 	add.w	r8, r2, #16
 80019a6:	f106 0710 	add.w	r7, r6, #16
    t2[0] = p2[0];
 80019aa:	ed17 1a04 	vldr	s2, [r7, #-16]
    t2[1] = p2[1];
 80019ae:	ed57 1a03 	vldr	s3, [r7, #-12]
    t4[0] = pMid2[0];
 80019b2:	ed10 5a04 	vldr	s10, [r0, #-16]
    t4[1] = pMid2[1];
 80019b6:	ed50 5a03 	vldr	s11, [r0, #-12]
    t2[2] = p2[2];
 80019ba:	ed57 8a02 	vldr	s17, [r7, #-8]
    t2[3] = p2[3];
 80019be:	ed17 8a01 	vldr	s16, [r7, #-4]
    t4[2] = pMid2[2];
 80019c2:	ed10 7a02 	vldr	s14, [r0, #-8]
    t4[3] = pMid2[3];
 80019c6:	ed50 7a01 	vldr	s15, [r0, #-4]
    t1[0] = p1[0];
 80019ca:	ed13 4a04 	vldr	s8, [r3, #-16]
    t1[1] = p1[1];
 80019ce:	ed53 4a03 	vldr	s9, [r3, #-12]
    t1[2] = p1[2];
 80019d2:	ed13 6a02 	vldr	s12, [r3, #-8]
    t1[3] = p1[3];
 80019d6:	ed53 6a01 	vldr	s13, [r3, #-4]
    t3[0] = pMid1[0];
 80019da:	ed1c 2a04 	vldr	s4, [ip, #-16]
    t3[1] = pMid1[1];
 80019de:	ed5c 2a03 	vldr	s5, [ip, #-12]
    t3[2] = pMid1[2];
 80019e2:	ed1c 0a02 	vldr	s0, [ip, #-8]
    t3[3] = pMid1[3];
 80019e6:	ed5c 0a01 	vldr	s1, [ip, #-4]
    *p1++ = t1[0] + t2[0];
 80019ea:	ee74 ba01 	vadd.f32	s23, s8, s2
    *p1++ = t1[1] + t2[1];
 80019ee:	ee34 baa1 	vadd.f32	s22, s9, s3
    *pMid1++ = t3[0] + t4[0];
 80019f2:	ee72 9a05 	vadd.f32	s19, s4, s10
    *pMid1++ = t3[1] + t4[1];
 80019f6:	ee32 9aa5 	vadd.f32	s18, s5, s11
    *pMid1++ = t3[2] + t4[2];
 80019fa:	ee30 3a07 	vadd.f32	s6, s0, s14
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 80019fe:	ee70 3aa7 	vadd.f32	s7, s1, s15
    *p1++ = t1[2] + t2[2];
 8001a02:	ee76 aa28 	vadd.f32	s21, s12, s17
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001a06:	ee36 aa88 	vadd.f32	s20, s13, s16
    *p1++ = t1[0] + t2[0];
 8001a0a:	ed43 ba04 	vstr	s23, [r3, #-16]
    *p1++ = t1[1] + t2[1];
 8001a0e:	ed03 ba03 	vstr	s22, [r3, #-12]
    *p1++ = t1[2] + t2[2];
 8001a12:	ed43 aa02 	vstr	s21, [r3, #-8]
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001a16:	ed03 aa01 	vstr	s20, [r3, #-4]
    *pMid1++ = t3[0] + t4[0];
 8001a1a:	ed4c 9a04 	vstr	s19, [ip, #-16]
    *pMid1++ = t3[1] + t4[1];
 8001a1e:	ed0c 9a03 	vstr	s18, [ip, #-12]
    *pMid1++ = t3[2] + t4[2];
 8001a22:	ed0c 3a02 	vstr	s6, [ip, #-8]
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 8001a26:	ed4c 3a01 	vstr	s7, [ip, #-4]
    twI = *tw++;
 8001a2a:	ed58 3a03 	vldr	s7, [r8, #-12]
    twR = *tw++;
 8001a2e:	ed18 3a04 	vldr	s6, [r8, #-16]
    t2[0] = t1[0] - t2[0];
 8001a32:	ee34 4a41 	vsub.f32	s8, s8, s2
    t2[1] = t1[1] - t2[1];
 8001a36:	ee74 4ae1 	vsub.f32	s9, s9, s3
    t4[1] = t4[1] - t3[1];
 8001a3a:	ee75 5ae2 	vsub.f32	s11, s11, s5
    t4[0] = t4[0] - t3[0];
 8001a3e:	ee35 5a42 	vsub.f32	s10, s10, s4
    m1 = t2[1] * twI;
 8001a42:	ee24 1aa3 	vmul.f32	s2, s9, s7
    *p2++ = m2 - m3;
 8001a46:	ee63 1ac4 	vnmul.f32	s3, s7, s8
    *pMid2++ = m0 - m1;
 8001a4a:	ee23 2a65 	vnmul.f32	s4, s6, s11
    *p2++ = m0 + m1;
 8001a4e:	eea4 1a03 	vfma.f32	s2, s8, s6
  for (l = L >> 2; l > 0; l-- )
 8001a52:	3310      	adds	r3, #16
 8001a54:	459e      	cmp	lr, r3
    m3 = t4[0] * twR;
 8001a56:	ee65 2a03 	vmul.f32	s5, s10, s6
    *p2++ = m2 - m3;
 8001a5a:	eeb0 4a61 	vmov.f32	s8, s3
 8001a5e:	eea4 4a83 	vfma.f32	s8, s9, s6
  for (l = L >> 2; l > 0; l-- )
 8001a62:	f10c 0c10 	add.w	ip, ip, #16
 8001a66:	f108 0810 	add.w	r8, r8, #16
    *pMid2++ = m0 - m1;
 8001a6a:	eef0 4a42 	vmov.f32	s9, s4
 8001a6e:	eee5 4a23 	vfma.f32	s9, s10, s7
  for (l = L >> 2; l > 0; l-- )
 8001a72:	f107 0710 	add.w	r7, r7, #16
 8001a76:	f100 0010 	add.w	r0, r0, #16
    *pMid2++ = m2 + m3;
 8001a7a:	eeb0 5a62 	vmov.f32	s10, s5
 8001a7e:	eea5 5aa3 	vfma.f32	s10, s11, s7
    *p2++ = m2 - m3;
 8001a82:	ed07 4a07 	vstr	s8, [r7, #-28]	@ 0xffffffe4
    *p2++ = m0 + m1;
 8001a86:	ed07 1a08 	vstr	s2, [r7, #-32]	@ 0xffffffe0
    *pMid2++ = m0 - m1;
 8001a8a:	ed40 4a08 	vstr	s9, [r0, #-32]	@ 0xffffffe0
    *pMid2++ = m2 + m3;
 8001a8e:	ed00 5a07 	vstr	s10, [r0, #-28]	@ 0xffffffe4
    twI = *tw++;
 8001a92:	ed58 5a05 	vldr	s11, [r8, #-20]	@ 0xffffffec
    twR = *tw++;
 8001a96:	ed18 5a06 	vldr	s10, [r8, #-24]	@ 0xffffffe8
    t2[2] = t1[2] - t2[2];
 8001a9a:	ee36 6a68 	vsub.f32	s12, s12, s17
    t2[3] = t1[3] - t2[3];    /* for col 2 */
 8001a9e:	ee76 6ac8 	vsub.f32	s13, s13, s16
    t4[3] = t4[3] - t3[3];    /* for col 2 */
 8001aa2:	ee77 7ae0 	vsub.f32	s15, s15, s1
    t4[2] = t4[2] - t3[2];
 8001aa6:	ee37 7a40 	vsub.f32	s14, s14, s0
    m1 = t2[3] * twI;
 8001aaa:	ee26 3aa5 	vmul.f32	s6, s13, s11
    *p2++ = m2 - m3;
 8001aae:	ee65 3ac6 	vnmul.f32	s7, s11, s12
    *pMid2++ = m0 - m1;
 8001ab2:	ee25 4a67 	vnmul.f32	s8, s10, s15
    *p2++ = m0 + m1;
 8001ab6:	eea6 3a05 	vfma.f32	s6, s12, s10
    m3 = t4[2] * twR;
 8001aba:	ee67 4a05 	vmul.f32	s9, s14, s10
    *p2++ = m2 - m3;
 8001abe:	eeb0 6a63 	vmov.f32	s12, s7
 8001ac2:	eea6 6a85 	vfma.f32	s12, s13, s10
    *pMid2++ = m0 - m1;
 8001ac6:	eef0 6a44 	vmov.f32	s13, s8
 8001aca:	eee7 6a25 	vfma.f32	s13, s14, s11
    *pMid2++ = m2 + m3;
 8001ace:	eeb0 7a64 	vmov.f32	s14, s9
 8001ad2:	eea7 7aa5 	vfma.f32	s14, s15, s11
    *p2++ = m0 + m1;
 8001ad6:	ed07 3a06 	vstr	s6, [r7, #-24]	@ 0xffffffe8
    *p2++ = m2 - m3;
 8001ada:	ed07 6a05 	vstr	s12, [r7, #-20]	@ 0xffffffec
    *pMid2++ = m0 - m1;
 8001ade:	ed40 6a06 	vstr	s13, [r0, #-24]	@ 0xffffffe8
    *pMid2++ = m2 + m3;
 8001ae2:	ed00 7a05 	vstr	s14, [r0, #-20]	@ 0xffffffec
  for (l = L >> 2; l > 0; l-- )
 8001ae6:	f47f af60 	bne.w	80019aa <arm_cfft_f32+0xee>
  arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 2U);
 8001aea:	b28f      	uxth	r7, r1
 8001aec:	2302      	movs	r3, #2
 8001aee:	4639      	mov	r1, r7
 8001af0:	4620      	mov	r0, r4
 8001af2:	f000 fa79 	bl	8001fe8 <arm_radix8_butterfly_f32>
  arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 2U);
 8001af6:	2302      	movs	r3, #2
 8001af8:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001afc:	4639      	mov	r1, r7
 8001afe:	4630      	mov	r0, r6
 8001b00:	f000 fa72 	bl	8001fe8 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	2b00      	cmp	r3, #0
 8001b08:	f47f aef5 	bne.w	80018f6 <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 8001b0c:	9b02      	ldr	r3, [sp, #8]
 8001b0e:	2b01      	cmp	r3, #1
 8001b10:	f47f af30 	bne.w	8001974 <arm_cfft_f32+0xb8>
    invL = 1.0f / (float32_t)L;
 8001b14:	ee07 5a90 	vmov	s15, r5
 8001b18:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8001b1c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8001b20:	eec7 6a27 	vdiv.f32	s13, s14, s15
    for (l= 0; l < L; l++)
 8001b24:	e6fa      	b.n	800191c <arm_cfft_f32+0x60>
  switch (L)
 8001b26:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 8001b2a:	f47f af1c 	bne.w	8001966 <arm_cfft_f32+0xaa>
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
 8001b2e:	2301      	movs	r3, #1
 8001b30:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001b34:	4629      	mov	r1, r5
 8001b36:	4620      	mov	r0, r4
 8001b38:	f000 fa56 	bl	8001fe8 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001b3c:	9b01      	ldr	r3, [sp, #4]
 8001b3e:	2b00      	cmp	r3, #0
 8001b40:	f43f af14 	beq.w	800196c <arm_cfft_f32+0xb0>
 8001b44:	e6d7      	b.n	80018f6 <arm_cfft_f32+0x3a>
    for (l = 0; l < L; l++)
 8001b46:	2d00      	cmp	r5, #0
 8001b48:	f000 8233 	beq.w	8001fb2 <arm_cfft_f32+0x6f6>
 8001b4c:	f101 030c 	add.w	r3, r1, #12
 8001b50:	2200      	movs	r2, #0
      *pSrc = -*pSrc;
 8001b52:	ed53 7a02 	vldr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001b56:	3201      	adds	r2, #1
      *pSrc = -*pSrc;
 8001b58:	eef1 7a67 	vneg.f32	s15, s15
    for (l = 0; l < L; l++)
 8001b5c:	4295      	cmp	r5, r2
      *pSrc = -*pSrc;
 8001b5e:	ed43 7a02 	vstr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001b62:	f103 0308 	add.w	r3, r3, #8
 8001b66:	d1f4      	bne.n	8001b52 <arm_cfft_f32+0x296>
 8001b68:	e6b5      	b.n	80018d6 <arm_cfft_f32+0x1a>
    uint32_t    L  = S->fftLen >> 1;
 8001b6a:	086b      	lsrs	r3, r5, #1
    float32_t * p3 = p2 + L;
 8001b6c:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    p1ap3_0 = p1[0] + p3[0];
 8001b70:	ed91 6a00 	vldr	s12, [r1]
    p1ap3_1 = p1[1] + p3[1];
 8001b74:	edd1 5a01 	vldr	s11, [r1, #4]
    p1ap3_0 = p1[0] + p3[0];
 8001b78:	ed94 7a00 	vldr	s14, [r4]
    p1ap3_1 = p1[1] + p3[1];
 8001b7c:	edd4 7a01 	vldr	s15, [r4, #4]
    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8001b80:	f8db 6004 	ldr.w	r6, [fp, #4]
 8001b84:	9606      	str	r6, [sp, #24]
    float32_t * p4 = p3 + L;
 8001b86:	eb01 0283 	add.w	r2, r1, r3, lsl #2
    p1ap3_0 = p1[0] + p3[0];
 8001b8a:	ee77 6a06 	vadd.f32	s13, s14, s12
    p1sp3_0 = p1[0] - p3[0];
 8001b8e:	ee37 7a46 	vsub.f32	s14, s14, s12
    p1ap3_1 = p1[1] + p3[1];
 8001b92:	ee37 6aa5 	vadd.f32	s12, s15, s11
    p1sp3_1 = p1[1] - p3[1];
 8001b96:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001b9a:	edd2 5a00 	vldr	s11, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001b9e:	ed92 2a01 	vldr	s4, [r2, #4]
 8001ba2:	9203      	str	r2, [sp, #12]
    float32_t * p2 = p1 + L;
 8001ba4:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001ba8:	ed90 5a00 	vldr	s10, [r0]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001bac:	edd0 2a01 	vldr	s5, [r0, #4]
    float32_t * p3 = p2 + L;
 8001bb0:	9105      	str	r1, [sp, #20]
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001bb2:	ee36 3aa5 	vadd.f32	s6, s13, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001bb6:	ee77 3aa5 	vadd.f32	s7, s15, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001bba:	ee33 3a05 	vadd.f32	s6, s6, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001bbe:	ee77 4a02 	vadd.f32	s9, s14, s4
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001bc2:	ed84 3a00 	vstr	s6, [r4]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001bc6:	ee76 6ac5 	vsub.f32	s13, s13, s10
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001bca:	ee77 7a85 	vadd.f32	s15, s15, s10
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001bce:	ee73 3ac5 	vsub.f32	s7, s7, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001bd2:	ee34 5ae2 	vsub.f32	s10, s9, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001bd6:	edd2 4a01 	vldr	s9, [r2, #4]
    float32_t * p2 = p1 + L;
 8001bda:	9004      	str	r0, [sp, #16]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001bdc:	ee36 4a62 	vsub.f32	s8, s12, s5
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001be0:	ee76 6ae5 	vsub.f32	s13, s13, s11
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001be4:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001be8:	ee37 7a22 	vadd.f32	s14, s14, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001bec:	edd0 5a01 	vldr	s11, [r0, #4]
 8001bf0:	950d      	str	r5, [sp, #52]	@ 0x34
 8001bf2:	ee36 6a24 	vadd.f32	s12, s12, s9
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001bf6:	ee37 7a42 	vsub.f32	s14, s14, s4
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001bfa:	ee34 4a42 	vsub.f32	s8, s8, s4
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001bfe:	ee36 6a25 	vadd.f32	s12, s12, s11
    L >>= 1;
 8001c02:	085f      	lsrs	r7, r3, #1
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001c04:	ed84 6a01 	vstr	s12, [r4, #4]
 8001c08:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *p2++ = t2[0];
 8001c0c:	ed80 7a00 	vstr	s14, [r0]
    *p2++ = t2[1];
 8001c10:	edc0 3a01 	vstr	s7, [r0, #4]
    *p3++ = t3[0];
 8001c14:	edc1 6a00 	vstr	s13, [r1]
    *p3++ = t3[1];
 8001c18:	ed81 4a01 	vstr	s8, [r1, #4]
    *p4++ = t4[0];
 8001c1c:	ed82 5a00 	vstr	s10, [r2]
    *p4++ = t4[1];
 8001c20:	edc2 7a01 	vstr	s15, [r2, #4]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001c24:	1eba      	subs	r2, r7, #2
    L >>= 1;
 8001c26:	9708      	str	r7, [sp, #32]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001c28:	0857      	lsrs	r7, r2, #1
 8001c2a:	9707      	str	r7, [sp, #28]
 8001c2c:	3b0c      	subs	r3, #12
 8001c2e:	930b      	str	r3, [sp, #44]	@ 0x2c
 8001c30:	f106 0820 	add.w	r8, r6, #32
    tw3 += twMod3;
 8001c34:	f106 0310 	add.w	r3, r6, #16
 8001c38:	f106 0930 	add.w	r9, r6, #48	@ 0x30
 8001c3c:	9e07      	ldr	r6, [sp, #28]
 8001c3e:	9309      	str	r3, [sp, #36]	@ 0x24
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001c40:	f1a0 0c0c 	sub.w	ip, r0, #12
 8001c44:	469a      	mov	sl, r3
 8001c46:	0133      	lsls	r3, r6, #4
 8001c48:	460a      	mov	r2, r1
 8001c4a:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
 8001c4e:	930a      	str	r3, [sp, #40]	@ 0x28
 8001c50:	eb08 1306 	add.w	r3, r8, r6, lsl #4
 8001c54:	f102 0e10 	add.w	lr, r2, #16
 8001c58:	461d      	mov	r5, r3
 8001c5a:	9a03      	ldr	r2, [sp, #12]
 8001c5c:	e9dd 360b 	ldrd	r3, r6, [sp, #44]	@ 0x2c
 8001c60:	f1a2 0c0c 	sub.w	ip, r2, #12
 8001c64:	f104 0710 	add.w	r7, r4, #16
 8001c68:	3010      	adds	r0, #16
 8001c6a:	390c      	subs	r1, #12
 8001c6c:	3210      	adds	r2, #16
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001c6e:	ed12 8a02 	vldr	s16, [r2, #-8]
 8001c72:	ed50 2a02 	vldr	s5, [r0, #-8]
      p1ap3_0 = p1[0] + p3[0];
 8001c76:	ed1e 6a02 	vldr	s12, [lr, #-8]
 8001c7a:	ed17 3a02 	vldr	s6, [r7, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001c7e:	ed12 2a01 	vldr	s4, [r2, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001c82:	ed1e 7a01 	vldr	s14, [lr, #-4]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001c86:	ed50 aa01 	vldr	s21, [r0, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001c8a:	ed57 6a01 	vldr	s13, [r7, #-4]
      p1ap3_0 = p1[0] + p3[0];
 8001c8e:	ee33 4a06 	vadd.f32	s8, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001c92:	ee72 7a88 	vadd.f32	s15, s5, s16
      p1ap3_1 = p1[1] + p3[1];
 8001c96:	ee76 4a87 	vadd.f32	s9, s13, s14
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001c9a:	ee77 7a84 	vadd.f32	s15, s15, s8
      p1sp3_0 = p1[0] - p3[0];
 8001c9e:	ee33 3a46 	vsub.f32	s6, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001ca2:	ed47 7a02 	vstr	s15, [r7, #-8]
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001ca6:	ed52 5a01 	vldr	s11, [r2, #-4]
 8001caa:	ed50 7a01 	vldr	s15, [r0, #-4]
 8001cae:	ee77 7aa5 	vadd.f32	s15, s15, s11
      p1sp3_1 = p1[1] - p3[1];
 8001cb2:	ee76 6ac7 	vsub.f32	s13, s13, s14
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001cb6:	ee77 7aa4 	vadd.f32	s15, s15, s9
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001cba:	ee73 9a42 	vsub.f32	s19, s6, s4
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001cbe:	ed47 7a01 	vstr	s15, [r7, #-4]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001cc2:	edd3 ba02 	vldr	s23, [r3, #8]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001cc6:	ed9c 6a02 	vldr	s12, [ip, #8]
 8001cca:	edd6 1a02 	vldr	s3, [r6, #8]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001cce:	edd1 5a02 	vldr	s11, [r1, #8]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001cd2:	ed93 ba01 	vldr	s22, [r3, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001cd6:	ed9c 1a01 	vldr	s2, [ip, #4]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001cda:	ed91 0a01 	vldr	s0, [r1, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001cde:	ed96 aa01 	vldr	s20, [r6, #4]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001ce2:	ee31 ca86 	vadd.f32	s24, s3, s12
 8001ce6:	ee75 0aab 	vadd.f32	s1, s11, s23
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001cea:	ee3a 5a01 	vadd.f32	s10, s20, s2
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001cee:	ee70 7a8c 	vadd.f32	s15, s1, s24
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001cf2:	ee36 9ae2 	vsub.f32	s18, s13, s5
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001cf6:	edc6 7a02 	vstr	s15, [r6, #8]
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001cfa:	edd3 8a01 	vldr	s17, [r3, #4]
 8001cfe:	edd1 7a01 	vldr	s15, [r1, #4]
 8001d02:	ee77 7aa8 	vadd.f32	s15, s15, s17
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001d06:	ee35 7aeb 	vsub.f32	s14, s11, s23
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001d0a:	ee77 7a85 	vadd.f32	s15, s15, s10
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001d0e:	ee39 9a08 	vadd.f32	s18, s18, s16
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001d12:	edc6 7a01 	vstr	s15, [r6, #4]
      twI = *tw2++;
 8001d16:	ed5a 8a01 	vldr	s17, [sl, #-4]
      twR = *tw2++;
 8001d1a:	ed5a 7a02 	vldr	s15, [sl, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001d1e:	ee79 9aaa 	vadd.f32	s19, s19, s21
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001d22:	ee7c 5a65 	vsub.f32	s11, s24, s11
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001d26:	ee71 3a8b 	vadd.f32	s7, s3, s22
      m0 = -t3[3] * twR;
 8001d2a:	ee70 0acc 	vsub.f32	s1, s1, s24
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001d2e:	ee75 5aeb 	vsub.f32	s11, s11, s23
      m1 = t2[1] * twI;
 8001d32:	ee29 ca28 	vmul.f32	s24, s18, s17
      *p2++ = m2 - m3;
 8001d36:	ee68 bae9 	vnmul.f32	s23, s17, s19
      *p2++ = m0 + m1;
 8001d3a:	eea9 caa7 	vfma.f32	s24, s19, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d3e:	f108 0810 	add.w	r8, r8, #16
 8001d42:	3708      	adds	r7, #8
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001d44:	ee73 3ac6 	vsub.f32	s7, s7, s12
      *p2++ = m2 - m3;
 8001d48:	eef0 9a6b 	vmov.f32	s19, s23
 8001d4c:	eee9 9a27 	vfma.f32	s19, s18, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d50:	3e08      	subs	r6, #8
 8001d52:	f10a 0a08 	add.w	sl, sl, #8
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001d56:	ee37 9a41 	vsub.f32	s18, s14, s2
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001d5a:	ee73 3ac0 	vsub.f32	s7, s7, s0
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001d5e:	ee35 5a40 	vsub.f32	s10, s10, s0
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001d62:	ee39 9a0a 	vadd.f32	s18, s18, s20
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001d66:	ee35 5a4b 	vsub.f32	s10, s10, s22
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001d6a:	ee36 6a0b 	vadd.f32	s12, s12, s22
      m3 = t2[3] * twR;
 8001d6e:	ee23 baa7 	vmul.f32	s22, s7, s15
      *pEnd2-- = m0 - m1;
 8001d72:	ee67 7ac9 	vnmul.f32	s15, s15, s18
      *p2++ = m2 - m3;
 8001d76:	ed40 9a01 	vstr	s19, [r0, #-4]
      *pEnd2-- = m2 + m3;
 8001d7a:	eef0 9a4b 	vmov.f32	s19, s22
      *pEnd2-- = m0 - m1;
 8001d7e:	eee3 7aa8 	vfma.f32	s15, s7, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d82:	3008      	adds	r0, #8
 8001d84:	3908      	subs	r1, #8
      *pEnd2-- = m2 + m3;
 8001d86:	eee9 9a28 	vfma.f32	s19, s18, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d8a:	f10e 0e08 	add.w	lr, lr, #8
 8001d8e:	f1ac 0c08 	sub.w	ip, ip, #8
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001d92:	ee34 4a62 	vsub.f32	s8, s8, s5
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001d96:	ee74 4aea 	vsub.f32	s9, s9, s21
      *p2++ = m0 + m1;
 8001d9a:	ed00 ca04 	vstr	s24, [r0, #-16]
      *pEnd2-- = m2 + m3;
 8001d9e:	edc1 9a03 	vstr	s19, [r1, #12]
      *pEnd2-- = m0 - m1;
 8001da2:	edc1 7a04 	vstr	s15, [r1, #16]
      twI = tw3[1];
 8001da6:	ed58 7a07 	vldr	s15, [r8, #-28]	@ 0xffffffe4
      twR = tw3[0];
 8001daa:	ed58 3a08 	vldr	s7, [r8, #-32]	@ 0xffffffe0
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001dae:	ee34 4a48 	vsub.f32	s8, s8, s16
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001db2:	ee74 4ac2 	vsub.f32	s9, s9, s4
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001db6:	ee76 6ac8 	vsub.f32	s13, s13, s16
      m1 = t3[1] * twI;
 8001dba:	ee64 8aa7 	vmul.f32	s17, s9, s15
      *p3++ = m2 - m3;
 8001dbe:	ee27 8ac4 	vnmul.f32	s16, s15, s8
      m3 =  t3[3] * twI;
 8001dc2:	ee65 5aa7 	vmul.f32	s11, s11, s15
      *pEnd3-- = m0 - m1;
 8001dc6:	ee67 7ac5 	vnmul.f32	s15, s15, s10
      *p3++ = m0 + m1;
 8001dca:	eee4 8a23 	vfma.f32	s17, s8, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001dce:	4545      	cmp	r5, r8
 8001dd0:	f109 0918 	add.w	r9, r9, #24
      *p3++ = m2 - m3;
 8001dd4:	eeb0 4a48 	vmov.f32	s8, s16
 8001dd8:	eea4 4aa3 	vfma.f32	s8, s9, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001ddc:	f102 0208 	add.w	r2, r2, #8
 8001de0:	f1a3 0308 	sub.w	r3, r3, #8
      *pEnd3-- = m3 - m2;
 8001de4:	eee5 5a63 	vfms.f32	s11, s10, s7
      *pEnd3-- = m0 - m1;
 8001de8:	eee3 7aa0 	vfma.f32	s15, s7, s1
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 8001dec:	ee37 7a4a 	vsub.f32	s14, s14, s20
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001df0:	ee33 3a6a 	vsub.f32	s6, s6, s21
      *p3++ = m0 + m1;
 8001df4:	ed4e 8a04 	vstr	s17, [lr, #-16]
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001df8:	ee36 6a40 	vsub.f32	s12, s12, s0
      *p3++ = m2 - m3;
 8001dfc:	ed0e 4a03 	vstr	s8, [lr, #-12]
      *pEnd3-- = m0 - m1;
 8001e00:	edcc 7a04 	vstr	s15, [ip, #16]
      *pEnd3-- = m3 - m2;
 8001e04:	edcc 5a03 	vstr	s11, [ip, #12]
      twR = tw4[0];
 8001e08:	ed19 5a0c 	vldr	s10, [r9, #-48]	@ 0xffffffd0
      twI = tw4[1];
 8001e0c:	ed59 5a0b 	vldr	s11, [r9, #-44]	@ 0xffffffd4
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 8001e10:	ee77 7a01 	vadd.f32	s15, s14, s2
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001e14:	ee33 3a02 	vadd.f32	s6, s6, s4
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001e18:	ee36 7a61 	vsub.f32	s14, s12, s3
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001e1c:	ee76 6aa2 	vadd.f32	s13, s13, s5
      *p4++ = m2 - m3;
 8001e20:	ee25 4ac3 	vnmul.f32	s8, s11, s6
      *pEnd4-- = m0 - m1;
 8001e24:	ee65 4a67 	vnmul.f32	s9, s10, s15
      m3 = t4[3] * twR;
 8001e28:	ee27 6a05 	vmul.f32	s12, s14, s10
      *p4++ = m2 - m3;
 8001e2c:	eea6 4a85 	vfma.f32	s8, s13, s10
      m1 = t4[1] * twI;
 8001e30:	ee66 3aa5 	vmul.f32	s7, s13, s11
      *pEnd4-- = m0 - m1;
 8001e34:	eef0 6a64 	vmov.f32	s13, s9
 8001e38:	eee7 6a25 	vfma.f32	s13, s14, s11
      *pEnd4-- = m2 + m3;
 8001e3c:	eeb0 7a46 	vmov.f32	s14, s12
      *p4++ = m0 + m1;
 8001e40:	eee3 3a05 	vfma.f32	s7, s6, s10
      *pEnd4-- = m2 + m3;
 8001e44:	eea7 7aa5 	vfma.f32	s14, s15, s11
      *p4++ = m0 + m1;
 8001e48:	ed42 3a04 	vstr	s7, [r2, #-16]
      *p4++ = m2 - m3;
 8001e4c:	ed02 4a03 	vstr	s8, [r2, #-12]
      *pEnd4-- = m0 - m1;
 8001e50:	edc3 6a04 	vstr	s13, [r3, #16]
      *pEnd4-- = m2 + m3;
 8001e54:	ed83 7a03 	vstr	s14, [r3, #12]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e58:	f47f af09 	bne.w	8001c6e <arm_cfft_f32+0x3b2>
 8001e5c:	e9dd 0309 	ldrd	r0, r3, [sp, #36]	@ 0x24
 8001e60:	4418      	add	r0, r3
 8001e62:	9b07      	ldr	r3, [sp, #28]
 8001e64:	9f05      	ldr	r7, [sp, #20]
 8001e66:	9906      	ldr	r1, [sp, #24]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001e68:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 8001e6c:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8001e6e:	00da      	lsls	r2, r3, #3
 8001e70:	3208      	adds	r2, #8
 8001e72:	eb07 0c02 	add.w	ip, r7, r2
 8001e76:	eb04 0e02 	add.w	lr, r4, r2
 8001e7a:	9f03      	ldr	r7, [sp, #12]
    p1ap3_0 = p1[0] + p3[0];
 8001e7c:	ed9c 5a00 	vldr	s10, [ip]
 8001e80:	edde 7a00 	vldr	s15, [lr]
    p1ap3_1 = p1[1] + p3[1];
 8001e84:	eddc 5a01 	vldr	s11, [ip, #4]
 8001e88:	ed9e 7a01 	vldr	s14, [lr, #4]
 8001e8c:	3301      	adds	r3, #1
 8001e8e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8001e92:	eb07 0802 	add.w	r8, r7, r2
    p1ap3_0 = p1[0] + p3[0];
 8001e96:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8001e9a:	9904      	ldr	r1, [sp, #16]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001e9c:	edd8 4a00 	vldr	s9, [r8]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001ea0:	edd8 2a01 	vldr	s5, [r8, #4]
    p1ap3_0 = p1[0] + p3[0];
 8001ea4:	ee77 6a85 	vadd.f32	s13, s15, s10
    p1sp3_0 = p1[0] - p3[0];
 8001ea8:	188f      	adds	r7, r1, r2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001eaa:	ed97 4a00 	vldr	s8, [r7]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001eae:	ed97 3a01 	vldr	s6, [r7, #4]
 8001eb2:	9906      	ldr	r1, [sp, #24]
    p1ap3_1 = p1[1] + p3[1];
 8001eb4:	ee37 6a25 	vadd.f32	s12, s14, s11
    p1sp3_1 = p1[1] - p3[1];
 8001eb8:	ee37 7a65 	vsub.f32	s14, s14, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001ebc:	ee76 5aa4 	vadd.f32	s11, s13, s9
    p1sp3_0 = p1[0] - p3[0];
 8001ec0:	ee77 7ac5 	vsub.f32	s15, s15, s10
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001ec4:	ee75 5a84 	vadd.f32	s11, s11, s8
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001ec8:	ee37 5aa2 	vadd.f32	s10, s15, s5
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001ecc:	edce 5a00 	vstr	s11, [lr]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001ed0:	edd8 5a01 	vldr	s11, [r8, #4]
 8001ed4:	ed97 2a01 	vldr	s4, [r7, #4]
 8001ed8:	ee76 5a25 	vadd.f32	s11, s12, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001edc:	ee77 3a44 	vsub.f32	s7, s14, s8
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001ee0:	ee75 5a82 	vadd.f32	s11, s11, s4
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001ee4:	ee77 7a83 	vadd.f32	s15, s15, s6
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001ee8:	edce 5a01 	vstr	s11, [lr, #4]
 8001eec:	440a      	add	r2, r1
    twI = tw2[1];
 8001eee:	edd2 5a01 	vldr	s11, [r2, #4]
    twR = tw2[0];
 8001ef2:	edd2 1a00 	vldr	s3, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001ef6:	ee77 7ae2 	vsub.f32	s15, s15, s5
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001efa:	ee73 3aa4 	vadd.f32	s7, s7, s9
    *p2++ = m2 - m3;
 8001efe:	ee25 2ae7 	vnmul.f32	s4, s11, s15
    m1 = t2[1] * twI;
 8001f02:	ee63 5aa5 	vmul.f32	s11, s7, s11
    *p2++ = m2 - m3;
 8001f06:	eea3 2aa1 	vfma.f32	s4, s7, s3
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001f0a:	460a      	mov	r2, r1
 8001f0c:	4631      	mov	r1, r6
    *p2++ = m0 + m1;
 8001f0e:	eee7 5aa1 	vfma.f32	s11, s15, s3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001f12:	ee76 7ac4 	vsub.f32	s15, s13, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001f16:	ee76 6a43 	vsub.f32	s13, s12, s6
    *p2++ = m2 - m3;
 8001f1a:	ed87 2a01 	vstr	s4, [r7, #4]
    *p2++ = m0 + m1;
 8001f1e:	edc7 5a00 	vstr	s11, [r7]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001f22:	ee77 7ae4 	vsub.f32	s15, s15, s9
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001f26:	ee76 6ae2 	vsub.f32	s13, s13, s5
    twI = tw3[1];
 8001f2a:	ed90 6a01 	vldr	s12, [r0, #4]
    twR = tw3[0];
 8001f2e:	edd0 3a00 	vldr	s7, [r0]
    *p3++ = m2 - m3;
 8001f32:	ee66 5a67 	vnmul.f32	s11, s12, s15
    m1 = t3[1] * twI;
 8001f36:	ee26 6a86 	vmul.f32	s12, s13, s12
    *p3++ = m2 - m3;
 8001f3a:	eee6 5aa3 	vfma.f32	s11, s13, s7
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001f3e:	4620      	mov	r0, r4
    *p3++ = m0 + m1;
 8001f40:	eea7 6aa3 	vfma.f32	s12, s15, s7
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001f44:	ee77 7a04 	vadd.f32	s15, s14, s8
    *p3++ = m0 + m1;
 8001f48:	ed8c 6a00 	vstr	s12, [ip]
    *p3++ = m2 - m3;
 8001f4c:	edcc 5a01 	vstr	s11, [ip, #4]
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001f50:	ee75 6a43 	vsub.f32	s13, s10, s6
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001f54:	ee77 7ae4 	vsub.f32	s15, s15, s9
    twI = tw4[1];
 8001f58:	ed93 7a01 	vldr	s14, [r3, #4]
    twR = tw4[0];
 8001f5c:	edd3 5a00 	vldr	s11, [r3]
    *p4++ = m2 - m3;
 8001f60:	ee27 6a66 	vnmul.f32	s12, s14, s13
    m1 = t4[1] * twI;
 8001f64:	ee27 7a87 	vmul.f32	s14, s15, s14
    *p4++ = m2 - m3;
 8001f68:	eea7 6aa5 	vfma.f32	s12, s15, s11
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001f6c:	2304      	movs	r3, #4
    *p4++ = m0 + m1;
 8001f6e:	eea6 7aa5 	vfma.f32	s14, s13, s11
    *p4++ = m2 - m3;
 8001f72:	ed88 6a01 	vstr	s12, [r8, #4]
    *p4++ = m0 + m1;
 8001f76:	ed88 7a00 	vstr	s14, [r8]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001f7a:	f000 f835 	bl	8001fe8 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 4U);
 8001f7e:	9804      	ldr	r0, [sp, #16]
 8001f80:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001f84:	2304      	movs	r3, #4
 8001f86:	4631      	mov	r1, r6
 8001f88:	f000 f82e 	bl	8001fe8 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol3, L, (float32_t *) S->pTwiddle, 4U);
 8001f8c:	9805      	ldr	r0, [sp, #20]
 8001f8e:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001f92:	2304      	movs	r3, #4
 8001f94:	4631      	mov	r1, r6
 8001f96:	f000 f827 	bl	8001fe8 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol4, L, (float32_t *) S->pTwiddle, 4U);
 8001f9a:	2304      	movs	r3, #4
 8001f9c:	9803      	ldr	r0, [sp, #12]
 8001f9e:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001fa2:	4631      	mov	r1, r6
 8001fa4:	f000 f820 	bl	8001fe8 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001fa8:	9b01      	ldr	r3, [sp, #4]
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	f43f acde 	beq.w	800196c <arm_cfft_f32+0xb0>
 8001fb0:	e4a1      	b.n	80018f6 <arm_cfft_f32+0x3a>
 8001fb2:	9b01      	ldr	r3, [sp, #4]
 8001fb4:	2b00      	cmp	r3, #0
 8001fb6:	f43f acdd 	beq.w	8001974 <arm_cfft_f32+0xb8>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 8001fba:	6882      	ldr	r2, [r0, #8]
 8001fbc:	8981      	ldrh	r1, [r0, #12]
 8001fbe:	4620      	mov	r0, r4
 8001fc0:	f7ff fc52 	bl	8001868 <arm_bitreversal_32>
  if (ifftFlag == 1U)
 8001fc4:	e4a1      	b.n	800190a <arm_cfft_f32+0x4e>
 8001fc6:	bf00      	nop

08001fc8 <arm_cfft_init_128_f32>:

  @par          Use of this function is mandatory only for the Helium and Neon versions of the FFT.
                Other versions can still initialize directly the data structure using 
                variables declared in arm_const_structs.h
 */
CFFTINIT_F32(128,64)
 8001fc8:	4b06      	ldr	r3, [pc, #24]	@ (8001fe4 <arm_cfft_init_128_f32+0x1c>)
 8001fca:	8999      	ldrh	r1, [r3, #12]
 8001fcc:	8181      	strh	r1, [r0, #12]
 8001fce:	e9d3 3201 	ldrd	r3, r2, [r3, #4]
 8001fd2:	f04f 0c80 	mov.w	ip, #128	@ 0x80
 8001fd6:	e9c0 3201 	strd	r3, r2, [r0, #4]
 8001fda:	f8a0 c000 	strh.w	ip, [r0]
 8001fde:	2000      	movs	r0, #0
 8001fe0:	4770      	bx	lr
 8001fe2:	bf00      	nop
 8001fe4:	0800355c 	.word	0x0800355c

08001fe8 <arm_radix8_butterfly_f32>:
ARM_DSP_ATTRIBUTE void arm_radix8_butterfly_f32(
  float32_t * pSrc,
  uint16_t fftLen,
  const float32_t * pCoef,
  uint16_t twidCoefModifier)
{
 8001fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001fec:	ed2d 8b10 	vpush	{d8-d15}
 8001ff0:	b08f      	sub	sp, #60	@ 0x3c
 8001ff2:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
 8001ff6:	4603      	mov	r3, r0
 8001ff8:	3304      	adds	r3, #4
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 8001ffa:	ed9f cabc 	vldr	s24, [pc, #752]	@ 80022ec <arm_radix8_butterfly_f32+0x304>
{
 8001ffe:	900c      	str	r0, [sp, #48]	@ 0x30
 8002000:	468a      	mov	sl, r1
   n2 = fftLen;
 8002002:	468b      	mov	fp, r1
 8002004:	930d      	str	r3, [sp, #52]	@ 0x34
      n2 = n2 >> 3;
 8002006:	ea4f 07db 	mov.w	r7, fp, lsr #3
 800200a:	eb07 0187 	add.w	r1, r7, r7, lsl #2
 800200e:	ea4f 00cb 	mov.w	r0, fp, lsl #3
 8002012:	9000      	str	r0, [sp, #0]
 8002014:	00c8      	lsls	r0, r1, #3
 8002016:	ebc7 01c7 	rsb	r1, r7, r7, lsl #3
 800201a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 800201c:	9002      	str	r0, [sp, #8]
 800201e:	ea4f 09c7 	mov.w	r9, r7, lsl #3
 8002022:	00c8      	lsls	r0, r1, #3
 8002024:	ea4f 1807 	mov.w	r8, r7, lsl #4
 8002028:	9005      	str	r0, [sp, #20]
 800202a:	f108 0104 	add.w	r1, r8, #4
 800202e:	f109 0004 	add.w	r0, r9, #4
 8002032:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 8002036:	eb03 1247 	add.w	r2, r3, r7, lsl #5
 800203a:	4418      	add	r0, r3
 800203c:	4419      	add	r1, r3
 800203e:	017b      	lsls	r3, r7, #5
 8002040:	9301      	str	r3, [sp, #4]
 8002042:	0133      	lsls	r3, r6, #4
 8002044:	eb02 1507 	add.w	r5, r2, r7, lsl #4
 8002048:	9303      	str	r3, [sp, #12]
 800204a:	00f3      	lsls	r3, r6, #3
 800204c:	eba5 04c6 	sub.w	r4, r5, r6, lsl #3
 8002050:	9304      	str	r3, [sp, #16]
 8002052:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
      i1 = 0;
 8002054:	9b00      	ldr	r3, [sp, #0]
      n2 = n2 >> 3;
 8002056:	9709      	str	r7, [sp, #36]	@ 0x24
      i1 = 0;
 8002058:	eb02 0cc7 	add.w	ip, r2, r7, lsl #3
 800205c:	f04f 0e00 	mov.w	lr, #0
 8002060:	eb04 1747 	add.w	r7, r4, r7, lsl #5
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002064:	edd5 9a00 	vldr	s19, [r5]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002068:	ed94 4a00 	vldr	s8, [r4]
 800206c:	ed97 9a00 	vldr	s18, [r7]
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002070:	ed11 2a01 	vldr	s4, [r1, #-4]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002074:	ed92 6a00 	vldr	s12, [r2]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002078:	ed9c 5a00 	vldr	s10, [ip]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 800207c:	ed56 3a01 	vldr	s7, [r6, #-4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002080:	ed50 7a01 	vldr	s15, [r0, #-4]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002084:	ee34 8a09 	vadd.f32	s16, s8, s18
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002088:	ee37 0a85 	vadd.f32	s0, s15, s10
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 800208c:	ee32 3a29 	vadd.f32	s6, s4, s19
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002090:	ee33 7a86 	vadd.f32	s14, s7, s12
         r2 = r2 + r4;
 8002094:	ee70 5a08 	vadd.f32	s11, s0, s16
         r1 = r1 + r3;
 8002098:	ee77 6a03 	vadd.f32	s13, s14, s6
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 800209c:	ee77 7ac5 	vsub.f32	s15, s15, s10
         pSrc[2 * i1] = r1 + r2;
 80020a0:	ee36 5aa5 	vadd.f32	s10, s13, s11
         pSrc[2 * i5] = r1 - r2;
 80020a4:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i1] = r1 + r2;
 80020a8:	ed06 5a01 	vstr	s10, [r6, #-4]
         pSrc[2 * i5] = r1 - r2;
 80020ac:	edc2 6a00 	vstr	s13, [r2]
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 80020b0:	ed9c ba01 	vldr	s22, [ip, #4]
 80020b4:	edd0 ba00 	vldr	s23, [r0]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80020b8:	ed94 1a01 	vldr	s2, [r4, #4]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80020bc:	edd2 aa01 	vldr	s21, [r2, #4]
 80020c0:	edd6 5a00 	vldr	s11, [r6]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80020c4:	edd7 2a01 	vldr	s5, [r7, #4]
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80020c8:	ed91 aa00 	vldr	s20, [r1]
 80020cc:	edd5 1a01 	vldr	s3, [r5, #4]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 80020d0:	ee7b 6acb 	vsub.f32	s13, s23, s22
         r1 = (r6 - r8) * C81;
 80020d4:	ee37 5ac4 	vsub.f32	s10, s15, s8
         r2 = (s6 - s8) * C81;
 80020d8:	ee76 4ac1 	vsub.f32	s9, s13, s2
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 80020dc:	ee75 0aea 	vsub.f32	s1, s11, s21
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 80020e0:	ee73 3ac6 	vsub.f32	s7, s7, s12
         r1 = (r6 - r8) * C81;
 80020e4:	ee35 5a09 	vadd.f32	s10, s10, s18
         r2 = (s6 - s8) * C81;
 80020e8:	ee34 6aa2 	vadd.f32	s12, s9, s5
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 80020ec:	eef0 8a60 	vmov.f32	s17, s1
         t1 = r5 - r1;
 80020f0:	eef0 4a63 	vmov.f32	s9, s7
 80020f4:	eee5 4a4c 	vfms.f32	s9, s10, s24
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 80020f8:	44de      	add	lr, fp
      } while (i1 < fftLen);
 80020fa:	45f2      	cmp	sl, lr
         t2 = s5 - r2;
 80020fc:	eee6 8a4c 	vfms.f32	s17, s12, s24
         r6 = (r6 + r8) * C81;
 8002100:	ee77 7ac9 	vsub.f32	s15, s15, s18
         s6 = (s6 + s8) * C81;
 8002104:	ee76 6ae2 	vsub.f32	s13, s13, s5
         r6 = (r6 + r8) * C81;
 8002108:	ee77 7a84 	vadd.f32	s15, s15, s8
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 800210c:	ee32 9a69 	vsub.f32	s18, s4, s19
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8002110:	ee3a 4a61 	vsub.f32	s8, s20, s3
         s6 = (s6 + s8) * C81;
 8002114:	ee76 6a81 	vadd.f32	s13, s13, s2
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002118:	ee75 5aaa 	vadd.f32	s11, s11, s21
 800211c:	ee39 2ac2 	vsub.f32	s4, s19, s4
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002120:	ee7a aa21 	vadd.f32	s21, s20, s3
 8002124:	ee71 1aca 	vsub.f32	s3, s3, s20
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002128:	ee7b ba8b 	vadd.f32	s23, s23, s22
         r5 = r5 + r1;
 800212c:	eee5 3a0c 	vfma.f32	s7, s10, s24
         s7 = s7 + s6;
 8002130:	eeb0 aa44 	vmov.f32	s20, s8
 8002134:	eeb0 ba64 	vmov.f32	s22, s9
         r7 = r7 + r6;
 8002138:	eeb0 5a49 	vmov.f32	s10, s18
 800213c:	eef0 9a68 	vmov.f32	s19, s17
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002140:	ee31 1a22 	vadd.f32	s2, s2, s5
         r7 = r7 + r6;
 8002144:	eea7 5a8c 	vfma.f32	s10, s15, s24
         s5 = s5 + r2;
 8002148:	eee6 0a0c 	vfma.f32	s1, s12, s24
         s7 = s7 + s6;
 800214c:	eea6 aa8c 	vfma.f32	s20, s13, s24
         t2 = r1 - s3;
 8002150:	ee35 6aea 	vsub.f32	s12, s11, s21
 8002154:	eee6 1a8c 	vfma.f32	s3, s13, s24
         t1 = r1 - r3;
 8002158:	ee37 7a43 	vsub.f32	s14, s14, s6
         r1 = r1 + s3;
 800215c:	eee7 9acc 	vfms.f32	s19, s15, s24
 8002160:	eea6 bacc 	vfms.f32	s22, s13, s24
 8002164:	eea7 2a8c 	vfma.f32	s4, s15, s24
         r2 = r2 + r4;
 8002168:	ee7b 2a81 	vadd.f32	s5, s23, s2
         pSrc[2 * i3]     = t1 + s3;
 800216c:	ee77 6a41 	vsub.f32	s13, s14, s2
         r1 = r1 + s3;
 8002170:	ee75 7aaa 	vadd.f32	s15, s11, s21
         pSrc[2 * i3 + 1] = t2 - r3;
 8002174:	ee36 3a40 	vsub.f32	s6, s12, s0
         pSrc[2 * i7]     = t1 - s3;
 8002178:	ee37 7a6b 	vsub.f32	s14, s14, s23
         pSrc[2 * i7 + 1] = t2 + r3;
 800217c:	ee36 6a48 	vsub.f32	s12, s12, s16
         pSrc[2 * i1 + 1] = r1 + r2;
 8002180:	ee77 aaa2 	vadd.f32	s21, s15, s5
         pSrc[2 * i7]     = t1 - s3;
 8002184:	ee37 7a01 	vadd.f32	s14, s14, s2
         pSrc[2 * i5 + 1] = r1 - r2;
 8002188:	ee77 7ae2 	vsub.f32	s15, s15, s5
         pSrc[2 * i2]     = r5 + s7;
 800218c:	ee33 1a8a 	vadd.f32	s2, s7, s20
         pSrc[2 * i3]     = t1 + s3;
 8002190:	ee76 2aab 	vadd.f32	s5, s13, s23
         pSrc[2 * i4]     = t1 - s8;
 8002194:	ee74 4aa1 	vadd.f32	s9, s9, s3
         pSrc[2 * i3 + 1] = t2 - r3;
 8002198:	ee33 3a08 	vadd.f32	s6, s6, s16
         pSrc[2 * i2 + 1] = s5 - r7;
 800219c:	ee70 1ac5 	vsub.f32	s3, s1, s10
         pSrc[2 * i7 + 1] = t2 + r3;
 80021a0:	ee36 6a00 	vadd.f32	s12, s12, s0
         pSrc[2 * i8]     = r5 - s7;
 80021a4:	ee73 3aca 	vsub.f32	s7, s7, s20
         pSrc[2 * i6]     = t1 + s8;
 80021a8:	ee34 4a0b 	vadd.f32	s8, s8, s22
         pSrc[2 * i8 + 1] = s5 + r7;
 80021ac:	ee35 5a20 	vadd.f32	s10, s10, s1
         pSrc[2 * i6 + 1] = t2 - r8;
 80021b0:	ee78 5a82 	vadd.f32	s11, s17, s4
         pSrc[2 * i4 + 1] = t2 + r8;
 80021b4:	ee79 6a29 	vadd.f32	s13, s18, s19
         pSrc[2 * i1 + 1] = r1 + r2;
 80021b8:	edc6 aa00 	vstr	s21, [r6]
         pSrc[2 * i5 + 1] = r1 - r2;
 80021bc:	edc2 7a01 	vstr	s15, [r2, #4]
      } while (i1 < fftLen);
 80021c0:	441e      	add	r6, r3
         pSrc[2 * i3]     = t1 + s3;
 80021c2:	ed41 2a01 	vstr	s5, [r1, #-4]
      } while (i1 < fftLen);
 80021c6:	441a      	add	r2, r3
         pSrc[2 * i7]     = t1 - s3;
 80021c8:	ed85 7a00 	vstr	s14, [r5]
         pSrc[2 * i3 + 1] = t2 - r3;
 80021cc:	ed81 3a00 	vstr	s6, [r1]
         pSrc[2 * i7 + 1] = t2 + r3;
 80021d0:	ed85 6a01 	vstr	s12, [r5, #4]
      } while (i1 < fftLen);
 80021d4:	4419      	add	r1, r3
         pSrc[2 * i2]     = r5 + s7;
 80021d6:	ed00 1a01 	vstr	s2, [r0, #-4]
      } while (i1 < fftLen);
 80021da:	441d      	add	r5, r3
         pSrc[2 * i8]     = r5 - s7;
 80021dc:	edc7 3a00 	vstr	s7, [r7]
         pSrc[2 * i6]     = t1 + s8;
 80021e0:	ed8c 4a00 	vstr	s8, [ip]
         pSrc[2 * i4]     = t1 - s8;
 80021e4:	edc4 4a00 	vstr	s9, [r4]
         pSrc[2 * i2 + 1] = s5 - r7;
 80021e8:	edc0 1a00 	vstr	s3, [r0]
         pSrc[2 * i8 + 1] = s5 + r7;
 80021ec:	ed87 5a01 	vstr	s10, [r7, #4]
      } while (i1 < fftLen);
 80021f0:	4418      	add	r0, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 80021f2:	edcc 5a01 	vstr	s11, [ip, #4]
      } while (i1 < fftLen);
 80021f6:	441f      	add	r7, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 80021f8:	edc4 6a01 	vstr	s13, [r4, #4]
      } while (i1 < fftLen);
 80021fc:	449c      	add	ip, r3
 80021fe:	441c      	add	r4, r3
 8002200:	f63f af30 	bhi.w	8002064 <arm_radix8_butterfly_f32+0x7c>

      if (n2 < 8)
 8002204:	461f      	mov	r7, r3
 8002206:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8002208:	2b07      	cmp	r3, #7
 800220a:	f240 81a1 	bls.w	8002550 <arm_radix8_butterfly_f32+0x568>
 800220e:	9d01      	ldr	r5, [sp, #4]
 8002210:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8002212:	9c02      	ldr	r4, [sp, #8]
 8002214:	9803      	ldr	r0, [sp, #12]
 8002216:	9904      	ldr	r1, [sp, #16]
 8002218:	9a05      	ldr	r2, [sp, #20]
 800221a:	3508      	adds	r5, #8
 800221c:	f109 0908 	add.w	r9, r9, #8
 8002220:	1973      	adds	r3, r6, r5
 8002222:	3408      	adds	r4, #8
 8002224:	9308      	str	r3, [sp, #32]
 8002226:	eb06 0309 	add.w	r3, r6, r9
 800222a:	3008      	adds	r0, #8
 800222c:	9307      	str	r3, [sp, #28]
 800222e:	1933      	adds	r3, r6, r4
 8002230:	3108      	adds	r1, #8
 8002232:	9306      	str	r3, [sp, #24]
 8002234:	1833      	adds	r3, r6, r0
 8002236:	3208      	adds	r2, #8
 8002238:	9305      	str	r3, [sp, #20]
 800223a:	1873      	adds	r3, r6, r1
 800223c:	f108 080c 	add.w	r8, r8, #12
 8002240:	9304      	str	r3, [sp, #16]
 8002242:	18b3      	adds	r3, r6, r2
 8002244:	9303      	str	r3, [sp, #12]
 8002246:	eb06 0308 	add.w	r3, r6, r8
 800224a:	9301      	str	r3, [sp, #4]
 800224c:	f106 030c 	add.w	r3, r6, #12
 8002250:	9302      	str	r3, [sp, #8]
         break;

      ia1 = 0;
      j = 1;
 8002252:	f04f 0901 	mov.w	r9, #1
      ia1 = 0;
 8002256:	f04f 0800 	mov.w	r8, #0
 800225a:	463b      	mov	r3, r7

      do
      {
         /*  index calculation for the coefficients */
         id  = ia1 + twidCoefModifier;
 800225c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 800225e:	4490      	add	r8, r2
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 8002260:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8002262:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002266:	ed92 fa00 	vldr	s30, [r2]
         co3 = pCoef[2 * ia2];
 800226a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800226e:	edd2 ea00 	vldr	s29, [r2]
         co4 = pCoef[2 * ia3];
 8002272:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002276:	ed92 ea00 	vldr	s28, [r2]
         co5 = pCoef[2 * ia4];
 800227a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800227e:	edd2 da00 	vldr	s27, [r2]
         co6 = pCoef[2 * ia5];
 8002282:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002286:	ed92 da00 	vldr	s26, [r2]
         co7 = pCoef[2 * ia6];
 800228a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800228e:	eb08 0148 	add.w	r1, r8, r8, lsl #1
 8002292:	edd2 ca00 	vldr	s25, [r2]
         co8 = pCoef[2 * ia7];
 8002296:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800229a:	edd2 ba00 	vldr	s23, [r2]
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
         si8 = pCoef[2 * ia7 + 1];
 800229e:	ed92 ba01 	vldr	s22, [r2, #4]
 80022a2:	eba2 1201 	sub.w	r2, r2, r1, lsl #4
         si2 = pCoef[2 * ia1 + 1];
 80022a6:	edd2 aa01 	vldr	s21, [r2, #4]
         si3 = pCoef[2 * ia2 + 1];
 80022aa:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80022ae:	ed92 aa01 	vldr	s20, [r2, #4]
         si4 = pCoef[2 * ia3 + 1];
 80022b2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80022b6:	edd2 9a01 	vldr	s19, [r2, #4]
         si5 = pCoef[2 * ia4 + 1];
 80022ba:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80022be:	ed92 9a01 	vldr	s18, [r2, #4]
         si6 = pCoef[2 * ia5 + 1];
 80022c2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80022c6:	edd2 8a01 	vldr	s17, [r2, #4]
         si7 = pCoef[2 * ia6 + 1];
 80022ca:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80022ce:	edd2 7a01 	vldr	s15, [r2, #4]
         si8 = pCoef[2 * ia7 + 1];
 80022d2:	e9dd c701 	ldrd	ip, r7, [sp, #4]
 80022d6:	e9dd 6503 	ldrd	r6, r5, [sp, #12]
 80022da:	e9dd 4005 	ldrd	r4, r0, [sp, #20]
 80022de:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
         si7 = pCoef[2 * ia6 + 1];
 80022e2:	edcd 7a00 	vstr	s15, [sp]

         i1 = j;
 80022e6:	46ce      	mov	lr, r9
 80022e8:	e002      	b.n	80022f0 <arm_radix8_butterfly_f32+0x308>
 80022ea:	bf00      	nop
 80022ec:	3f3504f3 	.word	0x3f3504f3
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80022f0:	edd5 4a00 	vldr	s9, [r5]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80022f4:	ed1c 7a01 	vldr	s14, [ip, #-4]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80022f8:	edd6 fa00 	vldr	s31, [r6]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80022fc:	edd4 6a00 	vldr	s13, [r4]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002300:	edd2 3a00 	vldr	s7, [r2]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002304:	ed90 3a00 	vldr	s6, [r0]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002308:	ed57 5a01 	vldr	s11, [r7, #-4]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 800230c:	edd1 7a00 	vldr	s15, [r1]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002310:	ed97 1a00 	vldr	s2, [r7]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002314:	ee74 0aaf 	vadd.f32	s1, s9, s31
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002318:	ee37 0a83 	vadd.f32	s0, s15, s6
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 800231c:	ee37 5a26 	vadd.f32	s10, s14, s13
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002320:	ee35 6aa3 	vadd.f32	s12, s11, s7
            r2 = r2 + r4;
 8002324:	ee30 4a20 	vadd.f32	s8, s0, s1
            r1 = r1 + r3;
 8002328:	ee36 2a05 	vadd.f32	s4, s12, s10
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 800232c:	ee77 7ac3 	vsub.f32	s15, s15, s6
            pSrc[2 * i1] = r1 + r2;
 8002330:	ee32 3a04 	vadd.f32	s6, s4, s8
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8002334:	ee75 5ae3 	vsub.f32	s11, s11, s7
            pSrc[2 * i1] = r1 + r2;
 8002338:	ed07 3a01 	vstr	s6, [r7, #-4]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 800233c:	ed90 3a01 	vldr	s6, [r0, #4]
 8002340:	edd1 3a01 	vldr	s7, [r1, #4]
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002344:	ed92 8a01 	vldr	s16, [r2, #4]
            r2 = r1 - r2;
 8002348:	ee32 2a44 	vsub.f32	s4, s4, s8
            t1 = r1 - r3;
 800234c:	ee36 6a45 	vsub.f32	s12, s12, s10
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002350:	ed95 4a01 	vldr	s8, [r5, #4]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 8002354:	ee33 5ac3 	vsub.f32	s10, s7, s6
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002358:	ee73 3a83 	vadd.f32	s7, s7, s6
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 800235c:	ee37 3ae4 	vsub.f32	s6, s15, s9
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8002360:	ee77 1a66 	vsub.f32	s3, s14, s13
            r1 = (r6 - r8) * C81;
 8002364:	ee33 3a2f 	vadd.f32	s6, s6, s31
 8002368:	ee76 6ac7 	vsub.f32	s13, s13, s14
            r6 = (r6 + r8) * C81;
 800236c:	ee77 7aef 	vsub.f32	s15, s15, s31
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002370:	ed96 7a01 	vldr	s14, [r6, #4]
            s1 = (s6 - s8) * C81;
 8002374:	ee75 fa44 	vsub.f32	s31, s10, s8
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 8002378:	ee71 2a48 	vsub.f32	s5, s2, s16
            r6 = (r6 + r8) * C81;
 800237c:	ee77 7aa4 	vadd.f32	s15, s15, s9
            s1 = (s6 - s8) * C81;
 8002380:	ee7f fa87 	vadd.f32	s31, s31, s14
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 8002384:	eef0 4a65 	vmov.f32	s9, s11
 8002388:	eee3 4a4c 	vfms.f32	s9, s6, s24
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 800238c:	44de      	add	lr, fp
         } while (i1 < fftLen);
 800238e:	45f2      	cmp	sl, lr
            r5 = r5 + r1;
 8002390:	eee3 5a0c 	vfma.f32	s11, s6, s24
            t2 = s5 - s1;
 8002394:	eeb0 3a62 	vmov.f32	s6, s5
 8002398:	eeaf 3acc 	vfms.f32	s6, s31, s24
 800239c:	eee7 6a8c 	vfma.f32	s13, s15, s24
            s6 = (s6 + s8) * C81;
 80023a0:	ee35 5a47 	vsub.f32	s10, s10, s14
            s6 = t2 - r8;
 80023a4:	ee73 6a26 	vadd.f32	s13, s6, s13
 80023a8:	eea7 3acc 	vfms.f32	s6, s15, s24
            s6 = (s6 + s8) * C81;
 80023ac:	ee35 5a04 	vadd.f32	s10, s10, s8
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80023b0:	ee31 1a08 	vadd.f32	s2, s2, s16
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80023b4:	ee34 4a07 	vadd.f32	s8, s8, s14
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80023b8:	ed9c 8a00 	vldr	s16, [ip]
 80023bc:	ed94 7a01 	vldr	s14, [r4, #4]
            s5 = s5 + s1;
 80023c0:	eeef 2a8c 	vfma.f32	s5, s31, s24
 80023c4:	eef0 fa43 	vmov.f32	s31, s6
            r7 = r7 + r6;
 80023c8:	eeb0 3a61 	vmov.f32	s6, s3
 80023cc:	eea7 3a8c 	vfma.f32	s6, s15, s24
            t2 = t2 + r8;
 80023d0:	ee71 7aaf 	vadd.f32	s15, s3, s31
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80023d4:	ee78 1a07 	vadd.f32	s3, s16, s14
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 80023d8:	ee78 fa47 	vsub.f32	s31, s16, s14
            t2 = s1 - s3;
 80023dc:	ee37 7a48 	vsub.f32	s14, s14, s16
            s7 = s7 + s6;
 80023e0:	eeb0 8a6f 	vmov.f32	s16, s31
 80023e4:	eea5 7a0c 	vfma.f32	s14, s10, s24
 80023e8:	eea5 8a0c 	vfma.f32	s16, s10, s24
            t1 = t1 - s8;
 80023ec:	ee37 7a24 	vadd.f32	s14, s14, s9
 80023f0:	eee5 4a4c 	vfms.f32	s9, s10, s24
            t2 = s1 - s3;
 80023f4:	ee31 5a61 	vsub.f32	s10, s2, s3
            r6 = t1 + s8;
 80023f8:	ee74 4aaf 	vadd.f32	s9, s9, s31
 80023fc:	ee75 fa60 	vsub.f32	s31, s10, s1
            s1 = t2 - r3;
 8002400:	ee35 5a40 	vsub.f32	s10, s10, s0
            s1 = s1 + s3;
 8002404:	ee71 1a21 	vadd.f32	s3, s2, s3
            s1 = t2 - r3;
 8002408:	ee35 5a20 	vadd.f32	s10, s10, s1
            s2 = s2 + s4;
 800240c:	ee33 1a84 	vadd.f32	s2, s7, s8
            r1 = t1 + s3;
 8002410:	ee76 0a44 	vsub.f32	s1, s12, s8
 8002414:	ee36 6a63 	vsub.f32	s12, s12, s7
 8002418:	ee70 0aa3 	vadd.f32	s1, s1, s7
            t1 = t1 - s3;
 800241c:	ee34 6a06 	vadd.f32	s12, s8, s12
            pSrc[2 * i1 + 1] = s1 + s2;
 8002420:	ee71 3a81 	vadd.f32	s7, s3, s2
            pSrc[2 * i5 + 1] = p3 - p4;
 8002424:	ee22 4a49 	vnmul.f32	s8, s4, s18
            s2 = s1 - s2;
 8002428:	ee31 1ac1 	vsub.f32	s2, s3, s2
            pSrc[2 * i1 + 1] = s1 + s2;
 800242c:	edc7 3a00 	vstr	s7, [r7]
            pSrc[2 * i5 + 1] = p3 - p4;
 8002430:	eead 4a81 	vfma.f32	s8, s27, s2
         } while (i1 < fftLen);
 8002434:	441f      	add	r7, r3
            p2 = si5 * s2;
 8002436:	ee69 1a01 	vmul.f32	s3, s18, s2
            p2 = si3 * s1;
 800243a:	ee2a 1a05 	vmul.f32	s2, s20, s10
            pSrc[2 * i5]     = p1 + p2;
 800243e:	eeed 1a82 	vfma.f32	s3, s27, s4
            pSrc[2 * i3]     = p1 + p2;
 8002442:	eeb0 2a41 	vmov.f32	s4, s2
            t2 = t2 + r3;
 8002446:	ee70 fa2f 	vadd.f32	s31, s0, s31
            p2 = si7 * t2;
 800244a:	eddd 3a00 	vldr	s7, [sp]
            pSrc[2 * i5]     = p1 + p2;
 800244e:	edc2 1a00 	vstr	s3, [r2]
            pSrc[2 * i3]     = p1 + p2;
 8002452:	eeae 2aa0 	vfma.f32	s4, s29, s1
            pSrc[2 * i3 + 1] = p3 - p4;
 8002456:	ee60 0aca 	vnmul.f32	s1, s1, s20
            s1 = s5 - r7;
 800245a:	ee32 1ac3 	vsub.f32	s2, s5, s6
            pSrc[2 * i3 + 1] = p3 - p4;
 800245e:	eeee 0a85 	vfma.f32	s1, s29, s10
            p2 = si7 * t2;
 8002462:	ee23 5aaf 	vmul.f32	s10, s7, s31
            pSrc[2 * i7 + 1] = p3 - p4;
 8002466:	ee66 3a63 	vnmul.f32	s7, s12, s7
            pSrc[2 * i7]     = p1 + p2;
 800246a:	eeac 5a86 	vfma.f32	s10, s25, s12
            r1 = r5 + s7;
 800246e:	ee35 6a88 	vadd.f32	s12, s11, s16
            r5 = r5 - s7;
 8002472:	ee35 8ac8 	vsub.f32	s16, s11, s16
            pSrc[2 * i5 + 1] = p3 - p4;
 8002476:	ed82 4a01 	vstr	s8, [r2, #4]
            s5 = s5 + r7;
 800247a:	ee33 3a22 	vadd.f32	s6, s6, s5
            p2 = si2 * s1;
 800247e:	ee6a 1a81 	vmul.f32	s3, s21, s2
            pSrc[2 * i8 + 1] = p3 - p4;
 8002482:	ee28 4a4b 	vnmul.f32	s8, s16, s22
            pSrc[2 * i2 + 1] = p3 - p4;
 8002486:	ee26 0a6a 	vnmul.f32	s0, s12, s21
            pSrc[2 * i2]     = p1 + p2;
 800248a:	eeef 1a06 	vfma.f32	s3, s30, s12
         } while (i1 < fftLen);
 800248e:	441a      	add	r2, r3
            pSrc[2 * i8 + 1] = p3 - p4;
 8002490:	eeab 4a83 	vfma.f32	s8, s23, s6
            p2 = si8 * s5;
 8002494:	ee6b 2a03 	vmul.f32	s5, s22, s6
            p2 = si4 * t2;
 8002498:	ee29 6aa7 	vmul.f32	s12, s19, s15
            pSrc[2 * i4 + 1] = p3 - p4;
 800249c:	ee27 3a69 	vnmul.f32	s6, s14, s19
            pSrc[2 * i2 + 1] = p3 - p4;
 80024a0:	eeaf 0a01 	vfma.f32	s0, s30, s2
            p2 = si6 * s6;
 80024a4:	ee68 5aa6 	vmul.f32	s11, s17, s13
            pSrc[2 * i6 + 1] = p3 - p4;
 80024a8:	ee24 1ae8 	vnmul.f32	s2, s9, s17
            pSrc[2 * i4]     = p1 + p2;
 80024ac:	eeae 6a07 	vfma.f32	s12, s28, s14
            pSrc[2 * i4 + 1] = p3 - p4;
 80024b0:	eeb0 7a43 	vmov.f32	s14, s6
            pSrc[2 * i7 + 1] = p3 - p4;
 80024b4:	eeec 3aaf 	vfma.f32	s7, s25, s31
            pSrc[2 * i8]     = p1 + p2;
 80024b8:	eeeb 2a88 	vfma.f32	s5, s23, s16
            pSrc[2 * i6]     = p1 + p2;
 80024bc:	eeed 5a24 	vfma.f32	s11, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
 80024c0:	eead 1a26 	vfma.f32	s2, s26, s13
            pSrc[2 * i4 + 1] = p3 - p4;
 80024c4:	eeae 7a27 	vfma.f32	s14, s28, s15
            pSrc[2 * i3]     = p1 + p2;
 80024c8:	ed0c 2a01 	vstr	s4, [ip, #-4]
            pSrc[2 * i3 + 1] = p3 - p4;
 80024cc:	edcc 0a00 	vstr	s1, [ip]
            pSrc[2 * i7]     = p1 + p2;
 80024d0:	ed84 5a00 	vstr	s10, [r4]
            pSrc[2 * i7 + 1] = p3 - p4;
 80024d4:	edc4 3a01 	vstr	s7, [r4, #4]
         } while (i1 < fftLen);
 80024d8:	449c      	add	ip, r3
            pSrc[2 * i2]     = p1 + p2;
 80024da:	edc1 1a00 	vstr	s3, [r1]
            pSrc[2 * i2 + 1] = p3 - p4;
 80024de:	ed81 0a01 	vstr	s0, [r1, #4]
         } while (i1 < fftLen);
 80024e2:	441c      	add	r4, r3
            pSrc[2 * i8]     = p1 + p2;
 80024e4:	edc6 2a00 	vstr	s5, [r6]
            pSrc[2 * i8 + 1] = p3 - p4;
 80024e8:	ed86 4a01 	vstr	s8, [r6, #4]
         } while (i1 < fftLen);
 80024ec:	4419      	add	r1, r3
            pSrc[2 * i6]     = p1 + p2;
 80024ee:	edc0 5a00 	vstr	s11, [r0]
            pSrc[2 * i6 + 1] = p3 - p4;
 80024f2:	ed80 1a01 	vstr	s2, [r0, #4]
         } while (i1 < fftLen);
 80024f6:	441e      	add	r6, r3
            pSrc[2 * i4]     = p1 + p2;
 80024f8:	ed85 6a00 	vstr	s12, [r5]
         } while (i1 < fftLen);
 80024fc:	4418      	add	r0, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 80024fe:	ed85 7a01 	vstr	s14, [r5, #4]
         } while (i1 < fftLen);
 8002502:	441d      	add	r5, r3
 8002504:	f63f aef4 	bhi.w	80022f0 <arm_radix8_butterfly_f32+0x308>

         j++;
      } while (j < n2);
 8002508:	9a08      	ldr	r2, [sp, #32]
 800250a:	3208      	adds	r2, #8
 800250c:	9208      	str	r2, [sp, #32]
 800250e:	9a07      	ldr	r2, [sp, #28]
 8002510:	3208      	adds	r2, #8
 8002512:	9207      	str	r2, [sp, #28]
 8002514:	9a06      	ldr	r2, [sp, #24]
 8002516:	3208      	adds	r2, #8
 8002518:	9206      	str	r2, [sp, #24]
 800251a:	9a05      	ldr	r2, [sp, #20]
 800251c:	3208      	adds	r2, #8
 800251e:	9205      	str	r2, [sp, #20]
 8002520:	9a04      	ldr	r2, [sp, #16]
 8002522:	3208      	adds	r2, #8
 8002524:	9204      	str	r2, [sp, #16]
 8002526:	9a03      	ldr	r2, [sp, #12]
 8002528:	3208      	adds	r2, #8
 800252a:	9203      	str	r2, [sp, #12]
 800252c:	9a02      	ldr	r2, [sp, #8]
 800252e:	3208      	adds	r2, #8
 8002530:	9202      	str	r2, [sp, #8]
 8002532:	9a01      	ldr	r2, [sp, #4]
 8002534:	3208      	adds	r2, #8
 8002536:	9201      	str	r2, [sp, #4]
 8002538:	9a09      	ldr	r2, [sp, #36]	@ 0x24
         j++;
 800253a:	f109 0901 	add.w	r9, r9, #1
      } while (j < n2);
 800253e:	454a      	cmp	r2, r9
 8002540:	f47f ae8c 	bne.w	800225c <arm_radix8_butterfly_f32+0x274>

      twidCoefModifier <<= 3;
 8002544:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8002546:	00db      	lsls	r3, r3, #3
 8002548:	b29b      	uxth	r3, r3
 800254a:	930a      	str	r3, [sp, #40]	@ 0x28
      n2 = n2 >> 3;
 800254c:	4693      	mov	fp, r2
 800254e:	e55a      	b.n	8002006 <arm_radix8_butterfly_f32+0x1e>
   } while (n2 > 7);
}
 8002550:	b00f      	add	sp, #60	@ 0x3c
 8002552:	ecbd 8b10 	vpop	{d8-d15}
 8002556:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800255a:	bf00      	nop

0800255c <arm_rfft_fast_f32>:
ARM_DSP_ATTRIBUTE void arm_rfft_fast_f32(
  const arm_rfft_fast_instance_f32 * S,
  float32_t * p,
  float32_t * pOut,
  uint8_t ifftFlag)
{
 800255c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002560:	4615      	mov	r5, r2
 8002562:	4607      	mov	r7, r0
 8002564:	460c      	mov	r4, r1
   const arm_cfft_instance_f32 * Sint = &(S->Sint);

   /* Calculation of Real FFT */
   if (ifftFlag)
 8002566:	461a      	mov	r2, r3
 8002568:	2b00      	cmp	r3, #0
 800256a:	d056      	beq.n	800261a <arm_rfft_fast_f32+0xbe>
   xAR = pA[0];
 800256c:	edd1 7a00 	vldr	s15, [r1]
   xAI = pA[1];
 8002570:	edd1 6a01 	vldr	s13, [r1, #4]
 8002574:	8800      	ldrh	r0, [r0, #0]
 8002576:	6979      	ldr	r1, [r7, #20]
   *pOut++ = 0.5f * ( xAR + xAI );
 8002578:	ee37 7aa6 	vadd.f32	s14, s15, s13
   *pOut++ = 0.5f * ( xAR - xAI );
 800257c:	ee77 7ae6 	vsub.f32	s15, s15, s13
   *pOut++ = 0.5f * ( xAR + xAI );
 8002580:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
   k = (S->Sint).fftLen - 1;
 8002584:	1e43      	subs	r3, r0, #1
   *pOut++ = 0.5f * ( xAR + xAI );
 8002586:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( xAR - xAI );
 800258a:	ee67 7a84 	vmul.f32	s15, s15, s8
   while (k > 0)
 800258e:	2b00      	cmp	r3, #0
   *pOut++ = 0.5f * ( xAR + xAI );
 8002590:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( xAR - xAI );
 8002594:	edc5 7a01 	vstr	s15, [r5, #4]
   pB  =  p + 2*k ;
 8002598:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
   while (k > 0)
 800259c:	dd36      	ble.n	800260c <arm_rfft_fast_f32+0xb0>
 800259e:	f101 0e10 	add.w	lr, r1, #16
 80025a2:	ebac 00c0 	sub.w	r0, ip, r0, lsl #3
 80025a6:	f104 0110 	add.w	r1, r4, #16
 80025aa:	f1ac 0c08 	sub.w	ip, ip, #8
 80025ae:	f105 0610 	add.w	r6, r5, #16
      xBI =   pB[1]    ;
 80025b2:	eddc 6a03 	vldr	s13, [ip, #12]
      xBR =   pB[0]    ;
 80025b6:	eddc 7a02 	vldr	s15, [ip, #8]
      xAR =  pA[0];
 80025ba:	ed11 7a02 	vldr	s14, [r1, #-8]
      xAI =  pA[1];
 80025be:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 80025c2:	ed1e 6a02 	vldr	s12, [lr, #-8]
      twI = *pCoeff++;
 80025c6:	ed5e 5a01 	vldr	s11, [lr, #-4]
      t1a = xAR - xBR ;
 80025ca:	ee77 4a67 	vsub.f32	s9, s14, s15
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80025ce:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80025d2:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80025d6:	eee6 7a64 	vfms.f32	s15, s12, s9
   while (k > 0)
 80025da:	f1ac 0c08 	sub.w	ip, ip, #8
 80025de:	3608      	adds	r6, #8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80025e0:	eea5 7aa4 	vfma.f32	s14, s11, s9
   while (k > 0)
 80025e4:	4560      	cmp	r0, ip
 80025e6:	f10e 0e08 	add.w	lr, lr, #8
      t1b = xAI + xBI ;
 80025ea:	ee76 6a85 	vadd.f32	s13, s13, s10
   while (k > 0)
 80025ee:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80025f2:	eee5 7ae6 	vfms.f32	s15, s11, s13
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80025f6:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80025fa:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80025fe:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 8002602:	ed46 7a04 	vstr	s15, [r6, #-16]
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 8002606:	ed06 7a03 	vstr	s14, [r6, #-12]
   while (k > 0)
 800260a:	d1d2      	bne.n	80025b2 <arm_rfft_fast_f32+0x56>
   {
      /*  Real FFT compression */
      merge_rfft_f32(S, p, pOut);
      /* Complex radix-4 IFFT process */
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 800260c:	4629      	mov	r1, r5
 800260e:	4638      	mov	r0, r7
 8002610:	2301      	movs	r3, #1
      arm_cfft_f32( Sint, p, ifftFlag, 1);

      /*  Real FFT extraction */
      stage_rfft_f32(S, p, pOut);
   }
}
 8002612:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 8002616:	f7ff b951 	b.w	80018bc <arm_cfft_f32>
      arm_cfft_f32( Sint, p, ifftFlag, 1);
 800261a:	2301      	movs	r3, #1
 800261c:	f7ff f94e 	bl	80018bc <arm_cfft_f32>
   t1b = xBI + xAI  ;
 8002620:	edd4 7a01 	vldr	s15, [r4, #4]
   xBR = pB[0];
 8002624:	ed94 6a00 	vldr	s12, [r4]
   k = (S->Sint).fftLen - 1;
 8002628:	883e      	ldrh	r6, [r7, #0]
 800262a:	6978      	ldr	r0, [r7, #20]
   t1b = xBI + xAI  ;
 800262c:	ee77 7aa7 	vadd.f32	s15, s15, s15
   *pOut++ = 0.5f * ( t1a + t1b );
 8002630:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 8002634:	eeb0 7a67 	vmov.f32	s14, s15
 8002638:	eea6 7a26 	vfma.f32	s14, s12, s13
   k = (S->Sint).fftLen - 1;
 800263c:	3e01      	subs	r6, #1
   *pOut++ = 0.5f * ( t1a + t1b );
 800263e:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
   *pOut++ = 0.5f * ( t1a - t1b );
 8002642:	eed6 7a26 	vfnms.f32	s15, s12, s13
 8002646:	3010      	adds	r0, #16
 8002648:	f105 0210 	add.w	r2, r5, #16
   *pOut++ = 0.5f * ( t1a + t1b );
 800264c:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 8002650:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( t1a - t1b );
 8002654:	ee67 7a84 	vmul.f32	s15, s15, s8
   *pOut++ = 0.5f * ( t1a + t1b );
 8002658:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( t1a - t1b );
 800265c:	edc5 7a01 	vstr	s15, [r5, #4]
   pA += 2;
 8002660:	f104 0110 	add.w	r1, r4, #16
 8002664:	3b08      	subs	r3, #8
      xAR = pA[0];
 8002666:	ed11 7a02 	vldr	s14, [r1, #-8]
      xBI = pB[1];
 800266a:	edd3 6a03 	vldr	s13, [r3, #12]
      xBR = pB[0];
 800266e:	edd3 7a02 	vldr	s15, [r3, #8]
      xAI = pA[1];
 8002672:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 8002676:	ed10 6a02 	vldr	s12, [r0, #-8]
      twI = *pCoeff++;
 800267a:	ed50 5a01 	vldr	s11, [r0, #-4]
      t1a = xBR - xAR ;
 800267e:	ee77 4ac7 	vsub.f32	s9, s15, s14
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002682:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 8002686:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 800268a:	eee6 7a24 	vfma.f32	s15, s12, s9
      k--;
 800268e:	3e01      	subs	r6, #1
   } while (k > 0);
 8002690:	3208      	adds	r2, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 8002692:	eea5 7aa4 	vfma.f32	s14, s11, s9
   } while (k > 0);
 8002696:	2e00      	cmp	r6, #0
 8002698:	f100 0008 	add.w	r0, r0, #8
      t1b = xBI + xAI ;
 800269c:	ee76 6a85 	vadd.f32	s13, s13, s10
   } while (k > 0);
 80026a0:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80026a4:	eee5 7aa6 	vfma.f32	s15, s11, s13
   } while (k > 0);
 80026a8:	f1a3 0308 	sub.w	r3, r3, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 80026ac:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80026b0:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 80026b4:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80026b8:	ed42 7a04 	vstr	s15, [r2, #-16]
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 80026bc:	ed02 7a03 	vstr	s14, [r2, #-12]
   } while (k > 0);
 80026c0:	dcd1      	bgt.n	8002666 <arm_rfft_fast_f32+0x10a>
}
 80026c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80026c6:	bf00      	nop

080026c8 <arm_rfft_fast_init_256_f32>:
#else
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {

  arm_status status;

  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 80026c8:	b150      	cbz	r0, 80026e0 <arm_rfft_fast_init_256_f32+0x18>
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {
 80026ca:	b510      	push	{r4, lr}
 80026cc:	4604      	mov	r4, r0

  status=arm_cfft_init_128_f32(&(S->Sint));
 80026ce:	f7ff fc7b 	bl	8001fc8 <arm_cfft_init_128_f32>
  if (status != ARM_MATH_SUCCESS)
 80026d2:	b920      	cbnz	r0, 80026de <arm_rfft_fast_init_256_f32+0x16>
  {
    return(status);
  }
  S->fftLenRFFT = 256U;

  S->pTwiddleRFFT    = (float32_t *) twiddleCoef_rfft_256;
 80026d4:	4b04      	ldr	r3, [pc, #16]	@ (80026e8 <arm_rfft_fast_init_256_f32+0x20>)
 80026d6:	6163      	str	r3, [r4, #20]
  S->fftLenRFFT = 256U;
 80026d8:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80026dc:	8222      	strh	r2, [r4, #16]

  return ARM_MATH_SUCCESS;
}
 80026de:	bd10      	pop	{r4, pc}
  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 80026e0:	f04f 30ff 	mov.w	r0, #4294967295
}
 80026e4:	4770      	bx	lr
 80026e6:	bf00      	nop
 80026e8:	08002bbc 	.word	0x08002bbc

080026ec <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80026ec:	4a03      	ldr	r2, [pc, #12]	@ (80026fc <HAL_IncTick+0x10>)
 80026ee:	4b04      	ldr	r3, [pc, #16]	@ (8002700 <HAL_IncTick+0x14>)
 80026f0:	6811      	ldr	r1, [r2, #0]
 80026f2:	781b      	ldrb	r3, [r3, #0]
 80026f4:	440b      	add	r3, r1
 80026f6:	6013      	str	r3, [r2, #0]
}
 80026f8:	4770      	bx	lr
 80026fa:	bf00      	nop
 80026fc:	200016a4 	.word	0x200016a4
 8002700:	20000000 	.word	0x20000000

08002704 <uart2_set_fcpu>:

unsigned long f_cpu;

/** Functions ----------------------------------------------------------------*/
void uart2_set_fcpu(unsigned long freq)
{
 8002704:	b480      	push	{r7}
 8002706:	b083      	sub	sp, #12
 8002708:	af00      	add	r7, sp, #0
 800270a:	6078      	str	r0, [r7, #4]
	f_cpu = freq;
 800270c:	4a04      	ldr	r2, [pc, #16]	@ (8002720 <uart2_set_fcpu+0x1c>)
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	6013      	str	r3, [r2, #0]
}
 8002712:	bf00      	nop
 8002714:	370c      	adds	r7, #12
 8002716:	46bd      	mov	sp, r7
 8002718:	f85d 7b04 	ldr.w	r7, [sp], #4
 800271c:	4770      	bx	lr
 800271e:	bf00      	nop
 8002720:	200016a8 	.word	0x200016a8

08002724 <uart2_dma1_config>:

	return USART_OK;
}

uart_err_type_t uart2_dma1_config(uint32_t baud, uart_data_type_t ndata, uart_stop_type_t nstop)
{
 8002724:	b5b0      	push	{r4, r5, r7, lr}
 8002726:	b086      	sub	sp, #24
 8002728:	af00      	add	r7, sp, #0
 800272a:	60f8      	str	r0, [r7, #12]
 800272c:	460b      	mov	r3, r1
 800272e:	72fb      	strb	r3, [r7, #11]
 8002730:	4613      	mov	r3, r2
 8002732:	72bb      	strb	r3, [r7, #10]
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;	// enable UART2 clock
 8002734:	4b85      	ldr	r3, [pc, #532]	@ (800294c <uart2_dma1_config+0x228>)
 8002736:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002738:	4a84      	ldr	r2, [pc, #528]	@ (800294c <uart2_dma1_config+0x228>)
 800273a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800273e:	6413      	str	r3, [r2, #64]	@ 0x40
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;	// enable GPIOA clock
 8002740:	4b82      	ldr	r3, [pc, #520]	@ (800294c <uart2_dma1_config+0x228>)
 8002742:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002744:	4a81      	ldr	r2, [pc, #516]	@ (800294c <uart2_dma1_config+0x228>)
 8002746:	f043 0301 	orr.w	r3, r3, #1
 800274a:	6313      	str	r3, [r2, #48]	@ 0x30
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;		// enable DMA1 clock
 800274c:	4b7f      	ldr	r3, [pc, #508]	@ (800294c <uart2_dma1_config+0x228>)
 800274e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002750:	4a7e      	ldr	r2, [pc, #504]	@ (800294c <uart2_dma1_config+0x228>)
 8002752:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8002756:	6313      	str	r3, [r2, #48]	@ 0x30

	/* Setup DMA1 for transmission */
	// disable DMA1 to configure
	DMA1_Stream6->CR &= ~DMA_SxCR_EN;
 8002758:	4b7d      	ldr	r3, [pc, #500]	@ (8002950 <uart2_dma1_config+0x22c>)
 800275a:	681b      	ldr	r3, [r3, #0]
 800275c:	4a7c      	ldr	r2, [pc, #496]	@ (8002950 <uart2_dma1_config+0x22c>)
 800275e:	f023 0301 	bic.w	r3, r3, #1
 8002762:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 8002764:	bf00      	nop
 8002766:	4b7a      	ldr	r3, [pc, #488]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002768:	681b      	ldr	r3, [r3, #0]
 800276a:	f003 0301 	and.w	r3, r3, #1
 800276e:	2b00      	cmp	r3, #0
 8002770:	d1f9      	bne.n	8002766 <uart2_dma1_config+0x42>

	// select stream 6, channel 4 for USART2_TX
	DMA1_Stream6->CR &= ~DMA_SxCR_CHSEL;
 8002772:	4b77      	ldr	r3, [pc, #476]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	4a76      	ldr	r2, [pc, #472]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002778:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
 800277c:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_CHSEL_2;
 800277e:	4b74      	ldr	r3, [pc, #464]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002780:	681b      	ldr	r3, [r3, #0]
 8002782:	4a73      	ldr	r2, [pc, #460]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002784:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8002788:	6013      	str	r3, [r2, #0]

	// disable direct mode
	DMA1_Stream6->FCR |= DMA_SxFCR_DMDIS;
 800278a:	4b71      	ldr	r3, [pc, #452]	@ (8002950 <uart2_dma1_config+0x22c>)
 800278c:	695b      	ldr	r3, [r3, #20]
 800278e:	4a70      	ldr	r2, [pc, #448]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002790:	f043 0304 	orr.w	r3, r3, #4
 8002794:	6153      	str	r3, [r2, #20]

	// normal mode, low priority, 1 byte data size (memory and peripheral)
	DMA1_Stream6->CR &= ~(DMA_SxCR_DBM | DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE);
 8002796:	4b6e      	ldr	r3, [pc, #440]	@ (8002950 <uart2_dma1_config+0x22c>)
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	4a6d      	ldr	r2, [pc, #436]	@ (8002950 <uart2_dma1_config+0x22c>)
 800279c:	f423 23ef 	bic.w	r3, r3, #489472	@ 0x77800
 80027a0:	6013      	str	r3, [r2, #0]

	// memory increment mode
	DMA1_Stream6->CR |= DMA_SxCR_MINC;
 80027a2:	4b6b      	ldr	r3, [pc, #428]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027a4:	681b      	ldr	r3, [r3, #0]
 80027a6:	4a6a      	ldr	r2, [pc, #424]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027a8:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 80027ac:	6013      	str	r3, [r2, #0]

	// fixed peripheral pointer
	DMA1_Stream6->CR &= ~DMA_SxCR_PINC;
 80027ae:	4b68      	ldr	r3, [pc, #416]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027b0:	681b      	ldr	r3, [r3, #0]
 80027b2:	4a67      	ldr	r2, [pc, #412]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027b4:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 80027b8:	6013      	str	r3, [r2, #0]

	// disable circular mode
	DMA1_Stream6->CR &= ~DMA_SxCR_CIRC;
 80027ba:	4b65      	ldr	r3, [pc, #404]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027bc:	681b      	ldr	r3, [r3, #0]
 80027be:	4a64      	ldr	r2, [pc, #400]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027c0:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80027c4:	6013      	str	r3, [r2, #0]

	// memory to peripheral mode
	DMA1_Stream6->CR &= ~DMA_SxCR_DIR_1;
 80027c6:	4b62      	ldr	r3, [pc, #392]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027c8:	681b      	ldr	r3, [r3, #0]
 80027ca:	4a61      	ldr	r2, [pc, #388]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027cc:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80027d0:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_DIR_0;
 80027d2:	4b5f      	ldr	r3, [pc, #380]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027d4:	681b      	ldr	r3, [r3, #0]
 80027d6:	4a5e      	ldr	r2, [pc, #376]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027d8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80027dc:	6013      	str	r3, [r2, #0]

	// peripheral address is USART2_DR
	DMA1_Stream6->PAR = (uint32_t)&(USART2->DR);
 80027de:	4b5c      	ldr	r3, [pc, #368]	@ (8002950 <uart2_dma1_config+0x22c>)
 80027e0:	4a5c      	ldr	r2, [pc, #368]	@ (8002954 <uart2_dma1_config+0x230>)
 80027e2:	609a      	str	r2, [r3, #8]

	/* Setup UART2 for transmission using DMA1 */
	// alternate function mode on TX (PA2) and RX (PA3)
	GPIOA->MODER |= GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;
 80027e4:	4b5c      	ldr	r3, [pc, #368]	@ (8002958 <uart2_dma1_config+0x234>)
 80027e6:	681b      	ldr	r3, [r3, #0]
 80027e8:	4a5b      	ldr	r2, [pc, #364]	@ (8002958 <uart2_dma1_config+0x234>)
 80027ea:	f043 03a0 	orr.w	r3, r3, #160	@ 0xa0
 80027ee:	6013      	str	r3, [r2, #0]
	GPIOA->MODER &= ~(GPIO_MODER_MODER2_0 | GPIO_MODER_MODER3_0);
 80027f0:	4b59      	ldr	r3, [pc, #356]	@ (8002958 <uart2_dma1_config+0x234>)
 80027f2:	681b      	ldr	r3, [r3, #0]
 80027f4:	4a58      	ldr	r2, [pc, #352]	@ (8002958 <uart2_dma1_config+0x234>)
 80027f6:	f023 0350 	bic.w	r3, r3, #80	@ 0x50
 80027fa:	6013      	str	r3, [r2, #0]

	// select alternate function mode 7 for each
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL2 | GPIO_AFRL_AFRL3);
 80027fc:	4b56      	ldr	r3, [pc, #344]	@ (8002958 <uart2_dma1_config+0x234>)
 80027fe:	6a1b      	ldr	r3, [r3, #32]
 8002800:	4a55      	ldr	r2, [pc, #340]	@ (8002958 <uart2_dma1_config+0x234>)
 8002802:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8002806:	6213      	str	r3, [r2, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL2_0 | GPIO_AFRL_AFRL3_0 |
 8002808:	4b53      	ldr	r3, [pc, #332]	@ (8002958 <uart2_dma1_config+0x234>)
 800280a:	6a1b      	ldr	r3, [r3, #32]
 800280c:	4a52      	ldr	r2, [pc, #328]	@ (8002958 <uart2_dma1_config+0x234>)
 800280e:	f443 43ee 	orr.w	r3, r3, #30464	@ 0x7700
 8002812:	6213      	str	r3, [r2, #32]
					GPIO_AFRL_AFRL2_1 | GPIO_AFRL_AFRL3_1 |
					GPIO_AFRL_AFRL2_2 | GPIO_AFRL_AFRL3_2;

	USART2->CR1 |= USART_CR1_UE;			// UART2 enable
 8002814:	4b51      	ldr	r3, [pc, #324]	@ (800295c <uart2_dma1_config+0x238>)
 8002816:	68db      	ldr	r3, [r3, #12]
 8002818:	4a50      	ldr	r2, [pc, #320]	@ (800295c <uart2_dma1_config+0x238>)
 800281a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800281e:	60d3      	str	r3, [r2, #12]

	if (ndata == USART_DATA_8)
 8002820:	7afb      	ldrb	r3, [r7, #11]
 8002822:	2b00      	cmp	r3, #0
 8002824:	d106      	bne.n	8002834 <uart2_dma1_config+0x110>
	{
		USART2->CR1 &= ~USART_CR1_M;		// 1 start, 8 data, n stop
 8002826:	4b4d      	ldr	r3, [pc, #308]	@ (800295c <uart2_dma1_config+0x238>)
 8002828:	68db      	ldr	r3, [r3, #12]
 800282a:	4a4c      	ldr	r2, [pc, #304]	@ (800295c <uart2_dma1_config+0x238>)
 800282c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8002830:	60d3      	str	r3, [r2, #12]
 8002832:	e00b      	b.n	800284c <uart2_dma1_config+0x128>
	}
	else if (ndata == USART_DATA_9)
 8002834:	7afb      	ldrb	r3, [r7, #11]
 8002836:	2b01      	cmp	r3, #1
 8002838:	d106      	bne.n	8002848 <uart2_dma1_config+0x124>
	{
		USART2->CR1 |= USART_CR1_M;			// 1 start, 9 data, n stop
 800283a:	4b48      	ldr	r3, [pc, #288]	@ (800295c <uart2_dma1_config+0x238>)
 800283c:	68db      	ldr	r3, [r3, #12]
 800283e:	4a47      	ldr	r2, [pc, #284]	@ (800295c <uart2_dma1_config+0x238>)
 8002840:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8002844:	60d3      	str	r3, [r2, #12]
 8002846:	e001      	b.n	800284c <uart2_dma1_config+0x128>
	}
	else
	{
		return USART_INVALID_NDATA;
 8002848:	2302      	movs	r3, #2
 800284a:	e07b      	b.n	8002944 <uart2_dma1_config+0x220>
	}

	if (nstop == USART_STOP_1)
 800284c:	7abb      	ldrb	r3, [r7, #10]
 800284e:	2b00      	cmp	r3, #0
 8002850:	d106      	bne.n	8002860 <uart2_dma1_config+0x13c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 1 stop bit
 8002852:	4b42      	ldr	r3, [pc, #264]	@ (800295c <uart2_dma1_config+0x238>)
 8002854:	691b      	ldr	r3, [r3, #16]
 8002856:	4a41      	ldr	r2, [pc, #260]	@ (800295c <uart2_dma1_config+0x238>)
 8002858:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 800285c:	6113      	str	r3, [r2, #16]
 800285e:	e021      	b.n	80028a4 <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_HALF)
 8002860:	7abb      	ldrb	r3, [r7, #10]
 8002862:	2b01      	cmp	r3, #1
 8002864:	d10c      	bne.n	8002880 <uart2_dma1_config+0x15c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// half stop bit
 8002866:	4b3d      	ldr	r3, [pc, #244]	@ (800295c <uart2_dma1_config+0x238>)
 8002868:	691b      	ldr	r3, [r3, #16]
 800286a:	4a3c      	ldr	r2, [pc, #240]	@ (800295c <uart2_dma1_config+0x238>)
 800286c:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002870:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_0;
 8002872:	4b3a      	ldr	r3, [pc, #232]	@ (800295c <uart2_dma1_config+0x238>)
 8002874:	691b      	ldr	r3, [r3, #16]
 8002876:	4a39      	ldr	r2, [pc, #228]	@ (800295c <uart2_dma1_config+0x238>)
 8002878:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800287c:	6113      	str	r3, [r2, #16]
 800287e:	e011      	b.n	80028a4 <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_2)
 8002880:	7abb      	ldrb	r3, [r7, #10]
 8002882:	2b02      	cmp	r3, #2
 8002884:	d10c      	bne.n	80028a0 <uart2_dma1_config+0x17c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 2 stop bits
 8002886:	4b35      	ldr	r3, [pc, #212]	@ (800295c <uart2_dma1_config+0x238>)
 8002888:	691b      	ldr	r3, [r3, #16]
 800288a:	4a34      	ldr	r2, [pc, #208]	@ (800295c <uart2_dma1_config+0x238>)
 800288c:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002890:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_1;
 8002892:	4b32      	ldr	r3, [pc, #200]	@ (800295c <uart2_dma1_config+0x238>)
 8002894:	691b      	ldr	r3, [r3, #16]
 8002896:	4a31      	ldr	r2, [pc, #196]	@ (800295c <uart2_dma1_config+0x238>)
 8002898:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800289c:	6113      	str	r3, [r2, #16]
 800289e:	e001      	b.n	80028a4 <uart2_dma1_config+0x180>
	}
	else
	{
		return USART_INVALID_NSTOP;
 80028a0:	2301      	movs	r3, #1
 80028a2:	e04f      	b.n	8002944 <uart2_dma1_config+0x220>
	}

	// pg. 519 STM32F401RE reference
	float usart_div = f_cpu / (2 * 16.0 * baud);		// APB1 bus is 1/2 clock speed of f_cpu
 80028a4:	4b2e      	ldr	r3, [pc, #184]	@ (8002960 <uart2_dma1_config+0x23c>)
 80028a6:	681b      	ldr	r3, [r3, #0]
 80028a8:	4618      	mov	r0, r3
 80028aa:	f7fd fdd7 	bl	800045c <__aeabi_ui2d>
 80028ae:	4604      	mov	r4, r0
 80028b0:	460d      	mov	r5, r1
 80028b2:	68f8      	ldr	r0, [r7, #12]
 80028b4:	f7fd fdd2 	bl	800045c <__aeabi_ui2d>
 80028b8:	f04f 0200 	mov.w	r2, #0
 80028bc:	4b29      	ldr	r3, [pc, #164]	@ (8002964 <uart2_dma1_config+0x240>)
 80028be:	f7fd fe47 	bl	8000550 <__aeabi_dmul>
 80028c2:	4602      	mov	r2, r0
 80028c4:	460b      	mov	r3, r1
 80028c6:	4620      	mov	r0, r4
 80028c8:	4629      	mov	r1, r5
 80028ca:	f7fd ff6b 	bl	80007a4 <__aeabi_ddiv>
 80028ce:	4602      	mov	r2, r0
 80028d0:	460b      	mov	r3, r1
 80028d2:	4610      	mov	r0, r2
 80028d4:	4619      	mov	r1, r3
 80028d6:	f7fe f8d5 	bl	8000a84 <__aeabi_d2f>
 80028da:	4603      	mov	r3, r0
 80028dc:	617b      	str	r3, [r7, #20]
	uint16_t mantissa = (uint16_t) usart_div;
 80028de:	edd7 7a05 	vldr	s15, [r7, #20]
 80028e2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80028e6:	ee17 3a90 	vmov	r3, s15
 80028ea:	827b      	strh	r3, [r7, #18]
	uint8_t fraction = (uint8_t) ((usart_div - mantissa) * 16);
 80028ec:	8a7b      	ldrh	r3, [r7, #18]
 80028ee:	ee07 3a90 	vmov	s15, r3
 80028f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80028f6:	ed97 7a05 	vldr	s14, [r7, #20]
 80028fa:	ee77 7a67 	vsub.f32	s15, s14, s15
 80028fe:	eeb3 7a00 	vmov.f32	s14, #48	@ 0x41800000  16.0
 8002902:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002906:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800290a:	edc7 7a01 	vstr	s15, [r7, #4]
 800290e:	793b      	ldrb	r3, [r7, #4]
 8002910:	747b      	strb	r3, [r7, #17]
	USART2->BRR = mantissa << 4 | fraction;
 8002912:	8a7b      	ldrh	r3, [r7, #18]
 8002914:	011a      	lsls	r2, r3, #4
 8002916:	7c7b      	ldrb	r3, [r7, #17]
 8002918:	431a      	orrs	r2, r3
 800291a:	4b10      	ldr	r3, [pc, #64]	@ (800295c <uart2_dma1_config+0x238>)
 800291c:	609a      	str	r2, [r3, #8]

	USART2->CR3 |= USART_CR3_DMAT;		// enable DMA transmitter
 800291e:	4b0f      	ldr	r3, [pc, #60]	@ (800295c <uart2_dma1_config+0x238>)
 8002920:	695b      	ldr	r3, [r3, #20]
 8002922:	4a0e      	ldr	r2, [pc, #56]	@ (800295c <uart2_dma1_config+0x238>)
 8002924:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002928:	6153      	str	r3, [r2, #20]

	USART2->CR1 |= USART_CR1_TE;		// transmitter enable
 800292a:	4b0c      	ldr	r3, [pc, #48]	@ (800295c <uart2_dma1_config+0x238>)
 800292c:	68db      	ldr	r3, [r3, #12]
 800292e:	4a0b      	ldr	r2, [pc, #44]	@ (800295c <uart2_dma1_config+0x238>)
 8002930:	f043 0308 	orr.w	r3, r3, #8
 8002934:	60d3      	str	r3, [r2, #12]
	USART2->CR1 |= USART_CR1_RE;		// receiver enable
 8002936:	4b09      	ldr	r3, [pc, #36]	@ (800295c <uart2_dma1_config+0x238>)
 8002938:	68db      	ldr	r3, [r3, #12]
 800293a:	4a08      	ldr	r2, [pc, #32]	@ (800295c <uart2_dma1_config+0x238>)
 800293c:	f043 0304 	orr.w	r3, r3, #4
 8002940:	60d3      	str	r3, [r2, #12]

	return USART_OK;
 8002942:	2300      	movs	r3, #0
}
 8002944:	4618      	mov	r0, r3
 8002946:	3718      	adds	r7, #24
 8002948:	46bd      	mov	sp, r7
 800294a:	bdb0      	pop	{r4, r5, r7, pc}
 800294c:	40023800 	.word	0x40023800
 8002950:	400260a0 	.word	0x400260a0
 8002954:	40004404 	.word	0x40004404
 8002958:	40020000 	.word	0x40020000
 800295c:	40004400 	.word	0x40004400
 8002960:	200016a8 	.word	0x200016a8
 8002964:	40400000 	.word	0x40400000

08002968 <uart2_dma1_write>:

	return USART_OK;
}

void uart2_dma1_write(uint16_t n, uint8_t * data)
{
 8002968:	b480      	push	{r7}
 800296a:	b083      	sub	sp, #12
 800296c:	af00      	add	r7, sp, #0
 800296e:	4603      	mov	r3, r0
 8002970:	6039      	str	r1, [r7, #0]
 8002972:	80fb      	strh	r3, [r7, #6]
	while (!(USART2->SR & USART_SR_TXE));	// wait for transmit data register empty
 8002974:	bf00      	nop
 8002976:	4b18      	ldr	r3, [pc, #96]	@ (80029d8 <uart2_dma1_write+0x70>)
 8002978:	681b      	ldr	r3, [r3, #0]
 800297a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800297e:	2b00      	cmp	r3, #0
 8002980:	d0f9      	beq.n	8002976 <uart2_dma1_write+0xe>
	USART2->SR &= ~USART_SR_TC;				// clear flag
 8002982:	4b15      	ldr	r3, [pc, #84]	@ (80029d8 <uart2_dma1_write+0x70>)
 8002984:	681b      	ldr	r3, [r3, #0]
 8002986:	4a14      	ldr	r2, [pc, #80]	@ (80029d8 <uart2_dma1_write+0x70>)
 8002988:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800298c:	6013      	str	r3, [r2, #0]

	DMA1_Stream6->CR &= ~DMA_SxCR_EN;		// disable DMA stream
 800298e:	4b13      	ldr	r3, [pc, #76]	@ (80029dc <uart2_dma1_write+0x74>)
 8002990:	681b      	ldr	r3, [r3, #0]
 8002992:	4a12      	ldr	r2, [pc, #72]	@ (80029dc <uart2_dma1_write+0x74>)
 8002994:	f023 0301 	bic.w	r3, r3, #1
 8002998:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 800299a:	bf00      	nop
 800299c:	4b0f      	ldr	r3, [pc, #60]	@ (80029dc <uart2_dma1_write+0x74>)
 800299e:	681b      	ldr	r3, [r3, #0]
 80029a0:	f003 0301 	and.w	r3, r3, #1
 80029a4:	2b00      	cmp	r3, #0
 80029a6:	d1f9      	bne.n	800299c <uart2_dma1_write+0x34>

	// clear flags
	DMA1->HIFCR |= DMA_HIFCR_CTCIF6 | DMA_HIFCR_CHTIF6 | DMA_HIFCR_CTEIF6 | DMA_HIFCR_CDMEIF6 | DMA_HIFCR_CFEIF6;
 80029a8:	4b0d      	ldr	r3, [pc, #52]	@ (80029e0 <uart2_dma1_write+0x78>)
 80029aa:	68db      	ldr	r3, [r3, #12]
 80029ac:	4a0c      	ldr	r2, [pc, #48]	@ (80029e0 <uart2_dma1_write+0x78>)
 80029ae:	f443 1374 	orr.w	r3, r3, #3997696	@ 0x3d0000
 80029b2:	60d3      	str	r3, [r2, #12]

	DMA1_Stream6->NDTR = n;					// set # of data items to transfer
 80029b4:	4a09      	ldr	r2, [pc, #36]	@ (80029dc <uart2_dma1_write+0x74>)
 80029b6:	88fb      	ldrh	r3, [r7, #6]
 80029b8:	6053      	str	r3, [r2, #4]
	DMA1_Stream6->M0AR = (uint32_t) data;	// pointer to data
 80029ba:	4a08      	ldr	r2, [pc, #32]	@ (80029dc <uart2_dma1_write+0x74>)
 80029bc:	683b      	ldr	r3, [r7, #0]
 80029be:	60d3      	str	r3, [r2, #12]
	DMA1_Stream6->CR |= DMA_SxCR_EN;		// enable DMA stream
 80029c0:	4b06      	ldr	r3, [pc, #24]	@ (80029dc <uart2_dma1_write+0x74>)
 80029c2:	681b      	ldr	r3, [r3, #0]
 80029c4:	4a05      	ldr	r2, [pc, #20]	@ (80029dc <uart2_dma1_write+0x74>)
 80029c6:	f043 0301 	orr.w	r3, r3, #1
 80029ca:	6013      	str	r3, [r2, #0]
}
 80029cc:	bf00      	nop
 80029ce:	370c      	adds	r7, #12
 80029d0:	46bd      	mov	sp, r7
 80029d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80029d6:	4770      	bx	lr
 80029d8:	40004400 	.word	0x40004400
 80029dc:	400260a0 	.word	0x400260a0
 80029e0:	40026000 	.word	0x40026000

080029e4 <memset>:
 80029e4:	4402      	add	r2, r0
 80029e6:	4603      	mov	r3, r0
 80029e8:	4293      	cmp	r3, r2
 80029ea:	d100      	bne.n	80029ee <memset+0xa>
 80029ec:	4770      	bx	lr
 80029ee:	f803 1b01 	strb.w	r1, [r3], #1
 80029f2:	e7f9      	b.n	80029e8 <memset+0x4>

080029f4 <__libc_init_array>:
 80029f4:	b570      	push	{r4, r5, r6, lr}
 80029f6:	4d0d      	ldr	r5, [pc, #52]	@ (8002a2c <__libc_init_array+0x38>)
 80029f8:	4c0d      	ldr	r4, [pc, #52]	@ (8002a30 <__libc_init_array+0x3c>)
 80029fa:	1b64      	subs	r4, r4, r5
 80029fc:	10a4      	asrs	r4, r4, #2
 80029fe:	2600      	movs	r6, #0
 8002a00:	42a6      	cmp	r6, r4
 8002a02:	d109      	bne.n	8002a18 <__libc_init_array+0x24>
 8002a04:	4d0b      	ldr	r5, [pc, #44]	@ (8002a34 <__libc_init_array+0x40>)
 8002a06:	4c0c      	ldr	r4, [pc, #48]	@ (8002a38 <__libc_init_array+0x44>)
 8002a08:	f000 f818 	bl	8002a3c <_init>
 8002a0c:	1b64      	subs	r4, r4, r5
 8002a0e:	10a4      	asrs	r4, r4, #2
 8002a10:	2600      	movs	r6, #0
 8002a12:	42a6      	cmp	r6, r4
 8002a14:	d105      	bne.n	8002a22 <__libc_init_array+0x2e>
 8002a16:	bd70      	pop	{r4, r5, r6, pc}
 8002a18:	f855 3b04 	ldr.w	r3, [r5], #4
 8002a1c:	4798      	blx	r3
 8002a1e:	3601      	adds	r6, #1
 8002a20:	e7ee      	b.n	8002a00 <__libc_init_array+0xc>
 8002a22:	f855 3b04 	ldr.w	r3, [r5], #4
 8002a26:	4798      	blx	r3
 8002a28:	3601      	adds	r6, #1
 8002a2a:	e7f2      	b.n	8002a12 <__libc_init_array+0x1e>
 8002a2c:	0800356c 	.word	0x0800356c
 8002a30:	0800356c 	.word	0x0800356c
 8002a34:	0800356c 	.word	0x0800356c
 8002a38:	08003570 	.word	0x08003570

08002a3c <_init>:
 8002a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a3e:	bf00      	nop
 8002a40:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002a42:	bc08      	pop	{r3}
 8002a44:	469e      	mov	lr, r3
 8002a46:	4770      	bx	lr

08002a48 <_fini>:
 8002a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a4a:	bf00      	nop
 8002a4c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002a4e:	bc08      	pop	{r3}
 8002a50:	469e      	mov	lr, r3
 8002a52:	4770      	bx	lr
