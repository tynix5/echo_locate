
echo_locate.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000029a4  08000198  08000198  00001198  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b18  08002b3c  08002b3c  00003b3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08003654  08003654  00005004  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  08003654  08003654  00005004  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  08003654  08003654  00005004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08003654  08003654  00004654  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08003658  08003658  00004658  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000004  20000000  0800365c  00005000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000016a8  20000004  08003660  00005004  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200016ac  08003660  000056ac  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00005004  2**0
                  CONTENTS, READONLY
 12 .debug_info   00007ee5  00000000  00000000  00005034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001969  00000000  00000000  0000cf19  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 00003148  00000000  00000000  0000e882  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000458  00000000  00000000  000119d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000507  00000000  00000000  00011e28  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000265bf  00000000  00000000  0001232f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000adfd  00000000  00000000  000388ee  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0008610c  00000000  00000000  000436eb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  000c97f7  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00000c0c  00000000  00000000  000c983c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000070  00000000  00000000  000ca448  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000004 	.word	0x20000004
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08002b24 	.word	0x08002b24

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000008 	.word	0x20000008
 80001d4:	08002b24 	.word	0x08002b24

080001d8 <__aeabi_drsub>:
 80001d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80001dc:	e002      	b.n	80001e4 <__adddf3>
 80001de:	bf00      	nop

080001e0 <__aeabi_dsub>:
 80001e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080001e4 <__adddf3>:
 80001e4:	b530      	push	{r4, r5, lr}
 80001e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80001ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80001ee:	ea94 0f05 	teq	r4, r5
 80001f2:	bf08      	it	eq
 80001f4:	ea90 0f02 	teqeq	r0, r2
 80001f8:	bf1f      	itttt	ne
 80001fa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80001fe:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000202:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000206:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800020a:	f000 80e2 	beq.w	80003d2 <__adddf3+0x1ee>
 800020e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000212:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000216:	bfb8      	it	lt
 8000218:	426d      	neglt	r5, r5
 800021a:	dd0c      	ble.n	8000236 <__adddf3+0x52>
 800021c:	442c      	add	r4, r5
 800021e:	ea80 0202 	eor.w	r2, r0, r2
 8000222:	ea81 0303 	eor.w	r3, r1, r3
 8000226:	ea82 0000 	eor.w	r0, r2, r0
 800022a:	ea83 0101 	eor.w	r1, r3, r1
 800022e:	ea80 0202 	eor.w	r2, r0, r2
 8000232:	ea81 0303 	eor.w	r3, r1, r3
 8000236:	2d36      	cmp	r5, #54	@ 0x36
 8000238:	bf88      	it	hi
 800023a:	bd30      	pophi	{r4, r5, pc}
 800023c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000240:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000244:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000248:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800024c:	d002      	beq.n	8000254 <__adddf3+0x70>
 800024e:	4240      	negs	r0, r0
 8000250:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000254:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000258:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800025c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000260:	d002      	beq.n	8000268 <__adddf3+0x84>
 8000262:	4252      	negs	r2, r2
 8000264:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000268:	ea94 0f05 	teq	r4, r5
 800026c:	f000 80a7 	beq.w	80003be <__adddf3+0x1da>
 8000270:	f1a4 0401 	sub.w	r4, r4, #1
 8000274:	f1d5 0e20 	rsbs	lr, r5, #32
 8000278:	db0d      	blt.n	8000296 <__adddf3+0xb2>
 800027a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800027e:	fa22 f205 	lsr.w	r2, r2, r5
 8000282:	1880      	adds	r0, r0, r2
 8000284:	f141 0100 	adc.w	r1, r1, #0
 8000288:	fa03 f20e 	lsl.w	r2, r3, lr
 800028c:	1880      	adds	r0, r0, r2
 800028e:	fa43 f305 	asr.w	r3, r3, r5
 8000292:	4159      	adcs	r1, r3
 8000294:	e00e      	b.n	80002b4 <__adddf3+0xd0>
 8000296:	f1a5 0520 	sub.w	r5, r5, #32
 800029a:	f10e 0e20 	add.w	lr, lr, #32
 800029e:	2a01      	cmp	r2, #1
 80002a0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002a4:	bf28      	it	cs
 80002a6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002aa:	fa43 f305 	asr.w	r3, r3, r5
 80002ae:	18c0      	adds	r0, r0, r3
 80002b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80002b8:	d507      	bpl.n	80002ca <__adddf3+0xe6>
 80002ba:	f04f 0e00 	mov.w	lr, #0
 80002be:	f1dc 0c00 	rsbs	ip, ip, #0
 80002c2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002c6:	eb6e 0101 	sbc.w	r1, lr, r1
 80002ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80002ce:	d31b      	bcc.n	8000308 <__adddf3+0x124>
 80002d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80002d4:	d30c      	bcc.n	80002f0 <__adddf3+0x10c>
 80002d6:	0849      	lsrs	r1, r1, #1
 80002d8:	ea5f 0030 	movs.w	r0, r0, rrx
 80002dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80002e0:	f104 0401 	add.w	r4, r4, #1
 80002e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80002e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80002ec:	f080 809a 	bcs.w	8000424 <__adddf3+0x240>
 80002f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80002f4:	bf08      	it	eq
 80002f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80002fa:	f150 0000 	adcs.w	r0, r0, #0
 80002fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000302:	ea41 0105 	orr.w	r1, r1, r5
 8000306:	bd30      	pop	{r4, r5, pc}
 8000308:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800030c:	4140      	adcs	r0, r0
 800030e:	eb41 0101 	adc.w	r1, r1, r1
 8000312:	3c01      	subs	r4, #1
 8000314:	bf28      	it	cs
 8000316:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800031a:	d2e9      	bcs.n	80002f0 <__adddf3+0x10c>
 800031c:	f091 0f00 	teq	r1, #0
 8000320:	bf04      	itt	eq
 8000322:	4601      	moveq	r1, r0
 8000324:	2000      	moveq	r0, #0
 8000326:	fab1 f381 	clz	r3, r1
 800032a:	bf08      	it	eq
 800032c:	3320      	addeq	r3, #32
 800032e:	f1a3 030b 	sub.w	r3, r3, #11
 8000332:	f1b3 0220 	subs.w	r2, r3, #32
 8000336:	da0c      	bge.n	8000352 <__adddf3+0x16e>
 8000338:	320c      	adds	r2, #12
 800033a:	dd08      	ble.n	800034e <__adddf3+0x16a>
 800033c:	f102 0c14 	add.w	ip, r2, #20
 8000340:	f1c2 020c 	rsb	r2, r2, #12
 8000344:	fa01 f00c 	lsl.w	r0, r1, ip
 8000348:	fa21 f102 	lsr.w	r1, r1, r2
 800034c:	e00c      	b.n	8000368 <__adddf3+0x184>
 800034e:	f102 0214 	add.w	r2, r2, #20
 8000352:	bfd8      	it	le
 8000354:	f1c2 0c20 	rsble	ip, r2, #32
 8000358:	fa01 f102 	lsl.w	r1, r1, r2
 800035c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000360:	bfdc      	itt	le
 8000362:	ea41 010c 	orrle.w	r1, r1, ip
 8000366:	4090      	lslle	r0, r2
 8000368:	1ae4      	subs	r4, r4, r3
 800036a:	bfa2      	ittt	ge
 800036c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000370:	4329      	orrge	r1, r5
 8000372:	bd30      	popge	{r4, r5, pc}
 8000374:	ea6f 0404 	mvn.w	r4, r4
 8000378:	3c1f      	subs	r4, #31
 800037a:	da1c      	bge.n	80003b6 <__adddf3+0x1d2>
 800037c:	340c      	adds	r4, #12
 800037e:	dc0e      	bgt.n	800039e <__adddf3+0x1ba>
 8000380:	f104 0414 	add.w	r4, r4, #20
 8000384:	f1c4 0220 	rsb	r2, r4, #32
 8000388:	fa20 f004 	lsr.w	r0, r0, r4
 800038c:	fa01 f302 	lsl.w	r3, r1, r2
 8000390:	ea40 0003 	orr.w	r0, r0, r3
 8000394:	fa21 f304 	lsr.w	r3, r1, r4
 8000398:	ea45 0103 	orr.w	r1, r5, r3
 800039c:	bd30      	pop	{r4, r5, pc}
 800039e:	f1c4 040c 	rsb	r4, r4, #12
 80003a2:	f1c4 0220 	rsb	r2, r4, #32
 80003a6:	fa20 f002 	lsr.w	r0, r0, r2
 80003aa:	fa01 f304 	lsl.w	r3, r1, r4
 80003ae:	ea40 0003 	orr.w	r0, r0, r3
 80003b2:	4629      	mov	r1, r5
 80003b4:	bd30      	pop	{r4, r5, pc}
 80003b6:	fa21 f004 	lsr.w	r0, r1, r4
 80003ba:	4629      	mov	r1, r5
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	f094 0f00 	teq	r4, #0
 80003c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80003c6:	bf06      	itte	eq
 80003c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80003cc:	3401      	addeq	r4, #1
 80003ce:	3d01      	subne	r5, #1
 80003d0:	e74e      	b.n	8000270 <__adddf3+0x8c>
 80003d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003d6:	bf18      	it	ne
 80003d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003dc:	d029      	beq.n	8000432 <__adddf3+0x24e>
 80003de:	ea94 0f05 	teq	r4, r5
 80003e2:	bf08      	it	eq
 80003e4:	ea90 0f02 	teqeq	r0, r2
 80003e8:	d005      	beq.n	80003f6 <__adddf3+0x212>
 80003ea:	ea54 0c00 	orrs.w	ip, r4, r0
 80003ee:	bf04      	itt	eq
 80003f0:	4619      	moveq	r1, r3
 80003f2:	4610      	moveq	r0, r2
 80003f4:	bd30      	pop	{r4, r5, pc}
 80003f6:	ea91 0f03 	teq	r1, r3
 80003fa:	bf1e      	ittt	ne
 80003fc:	2100      	movne	r1, #0
 80003fe:	2000      	movne	r0, #0
 8000400:	bd30      	popne	{r4, r5, pc}
 8000402:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000406:	d105      	bne.n	8000414 <__adddf3+0x230>
 8000408:	0040      	lsls	r0, r0, #1
 800040a:	4149      	adcs	r1, r1
 800040c:	bf28      	it	cs
 800040e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000412:	bd30      	pop	{r4, r5, pc}
 8000414:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000418:	bf3c      	itt	cc
 800041a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 800041e:	bd30      	popcc	{r4, r5, pc}
 8000420:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000424:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000428:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800042c:	f04f 0000 	mov.w	r0, #0
 8000430:	bd30      	pop	{r4, r5, pc}
 8000432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000436:	bf1a      	itte	ne
 8000438:	4619      	movne	r1, r3
 800043a:	4610      	movne	r0, r2
 800043c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000440:	bf1c      	itt	ne
 8000442:	460b      	movne	r3, r1
 8000444:	4602      	movne	r2, r0
 8000446:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800044a:	bf06      	itte	eq
 800044c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000450:	ea91 0f03 	teqeq	r1, r3
 8000454:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000458:	bd30      	pop	{r4, r5, pc}
 800045a:	bf00      	nop

0800045c <__aeabi_ui2d>:
 800045c:	f090 0f00 	teq	r0, #0
 8000460:	bf04      	itt	eq
 8000462:	2100      	moveq	r1, #0
 8000464:	4770      	bxeq	lr
 8000466:	b530      	push	{r4, r5, lr}
 8000468:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800046c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000470:	f04f 0500 	mov.w	r5, #0
 8000474:	f04f 0100 	mov.w	r1, #0
 8000478:	e750      	b.n	800031c <__adddf3+0x138>
 800047a:	bf00      	nop

0800047c <__aeabi_i2d>:
 800047c:	f090 0f00 	teq	r0, #0
 8000480:	bf04      	itt	eq
 8000482:	2100      	moveq	r1, #0
 8000484:	4770      	bxeq	lr
 8000486:	b530      	push	{r4, r5, lr}
 8000488:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800048c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000490:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000494:	bf48      	it	mi
 8000496:	4240      	negmi	r0, r0
 8000498:	f04f 0100 	mov.w	r1, #0
 800049c:	e73e      	b.n	800031c <__adddf3+0x138>
 800049e:	bf00      	nop

080004a0 <__aeabi_f2d>:
 80004a0:	0042      	lsls	r2, r0, #1
 80004a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004a6:	ea4f 0131 	mov.w	r1, r1, rrx
 80004aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ae:	bf1f      	itttt	ne
 80004b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80004b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80004b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80004bc:	4770      	bxne	lr
 80004be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80004c2:	bf08      	it	eq
 80004c4:	4770      	bxeq	lr
 80004c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80004ca:	bf04      	itt	eq
 80004cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80004d0:	4770      	bxeq	lr
 80004d2:	b530      	push	{r4, r5, lr}
 80004d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80004e0:	e71c      	b.n	800031c <__adddf3+0x138>
 80004e2:	bf00      	nop

080004e4 <__aeabi_ul2d>:
 80004e4:	ea50 0201 	orrs.w	r2, r0, r1
 80004e8:	bf08      	it	eq
 80004ea:	4770      	bxeq	lr
 80004ec:	b530      	push	{r4, r5, lr}
 80004ee:	f04f 0500 	mov.w	r5, #0
 80004f2:	e00a      	b.n	800050a <__aeabi_l2d+0x16>

080004f4 <__aeabi_l2d>:
 80004f4:	ea50 0201 	orrs.w	r2, r0, r1
 80004f8:	bf08      	it	eq
 80004fa:	4770      	bxeq	lr
 80004fc:	b530      	push	{r4, r5, lr}
 80004fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000502:	d502      	bpl.n	800050a <__aeabi_l2d+0x16>
 8000504:	4240      	negs	r0, r0
 8000506:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800050a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800050e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000512:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000516:	f43f aed8 	beq.w	80002ca <__adddf3+0xe6>
 800051a:	f04f 0203 	mov.w	r2, #3
 800051e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000522:	bf18      	it	ne
 8000524:	3203      	addne	r2, #3
 8000526:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800052a:	bf18      	it	ne
 800052c:	3203      	addne	r2, #3
 800052e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000532:	f1c2 0320 	rsb	r3, r2, #32
 8000536:	fa00 fc03 	lsl.w	ip, r0, r3
 800053a:	fa20 f002 	lsr.w	r0, r0, r2
 800053e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000542:	ea40 000e 	orr.w	r0, r0, lr
 8000546:	fa21 f102 	lsr.w	r1, r1, r2
 800054a:	4414      	add	r4, r2
 800054c:	e6bd      	b.n	80002ca <__adddf3+0xe6>
 800054e:	bf00      	nop

08000550 <__aeabi_dmul>:
 8000550:	b570      	push	{r4, r5, r6, lr}
 8000552:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000556:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 800055a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800055e:	bf1d      	ittte	ne
 8000560:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000564:	ea94 0f0c 	teqne	r4, ip
 8000568:	ea95 0f0c 	teqne	r5, ip
 800056c:	f000 f8de 	bleq	800072c <__aeabi_dmul+0x1dc>
 8000570:	442c      	add	r4, r5
 8000572:	ea81 0603 	eor.w	r6, r1, r3
 8000576:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800057a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800057e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000582:	bf18      	it	ne
 8000584:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000588:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 800058c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000590:	d038      	beq.n	8000604 <__aeabi_dmul+0xb4>
 8000592:	fba0 ce02 	umull	ip, lr, r0, r2
 8000596:	f04f 0500 	mov.w	r5, #0
 800059a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800059e:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 80005a2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005a6:	f04f 0600 	mov.w	r6, #0
 80005aa:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ae:	f09c 0f00 	teq	ip, #0
 80005b2:	bf18      	it	ne
 80005b4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005b8:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 80005bc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 80005c0:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 80005c4:	d204      	bcs.n	80005d0 <__aeabi_dmul+0x80>
 80005c6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ca:	416d      	adcs	r5, r5
 80005cc:	eb46 0606 	adc.w	r6, r6, r6
 80005d0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005d4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005d8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005dc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80005e0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80005e4:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80005e8:	bf88      	it	hi
 80005ea:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80005ee:	d81e      	bhi.n	800062e <__aeabi_dmul+0xde>
 80005f0:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80005f4:	bf08      	it	eq
 80005f6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80005fa:	f150 0000 	adcs.w	r0, r0, #0
 80005fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000602:	bd70      	pop	{r4, r5, r6, pc}
 8000604:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8000608:	ea46 0101 	orr.w	r1, r6, r1
 800060c:	ea40 0002 	orr.w	r0, r0, r2
 8000610:	ea81 0103 	eor.w	r1, r1, r3
 8000614:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000618:	bfc2      	ittt	gt
 800061a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800061e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000622:	bd70      	popgt	{r4, r5, r6, pc}
 8000624:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000628:	f04f 0e00 	mov.w	lr, #0
 800062c:	3c01      	subs	r4, #1
 800062e:	f300 80ab 	bgt.w	8000788 <__aeabi_dmul+0x238>
 8000632:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 8000636:	bfde      	ittt	le
 8000638:	2000      	movle	r0, #0
 800063a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 800063e:	bd70      	pople	{r4, r5, r6, pc}
 8000640:	f1c4 0400 	rsb	r4, r4, #0
 8000644:	3c20      	subs	r4, #32
 8000646:	da35      	bge.n	80006b4 <__aeabi_dmul+0x164>
 8000648:	340c      	adds	r4, #12
 800064a:	dc1b      	bgt.n	8000684 <__aeabi_dmul+0x134>
 800064c:	f104 0414 	add.w	r4, r4, #20
 8000650:	f1c4 0520 	rsb	r5, r4, #32
 8000654:	fa00 f305 	lsl.w	r3, r0, r5
 8000658:	fa20 f004 	lsr.w	r0, r0, r4
 800065c:	fa01 f205 	lsl.w	r2, r1, r5
 8000660:	ea40 0002 	orr.w	r0, r0, r2
 8000664:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000668:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 800066c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000670:	fa21 f604 	lsr.w	r6, r1, r4
 8000674:	eb42 0106 	adc.w	r1, r2, r6
 8000678:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800067c:	bf08      	it	eq
 800067e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f1c4 040c 	rsb	r4, r4, #12
 8000688:	f1c4 0520 	rsb	r5, r4, #32
 800068c:	fa00 f304 	lsl.w	r3, r0, r4
 8000690:	fa20 f005 	lsr.w	r0, r0, r5
 8000694:	fa01 f204 	lsl.w	r2, r1, r4
 8000698:	ea40 0002 	orr.w	r0, r0, r2
 800069c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006a0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006a4:	f141 0100 	adc.w	r1, r1, #0
 80006a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006ac:	bf08      	it	eq
 80006ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006b2:	bd70      	pop	{r4, r5, r6, pc}
 80006b4:	f1c4 0520 	rsb	r5, r4, #32
 80006b8:	fa00 f205 	lsl.w	r2, r0, r5
 80006bc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006c0:	fa20 f304 	lsr.w	r3, r0, r4
 80006c4:	fa01 f205 	lsl.w	r2, r1, r5
 80006c8:	ea43 0302 	orr.w	r3, r3, r2
 80006cc:	fa21 f004 	lsr.w	r0, r1, r4
 80006d0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80006d4:	fa21 f204 	lsr.w	r2, r1, r4
 80006d8:	ea20 0002 	bic.w	r0, r0, r2
 80006dc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80006e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006e4:	bf08      	it	eq
 80006e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f094 0f00 	teq	r4, #0
 80006f0:	d10f      	bne.n	8000712 <__aeabi_dmul+0x1c2>
 80006f2:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80006f6:	0040      	lsls	r0, r0, #1
 80006f8:	eb41 0101 	adc.w	r1, r1, r1
 80006fc:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000700:	bf08      	it	eq
 8000702:	3c01      	subeq	r4, #1
 8000704:	d0f7      	beq.n	80006f6 <__aeabi_dmul+0x1a6>
 8000706:	ea41 0106 	orr.w	r1, r1, r6
 800070a:	f095 0f00 	teq	r5, #0
 800070e:	bf18      	it	ne
 8000710:	4770      	bxne	lr
 8000712:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 8000716:	0052      	lsls	r2, r2, #1
 8000718:	eb43 0303 	adc.w	r3, r3, r3
 800071c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8000720:	bf08      	it	eq
 8000722:	3d01      	subeq	r5, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1c6>
 8000726:	ea43 0306 	orr.w	r3, r3, r6
 800072a:	4770      	bx	lr
 800072c:	ea94 0f0c 	teq	r4, ip
 8000730:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000734:	bf18      	it	ne
 8000736:	ea95 0f0c 	teqne	r5, ip
 800073a:	d00c      	beq.n	8000756 <__aeabi_dmul+0x206>
 800073c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000740:	bf18      	it	ne
 8000742:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000746:	d1d1      	bne.n	80006ec <__aeabi_dmul+0x19c>
 8000748:	ea81 0103 	eor.w	r1, r1, r3
 800074c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000750:	f04f 0000 	mov.w	r0, #0
 8000754:	bd70      	pop	{r4, r5, r6, pc}
 8000756:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800075a:	bf06      	itte	eq
 800075c:	4610      	moveq	r0, r2
 800075e:	4619      	moveq	r1, r3
 8000760:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000764:	d019      	beq.n	800079a <__aeabi_dmul+0x24a>
 8000766:	ea94 0f0c 	teq	r4, ip
 800076a:	d102      	bne.n	8000772 <__aeabi_dmul+0x222>
 800076c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000770:	d113      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000772:	ea95 0f0c 	teq	r5, ip
 8000776:	d105      	bne.n	8000784 <__aeabi_dmul+0x234>
 8000778:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800077c:	bf1c      	itt	ne
 800077e:	4610      	movne	r0, r2
 8000780:	4619      	movne	r1, r3
 8000782:	d10a      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000784:	ea81 0103 	eor.w	r1, r1, r3
 8000788:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800078c:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000790:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000794:	f04f 0000 	mov.w	r0, #0
 8000798:	bd70      	pop	{r4, r5, r6, pc}
 800079a:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 800079e:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 80007a2:	bd70      	pop	{r4, r5, r6, pc}

080007a4 <__aeabi_ddiv>:
 80007a4:	b570      	push	{r4, r5, r6, lr}
 80007a6:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80007aa:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80007ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007b2:	bf1d      	ittte	ne
 80007b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007b8:	ea94 0f0c 	teqne	r4, ip
 80007bc:	ea95 0f0c 	teqne	r5, ip
 80007c0:	f000 f8a7 	bleq	8000912 <__aeabi_ddiv+0x16e>
 80007c4:	eba4 0405 	sub.w	r4, r4, r5
 80007c8:	ea81 0e03 	eor.w	lr, r1, r3
 80007cc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007d4:	f000 8088 	beq.w	80008e8 <__aeabi_ddiv+0x144>
 80007d8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007dc:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 80007e0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80007e4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80007e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80007ec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80007f0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80007f4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80007f8:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80007fc:	429d      	cmp	r5, r3
 80007fe:	bf08      	it	eq
 8000800:	4296      	cmpeq	r6, r2
 8000802:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 8000806:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 800080a:	d202      	bcs.n	8000812 <__aeabi_ddiv+0x6e>
 800080c:	085b      	lsrs	r3, r3, #1
 800080e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000812:	1ab6      	subs	r6, r6, r2
 8000814:	eb65 0503 	sbc.w	r5, r5, r3
 8000818:	085b      	lsrs	r3, r3, #1
 800081a:	ea4f 0232 	mov.w	r2, r2, rrx
 800081e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8000822:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 8000826:	ebb6 0e02 	subs.w	lr, r6, r2
 800082a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800082e:	bf22      	ittt	cs
 8000830:	1ab6      	subcs	r6, r6, r2
 8000832:	4675      	movcs	r5, lr
 8000834:	ea40 000c 	orrcs.w	r0, r0, ip
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000842:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000846:	bf22      	ittt	cs
 8000848:	1ab6      	subcs	r6, r6, r2
 800084a:	4675      	movcs	r5, lr
 800084c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000850:	085b      	lsrs	r3, r3, #1
 8000852:	ea4f 0232 	mov.w	r2, r2, rrx
 8000856:	ebb6 0e02 	subs.w	lr, r6, r2
 800085a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800085e:	bf22      	ittt	cs
 8000860:	1ab6      	subcs	r6, r6, r2
 8000862:	4675      	movcs	r5, lr
 8000864:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000868:	085b      	lsrs	r3, r3, #1
 800086a:	ea4f 0232 	mov.w	r2, r2, rrx
 800086e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000872:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000876:	bf22      	ittt	cs
 8000878:	1ab6      	subcs	r6, r6, r2
 800087a:	4675      	movcs	r5, lr
 800087c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000880:	ea55 0e06 	orrs.w	lr, r5, r6
 8000884:	d018      	beq.n	80008b8 <__aeabi_ddiv+0x114>
 8000886:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800088a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800088e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000892:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000896:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800089a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800089e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008a2:	d1c0      	bne.n	8000826 <__aeabi_ddiv+0x82>
 80008a4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008a8:	d10b      	bne.n	80008c2 <__aeabi_ddiv+0x11e>
 80008aa:	ea41 0100 	orr.w	r1, r1, r0
 80008ae:	f04f 0000 	mov.w	r0, #0
 80008b2:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 80008b6:	e7b6      	b.n	8000826 <__aeabi_ddiv+0x82>
 80008b8:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80008bc:	bf04      	itt	eq
 80008be:	4301      	orreq	r1, r0
 80008c0:	2000      	moveq	r0, #0
 80008c2:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80008c6:	bf88      	it	hi
 80008c8:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80008cc:	f63f aeaf 	bhi.w	800062e <__aeabi_dmul+0xde>
 80008d0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008d4:	bf04      	itt	eq
 80008d6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008de:	f150 0000 	adcs.w	r0, r0, #0
 80008e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80008e6:	bd70      	pop	{r4, r5, r6, pc}
 80008e8:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 80008ec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80008f0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80008f4:	bfc2      	ittt	gt
 80008f6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80008fa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80008fe:	bd70      	popgt	{r4, r5, r6, pc}
 8000900:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000904:	f04f 0e00 	mov.w	lr, #0
 8000908:	3c01      	subs	r4, #1
 800090a:	e690      	b.n	800062e <__aeabi_dmul+0xde>
 800090c:	ea45 0e06 	orr.w	lr, r5, r6
 8000910:	e68d      	b.n	800062e <__aeabi_dmul+0xde>
 8000912:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000916:	ea94 0f0c 	teq	r4, ip
 800091a:	bf08      	it	eq
 800091c:	ea95 0f0c 	teqeq	r5, ip
 8000920:	f43f af3b 	beq.w	800079a <__aeabi_dmul+0x24a>
 8000924:	ea94 0f0c 	teq	r4, ip
 8000928:	d10a      	bne.n	8000940 <__aeabi_ddiv+0x19c>
 800092a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800092e:	f47f af34 	bne.w	800079a <__aeabi_dmul+0x24a>
 8000932:	ea95 0f0c 	teq	r5, ip
 8000936:	f47f af25 	bne.w	8000784 <__aeabi_dmul+0x234>
 800093a:	4610      	mov	r0, r2
 800093c:	4619      	mov	r1, r3
 800093e:	e72c      	b.n	800079a <__aeabi_dmul+0x24a>
 8000940:	ea95 0f0c 	teq	r5, ip
 8000944:	d106      	bne.n	8000954 <__aeabi_ddiv+0x1b0>
 8000946:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800094a:	f43f aefd 	beq.w	8000748 <__aeabi_dmul+0x1f8>
 800094e:	4610      	mov	r0, r2
 8000950:	4619      	mov	r1, r3
 8000952:	e722      	b.n	800079a <__aeabi_dmul+0x24a>
 8000954:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000958:	bf18      	it	ne
 800095a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800095e:	f47f aec5 	bne.w	80006ec <__aeabi_dmul+0x19c>
 8000962:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000966:	f47f af0d 	bne.w	8000784 <__aeabi_dmul+0x234>
 800096a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800096e:	f47f aeeb 	bne.w	8000748 <__aeabi_dmul+0x1f8>
 8000972:	e712      	b.n	800079a <__aeabi_dmul+0x24a>

08000974 <__gedf2>:
 8000974:	f04f 3cff 	mov.w	ip, #4294967295
 8000978:	e006      	b.n	8000988 <__cmpdf2+0x4>
 800097a:	bf00      	nop

0800097c <__ledf2>:
 800097c:	f04f 0c01 	mov.w	ip, #1
 8000980:	e002      	b.n	8000988 <__cmpdf2+0x4>
 8000982:	bf00      	nop

08000984 <__cmpdf2>:
 8000984:	f04f 0c01 	mov.w	ip, #1
 8000988:	f84d cd04 	str.w	ip, [sp, #-4]!
 800098c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000990:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000994:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000998:	bf18      	it	ne
 800099a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800099e:	d01b      	beq.n	80009d8 <__cmpdf2+0x54>
 80009a0:	b001      	add	sp, #4
 80009a2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80009a6:	bf0c      	ite	eq
 80009a8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80009ac:	ea91 0f03 	teqne	r1, r3
 80009b0:	bf02      	ittt	eq
 80009b2:	ea90 0f02 	teqeq	r0, r2
 80009b6:	2000      	moveq	r0, #0
 80009b8:	4770      	bxeq	lr
 80009ba:	f110 0f00 	cmn.w	r0, #0
 80009be:	ea91 0f03 	teq	r1, r3
 80009c2:	bf58      	it	pl
 80009c4:	4299      	cmppl	r1, r3
 80009c6:	bf08      	it	eq
 80009c8:	4290      	cmpeq	r0, r2
 80009ca:	bf2c      	ite	cs
 80009cc:	17d8      	asrcs	r0, r3, #31
 80009ce:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80009d2:	f040 0001 	orr.w	r0, r0, #1
 80009d6:	4770      	bx	lr
 80009d8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80009dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009e0:	d102      	bne.n	80009e8 <__cmpdf2+0x64>
 80009e2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80009e6:	d107      	bne.n	80009f8 <__cmpdf2+0x74>
 80009e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80009ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009f0:	d1d6      	bne.n	80009a0 <__cmpdf2+0x1c>
 80009f2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80009f6:	d0d3      	beq.n	80009a0 <__cmpdf2+0x1c>
 80009f8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <__aeabi_cdrcmple>:
 8000a00:	4684      	mov	ip, r0
 8000a02:	4610      	mov	r0, r2
 8000a04:	4662      	mov	r2, ip
 8000a06:	468c      	mov	ip, r1
 8000a08:	4619      	mov	r1, r3
 8000a0a:	4663      	mov	r3, ip
 8000a0c:	e000      	b.n	8000a10 <__aeabi_cdcmpeq>
 8000a0e:	bf00      	nop

08000a10 <__aeabi_cdcmpeq>:
 8000a10:	b501      	push	{r0, lr}
 8000a12:	f7ff ffb7 	bl	8000984 <__cmpdf2>
 8000a16:	2800      	cmp	r0, #0
 8000a18:	bf48      	it	mi
 8000a1a:	f110 0f00 	cmnmi.w	r0, #0
 8000a1e:	bd01      	pop	{r0, pc}

08000a20 <__aeabi_dcmpeq>:
 8000a20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a24:	f7ff fff4 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a28:	bf0c      	ite	eq
 8000a2a:	2001      	moveq	r0, #1
 8000a2c:	2000      	movne	r0, #0
 8000a2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a32:	bf00      	nop

08000a34 <__aeabi_dcmplt>:
 8000a34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a38:	f7ff ffea 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a3c:	bf34      	ite	cc
 8000a3e:	2001      	movcc	r0, #1
 8000a40:	2000      	movcs	r0, #0
 8000a42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a46:	bf00      	nop

08000a48 <__aeabi_dcmple>:
 8000a48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a4c:	f7ff ffe0 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a50:	bf94      	ite	ls
 8000a52:	2001      	movls	r0, #1
 8000a54:	2000      	movhi	r0, #0
 8000a56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a5a:	bf00      	nop

08000a5c <__aeabi_dcmpge>:
 8000a5c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a60:	f7ff ffce 	bl	8000a00 <__aeabi_cdrcmple>
 8000a64:	bf94      	ite	ls
 8000a66:	2001      	movls	r0, #1
 8000a68:	2000      	movhi	r0, #0
 8000a6a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dcmpgt>:
 8000a70:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a74:	f7ff ffc4 	bl	8000a00 <__aeabi_cdrcmple>
 8000a78:	bf34      	ite	cc
 8000a7a:	2001      	movcc	r0, #1
 8000a7c:	2000      	movcs	r0, #0
 8000a7e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a82:	bf00      	nop

08000a84 <__aeabi_d2f>:
 8000a84:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a88:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000a8c:	bf24      	itt	cs
 8000a8e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000a92:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000a96:	d90d      	bls.n	8000ab4 <__aeabi_d2f+0x30>
 8000a98:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000a9c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000aa0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000aa4:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000aa8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000aac:	bf08      	it	eq
 8000aae:	f020 0001 	biceq.w	r0, r0, #1
 8000ab2:	4770      	bx	lr
 8000ab4:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000ab8:	d121      	bne.n	8000afe <__aeabi_d2f+0x7a>
 8000aba:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000abe:	bfbc      	itt	lt
 8000ac0:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000ac4:	4770      	bxlt	lr
 8000ac6:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000aca:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000ace:	f1c2 0218 	rsb	r2, r2, #24
 8000ad2:	f1c2 0c20 	rsb	ip, r2, #32
 8000ad6:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ada:	fa20 f002 	lsr.w	r0, r0, r2
 8000ade:	bf18      	it	ne
 8000ae0:	f040 0001 	orrne.w	r0, r0, #1
 8000ae4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ae8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000aec:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000af0:	ea40 000c 	orr.w	r0, r0, ip
 8000af4:	fa23 f302 	lsr.w	r3, r3, r2
 8000af8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000afc:	e7cc      	b.n	8000a98 <__aeabi_d2f+0x14>
 8000afe:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b02:	d107      	bne.n	8000b14 <__aeabi_d2f+0x90>
 8000b04:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b08:	bf1e      	ittt	ne
 8000b0a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000b0e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000b12:	4770      	bxne	lr
 8000b14:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000b18:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000b1c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000b20:	4770      	bx	lr
 8000b22:	bf00      	nop

08000b24 <sysclock_init>:
}

void sysclock_init(void)
{
	// 16 MHz HSI oscillator is default on reset, but select anyways
	RCC->CR |= RCC_CR_HSION;
 8000b24:	4a1b      	ldr	r2, [pc, #108]	@ (8000b94 <sysclock_init+0x70>)
 8000b26:	6813      	ldr	r3, [r2, #0]
 8000b28:	f043 0301 	orr.w	r3, r3, #1
{
 8000b2c:	b410      	push	{r4}
	RCC->CR |= RCC_CR_HSION;
 8000b2e:	6013      	str	r3, [r2, #0]
	// wait for HSI to be ready
	while (!((RCC->CR) & RCC_CR_HSIRDY));
 8000b30:	6813      	ldr	r3, [r2, #0]
 8000b32:	0799      	lsls	r1, r3, #30
 8000b34:	d5fc      	bpl.n	8000b30 <sysclock_init+0xc>

	// enable power interface clock for APB1
	RCC->APB1ENR = RCC_APB1ENR_PWREN;

	// configure VCO to scale 2 per CubeMX
	PWR->CR |= PWR_CR_VOS_1;
 8000b36:	4b18      	ldr	r3, [pc, #96]	@ (8000b98 <sysclock_init+0x74>)
	// configure FLASH
	// instruction cache, prefetch enable, and data cache enabled
	uint32_t flash;
	flash = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN;
	flash |= 2;		// 2 wait states for flash
	FLASH->ACR = flash;
 8000b38:	4818      	ldr	r0, [pc, #96]	@ (8000b9c <sysclock_init+0x78>)
	RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000b3a:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
 8000b3e:	6411      	str	r1, [r2, #64]	@ 0x40
	PWR->CR |= PWR_CR_VOS_1;
 8000b40:	6819      	ldr	r1, [r3, #0]
 8000b42:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
 8000b46:	6019      	str	r1, [r3, #0]
	PWR->CR &= ~PWR_CR_VOS_0;
 8000b48:	6819      	ldr	r1, [r3, #0]
 8000b4a:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
 8000b4e:	6019      	str	r1, [r3, #0]
	FLASH->ACR = flash;
 8000b50:	f240 7402 	movw	r4, #1794	@ 0x702
	// configure bus prescalers
	uint32_t cfgr = 0;
	cfgr &= ~RCC_CFGR_PPRE2_2;		// APB2 prescaler of 1 (84MHz)
	cfgr |= RCC_CFGR_PPRE1_2;		// APB1 prescaler of 2 (42MHZ)
	cfgr &= ~RCC_CFGR_HPRE;			// AHB prescaler of 1 (84MHz)
	RCC->CFGR = cfgr;
 8000b54:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
	FLASH->ACR = flash;
 8000b58:	6004      	str	r4, [r0, #0]
	RCC->CFGR = cfgr;
 8000b5a:	6093      	str	r3, [r2, #8]

	// configure main PLL
	uint32_t pll_cfg = RCC->PLLCFGR;
 8000b5c:	6851      	ldr	r1, [r2, #4]
	pll_cfg &= ~RCC_PLLCFGR_PLLP;	// main PLL division factor of 2

	pll_cfg &= ~RCC_PLLCFGR_PLLN;
	pll_cfg |= 168UL << 6;	// pll multiplication factor for VCO (x168)

	pll_cfg &= ~RCC_PLLCFGR_PLLM;
 8000b5e:	4810      	ldr	r0, [pc, #64]	@ (8000ba0 <sysclock_init+0x7c>)
	pll_cfg |= 16UL << 0;	// pll division factor for main PLL and audio PLL (/16)
 8000b60:	4b10      	ldr	r3, [pc, #64]	@ (8000ba4 <sysclock_init+0x80>)
 8000b62:	4001      	ands	r1, r0
 8000b64:	430b      	orrs	r3, r1

	RCC->PLLCFGR = pll_cfg;
 8000b66:	6053      	str	r3, [r2, #4]

	// enable PLL and wait for ready
	RCC->CR |= RCC_CR_PLLON;
 8000b68:	6813      	ldr	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b6a:	490a      	ldr	r1, [pc, #40]	@ (8000b94 <sysclock_init+0x70>)
	RCC->CR |= RCC_CR_PLLON;
 8000b6c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8000b70:	6013      	str	r3, [r2, #0]
	while (!((RCC->CR) & RCC_CR_PLLRDY));
 8000b72:	680b      	ldr	r3, [r1, #0]
 8000b74:	019a      	lsls	r2, r3, #6
 8000b76:	d5fc      	bpl.n	8000b72 <sysclock_init+0x4e>

	// select clock source
	cfgr = RCC->CFGR;
 8000b78:	688b      	ldr	r3, [r1, #8]
	cfgr |= RCC_CFGR_SW_1;		// select PLL as system clock
	cfgr &= ~RCC_CFGR_SW_0;
	RCC->CFGR = cfgr;

	// wait for PLL clock source to become active
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b7a:	4a06      	ldr	r2, [pc, #24]	@ (8000b94 <sysclock_init+0x70>)
 8000b7c:	f023 0301 	bic.w	r3, r3, #1
	cfgr &= ~RCC_CFGR_SW_0;
 8000b80:	f043 0302 	orr.w	r3, r3, #2
	RCC->CFGR = cfgr;
 8000b84:	608b      	str	r3, [r1, #8]
	while (!((RCC->CFGR) & RCC_CFGR_SWS_1));
 8000b86:	6893      	ldr	r3, [r2, #8]
 8000b88:	071b      	lsls	r3, r3, #28
 8000b8a:	d5fc      	bpl.n	8000b86 <sysclock_init+0x62>
}
 8000b8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop
 8000b94:	40023800 	.word	0x40023800
 8000b98:	40007000 	.word	0x40007000
 8000b9c:	40023c00 	.word	0x40023c00
 8000ba0:	f0fc8000 	.word	0xf0fc8000
 8000ba4:	04002a10 	.word	0x04002a10

08000ba8 <spi1_dma2_init>:

void spi1_dma2_init(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000ba8:	495b      	ldr	r1, [pc, #364]	@ (8000d18 <spi1_dma2_init+0x170>)
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock

	// PA4 is SPI1_NSS (select alternate function)
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000baa:	4b5c      	ldr	r3, [pc, #368]	@ (8000d1c <spi1_dma2_init+0x174>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bac:	6c48      	ldr	r0, [r1, #68]	@ 0x44

	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);

	// initialize SPI slave
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000bae:	4a5c      	ldr	r2, [pc, #368]	@ (8000d20 <spi1_dma2_init+0x178>)
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb0:	f440 5080 	orr.w	r0, r0, #4096	@ 0x1000
{
 8000bb4:	b410      	push	{r4}
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;				// enable SPI1 clock
 8000bb6:	6448      	str	r0, [r1, #68]	@ 0x44
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			// enable GPIOA clock
 8000bb8:	6b08      	ldr	r0, [r1, #48]	@ 0x30
 8000bba:	f040 0001 	orr.w	r0, r0, #1
 8000bbe:	6308      	str	r0, [r1, #48]	@ 0x30
	GPIOA->MODER |= GPIO_MODER_MODER4_1;
 8000bc0:	6818      	ldr	r0, [r3, #0]
 8000bc2:	f440 7000 	orr.w	r0, r0, #512	@ 0x200
 8000bc6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER4_0;
 8000bc8:	6818      	ldr	r0, [r3, #0]
 8000bca:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
 8000bce:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER5_1;
 8000bd0:	6818      	ldr	r0, [r3, #0]
 8000bd2:	f440 6000 	orr.w	r0, r0, #2048	@ 0x800
 8000bd6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER5_0;
 8000bd8:	6818      	ldr	r0, [r3, #0]
 8000bda:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
 8000bde:	6018      	str	r0, [r3, #0]
	GPIOA->MODER |= GPIO_MODER_MODER7_1;
 8000be0:	6818      	ldr	r0, [r3, #0]
 8000be2:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
 8000be6:	6018      	str	r0, [r3, #0]
	GPIOA->MODER &= ~GPIO_MODER_MODER7_0;
 8000be8:	6818      	ldr	r0, [r3, #0]
 8000bea:	f420 4080 	bic.w	r0, r0, #16384	@ 0x4000
 8000bee:	6018      	str	r0, [r3, #0]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL4_0 | GPIO_AFRL_AFRL4_2;
 8000bf0:	6a18      	ldr	r0, [r3, #32]
 8000bf2:	f440 20a0 	orr.w	r0, r0, #327680	@ 0x50000
 8000bf6:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_3);
 8000bf8:	6a18      	ldr	r0, [r3, #32]
 8000bfa:	f420 2020 	bic.w	r0, r0, #655360	@ 0xa0000
 8000bfe:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL5_0 | GPIO_AFRL_AFRL5_2;
 8000c00:	6a18      	ldr	r0, [r3, #32]
 8000c02:	f440 00a0 	orr.w	r0, r0, #5242880	@ 0x500000
 8000c06:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL5_1 | GPIO_AFRL_AFRL5_3);
 8000c08:	6a18      	ldr	r0, [r3, #32]
 8000c0a:	f420 0020 	bic.w	r0, r0, #10485760	@ 0xa00000
 8000c0e:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL7_0 | GPIO_AFRL_AFRL7_2;
 8000c10:	6a18      	ldr	r0, [r3, #32]
 8000c12:	f040 40a0 	orr.w	r0, r0, #1342177280	@ 0x50000000
 8000c16:	6218      	str	r0, [r3, #32]
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL7_1 | GPIO_AFRL_AFRL7_3);
 8000c18:	6a18      	ldr	r0, [r3, #32]
 8000c1a:	f020 4020 	bic.w	r0, r0, #2684354560	@ 0xa0000000
 8000c1e:	6218      	str	r0, [r3, #32]
	SPI1->CR1 |= SPI_CR1_DFF | SPI_CR1_RXONLY;			// 16-bit data frame, not using MISO
 8000c20:	6810      	ldr	r0, [r2, #0]
 8000c22:	f440 6040 	orr.w	r0, r0, #3072	@ 0xc00
 8000c26:	6010      	str	r0, [r2, #0]
	SPI1->CR1 &= ~(SPI_CR1_LSBFIRST | SPI_CR1_SSM | 	// MSb first, disable software slave management
 8000c28:	6810      	ldr	r0, [r2, #0]
 8000c2a:	f420 4002 	bic.w	r0, r0, #33280	@ 0x8200
 8000c2e:	f020 00c7 	bic.w	r0, r0, #199	@ 0xc7
 8000c32:	6010      	str	r0, [r2, #0]
					SPI_CR1_SPE | SPI_CR1_MSTR | 		// disable SPI, slave mode
					SPI_CR1_BIDIMODE |					// not using bidirectional mode
					SPI_CR1_CPOL | SPI_CR1_CPHA);		// SPI mode = [0, 0]

	SPI1->CR2 &= ~(SPI_CR2_SSOE | SPI_CR2_FRF);			// disable slave select output and select Motorola mode
 8000c34:	6850      	ldr	r0, [r2, #4]
 8000c36:	f020 0014 	bic.w	r0, r0, #20
 8000c3a:	6050      	str	r0, [r2, #4]
	SPI1->CR2 |= SPI_CR2_RXDMAEN;						// enable DMA requests when data is received
 8000c3c:	6850      	ldr	r0, [r2, #4]
 8000c3e:	f040 0001 	orr.w	r0, r0, #1
 8000c42:	6050      	str	r0, [r2, #4]


	/* DMA2 Channel 3, Stream 0 --> SPI1 RX */
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c44:	6b0a      	ldr	r2, [r1, #48]	@ 0x30

	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c46:	f503 43c8 	add.w	r3, r3, #25600	@ 0x6400
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;		// enable DMA2 clock
 8000c4a:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 8000c4e:	630a      	str	r2, [r1, #48]	@ 0x30
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;		// disable stream
 8000c50:	691a      	ldr	r2, [r3, #16]
 8000c52:	f022 0201 	bic.w	r2, r2, #1
 8000c56:	611a      	str	r2, [r3, #16]
	while (DMA2_Stream0->CR & DMA_SxCR_EN);	// wait for stream to disable
 8000c58:	691a      	ldr	r2, [r3, #16]
 8000c5a:	07d2      	lsls	r2, r2, #31
 8000c5c:	d4fc      	bmi.n	8000c58 <spi1_dma2_init+0xb0>

	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c5e:	4c31      	ldr	r4, [pc, #196]	@ (8000d24 <spi1_dma2_init+0x17c>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c60:	4931      	ldr	r1, [pc, #196]	@ (8000d28 <spi1_dma2_init+0x180>)
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c62:	4832      	ldr	r0, [pc, #200]	@ (8000d2c <spi1_dma2_init+0x184>)
	DMA2_Stream0->PAR = (uint32_t)&(SPI1->DR);// peripheral address
 8000c64:	619c      	str	r4, [r3, #24]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c66:	f44f 62b4 	mov.w	r2, #1440	@ 0x5a0
	DMA2_Stream0->M0AR = (uint32_t)stream0;	// destination memory address (CT = 0)
 8000c6a:	61d8      	str	r0, [r3, #28]
	DMA2_Stream0->M1AR = (uint32_t)stream1;	// destination memory address (CT = 1)
 8000c6c:	6219      	str	r1, [r3, #32]
	DMA2_Stream0->NDTR = N_BLOCK;			// number of units to be transmitted
 8000c6e:	615a      	str	r2, [r3, #20]

	// select channel 3 for SPI1 RX
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c70:	691a      	ldr	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;


	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream

	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000c72:	492b      	ldr	r1, [pc, #172]	@ (8000d20 <spi1_dma2_init+0x178>)
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
 8000c74:	f022 6260 	bic.w	r2, r2, #234881024	@ 0xe000000
 8000c78:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CHSEL_0 | DMA_SxCR_CHSEL_1;
 8000c7a:	691a      	ldr	r2, [r3, #16]
 8000c7c:	f042 62c0 	orr.w	r2, r2, #100663296	@ 0x6000000
 8000c80:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PFCTRL;	// DMA is the flow controller
 8000c82:	691a      	ldr	r2, [r3, #16]
 8000c84:	f022 0220 	bic.w	r2, r2, #32
 8000c88:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PL_0;
 8000c8a:	691a      	ldr	r2, [r3, #16]
 8000c8c:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8000c90:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PL_1;
 8000c92:	691a      	ldr	r2, [r3, #16]
 8000c94:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8000c98:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->FCR |= DMA_SxFCR_DMDIS;
 8000c9a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000c9c:	f042 0204 	orr.w	r2, r2, #4
 8000ca0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR |= DMA_SxFCR_FTH_0;
 8000ca2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000ca4:	f042 0201 	orr.w	r2, r2, #1
 8000ca8:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->FCR &= ~DMA_SxFCR_FTH_1;
 8000caa:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8000cac:	f022 0202 	bic.w	r2, r2, #2
 8000cb0:	625a      	str	r2, [r3, #36]	@ 0x24
	DMA2_Stream0->CR |= DMA_SxCR_MSIZE_0;
 8000cb2:	691a      	ldr	r2, [r3, #16]
 8000cb4:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8000cb8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_MSIZE_1;
 8000cba:	691a      	ldr	r2, [r3, #16]
 8000cbc:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 8000cc0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_PSIZE_0;
 8000cc2:	691a      	ldr	r2, [r3, #16]
 8000cc4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8000cc8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PSIZE_1;
 8000cca:	691a      	ldr	r2, [r3, #16]
 8000ccc:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 8000cd0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_MINC;
 8000cd2:	691a      	ldr	r2, [r3, #16]
 8000cd4:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8000cd8:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_PINC;
 8000cda:	691a      	ldr	r2, [r3, #16]
 8000cdc:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8000ce0:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce2:	691a      	ldr	r2, [r3, #16]
}
 8000ce4:	f85d 4b04 	ldr.w	r4, [sp], #4
	DMA2_Stream0->CR &= ~DMA_SxCR_DIR;
 8000ce8:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8000cec:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_CIRC;
 8000cee:	691a      	ldr	r2, [r3, #16]
 8000cf0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8000cf4:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_DBM;
 8000cf6:	691a      	ldr	r2, [r3, #16]
 8000cf8:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8000cfc:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR &= ~DMA_SxCR_CT;
 8000cfe:	691a      	ldr	r2, [r3, #16]
 8000d00:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 8000d04:	611a      	str	r2, [r3, #16]
	DMA2_Stream0->CR |= DMA_SxCR_EN;		// enable DMA stream
 8000d06:	691a      	ldr	r2, [r3, #16]
 8000d08:	f042 0201 	orr.w	r2, r2, #1
 8000d0c:	611a      	str	r2, [r3, #16]
	SPI1->CR1 |= SPI_CR1_SPE;				// enable SPI1
 8000d0e:	680b      	ldr	r3, [r1, #0]
 8000d10:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8000d14:	600b      	str	r3, [r1, #0]
}
 8000d16:	4770      	bx	lr
 8000d18:	40023800 	.word	0x40023800
 8000d1c:	40020000 	.word	0x40020000
 8000d20:	40013000 	.word	0x40013000
 8000d24:	4001300c 	.word	0x4001300c
 8000d28:	20000024 	.word	0x20000024
 8000d2c:	20000b64 	.word	0x20000b64

08000d30 <stream_splice>:

void stream_splice(struct MicProc * mics)
{
 8000d30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		// mic0 = [CH0_S0, CH0_S1, CH0_S2, ...]
		// mic1 = [CH1_S0, CH1_S1, CH1_S2, ...]
		// mic2 = [CH2_S0, CH2_S1, CH2_S2, ...]

		// DMA is targeting M1AR ---> read from M0AR memory
		if (dma_tgt)
 8000d34:	4b5c      	ldr	r3, [pc, #368]	@ (8000ea8 <stream_splice+0x178>)
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
		}
		else
		{
			for (uint32_t j = 0; j < N_MICS; j++)
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d36:	f8df 9190 	ldr.w	r9, [pc, #400]	@ 8000ec8 <stream_splice+0x198>
 8000d3a:	781d      	ldrb	r5, [r3, #0]
{
 8000d3c:	4607      	mov	r7, r0
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d3e:	f04f 0800 	mov.w	r8, #0
 8000d42:	2d00      	cmp	r5, #0
 8000d44:	d157      	bne.n	8000df6 <stream_splice+0xc6>
 8000d46:	f04f 0a00 	mov.w	sl, #0
 8000d4a:	f04f 5b7d 	mov.w	fp, #1061158912	@ 0x3f400000
 8000d4e:	4b57      	ldr	r3, [pc, #348]	@ (8000eac <stream_splice+0x17c>)
 8000d50:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
		uint32_t ind = i / 3;
 8000d54:	4b56      	ldr	r3, [pc, #344]	@ (8000eb0 <stream_splice+0x180>)
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d56:	ee07 0a90 	vmov	s15, r0
 8000d5a:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8000d5e:	fba3 3405 	umull	r3, r4, r3, r5
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d62:	ee17 0a90 	vmov	r0, s15
 8000d66:	f7ff fb9b 	bl	80004a0 <__aeabi_f2d>
 8000d6a:	4642      	mov	r2, r8
 8000d6c:	464b      	mov	r3, r9
 8000d6e:	f7ff fa37 	bl	80001e0 <__aeabi_dsub>
 8000d72:	4652      	mov	r2, sl
 8000d74:	465b      	mov	r3, fp
 8000d76:	f7ff fbeb 	bl	8000550 <__aeabi_dmul>
		uint32_t ind = i / 3;
 8000d7a:	0864      	lsrs	r4, r4, #1
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000d7c:	f7ff fe82 	bl	8000a84 <__aeabi_d2f>
 8000d80:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8000d84:	4b4b      	ldr	r3, [pc, #300]	@ (8000eb4 <stream_splice+0x184>)
 8000d86:	f504 5680 	add.w	r6, r4, #4096	@ 0x1000
 8000d8a:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000d8c:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000d90:	ee07 0a90 	vmov	s15, r0
 8000d94:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000d98:	f504 469c 	add.w	r6, r4, #19968	@ 0x4e00
 8000d9c:	ee17 0a90 	vmov	r0, s15
 8000da0:	f7ff fb7e 	bl	80004a0 <__aeabi_f2d>
 8000da4:	4642      	mov	r2, r8
 8000da6:	464b      	mov	r3, r9
 8000da8:	f7ff fa1a 	bl	80001e0 <__aeabi_dsub>
 8000dac:	4652      	mov	r2, sl
 8000dae:	465b      	mov	r3, fp
 8000db0:	f7ff fbce 	bl	8000550 <__aeabi_dmul>
 8000db4:	f7ff fe66 	bl	8000a84 <__aeabi_d2f>
 8000db8:	4b3f      	ldr	r3, [pc, #252]	@ (8000eb8 <stream_splice+0x188>)
 8000dba:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000dbc:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000dc0:	ee07 0a90 	vmov	s15, r0
 8000dc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000dc8:	f504 440c 	add.w	r4, r4, #35840	@ 0x8c00
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000dcc:	ee17 0a90 	vmov	r0, s15
 8000dd0:	f7ff fb66 	bl	80004a0 <__aeabi_f2d>
 8000dd4:	4642      	mov	r2, r8
 8000dd6:	464b      	mov	r3, r9
 8000dd8:	f7ff fa02 	bl	80001e0 <__aeabi_dsub>
 8000ddc:	4652      	mov	r2, sl
 8000dde:	465b      	mov	r3, fp
 8000de0:	f7ff fbb6 	bl	8000550 <__aeabi_dmul>
 8000de4:	f7ff fe4e 	bl	8000a84 <__aeabi_d2f>
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000de8:	3503      	adds	r5, #3
 8000dea:	f5b5 6fb4 	cmp.w	r5, #1440	@ 0x5a0
				mics[j].raw[ind] = ((float32_t) stream1[i + j] - 2048.0) * (1.0f / 2048.0f);
 8000dee:	67a0      	str	r0, [r4, #120]	@ 0x78
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000df0:	d1ad      	bne.n	8000d4e <stream_splice+0x1e>
		}
	}
}
 8000df2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000df6:	2500      	movs	r5, #0
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000df8:	f04f 0a00 	mov.w	sl, #0
 8000dfc:	f04f 5b7d 	mov.w	fp, #1061158912	@ 0x3f400000
 8000e00:	4b2e      	ldr	r3, [pc, #184]	@ (8000ebc <stream_splice+0x18c>)
 8000e02:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
		uint32_t ind = i / 3;
 8000e06:	4b2a      	ldr	r3, [pc, #168]	@ (8000eb0 <stream_splice+0x180>)
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e08:	ee07 0a90 	vmov	s15, r0
 8000e0c:	eef8 7a67 	vcvt.f32.u32	s15, s15
		uint32_t ind = i / 3;
 8000e10:	fba3 3405 	umull	r3, r4, r3, r5
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e14:	ee17 0a90 	vmov	r0, s15
 8000e18:	f7ff fb42 	bl	80004a0 <__aeabi_f2d>
 8000e1c:	4642      	mov	r2, r8
 8000e1e:	464b      	mov	r3, r9
 8000e20:	f7ff f9de 	bl	80001e0 <__aeabi_dsub>
 8000e24:	4652      	mov	r2, sl
 8000e26:	465b      	mov	r3, fp
 8000e28:	f7ff fb92 	bl	8000550 <__aeabi_dmul>
		uint32_t ind = i / 3;
 8000e2c:	0864      	lsrs	r4, r4, #1
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000e2e:	f7ff fe29 	bl	8000a84 <__aeabi_d2f>
 8000e32:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8000e36:	4b22      	ldr	r3, [pc, #136]	@ (8000ec0 <stream_splice+0x190>)
 8000e38:	f504 5680 	add.w	r6, r4, #4096	@ 0x1000
 8000e3c:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000e3e:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000e42:	ee07 0a90 	vmov	s15, r0
 8000e46:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000e4a:	f504 469c 	add.w	r6, r4, #19968	@ 0x4e00
 8000e4e:	ee17 0a90 	vmov	r0, s15
 8000e52:	f7ff fb25 	bl	80004a0 <__aeabi_f2d>
 8000e56:	4642      	mov	r2, r8
 8000e58:	464b      	mov	r3, r9
 8000e5a:	f7ff f9c1 	bl	80001e0 <__aeabi_dsub>
 8000e5e:	4652      	mov	r2, sl
 8000e60:	465b      	mov	r3, fp
 8000e62:	f7ff fb75 	bl	8000550 <__aeabi_dmul>
 8000e66:	f7ff fe0d 	bl	8000a84 <__aeabi_d2f>
 8000e6a:	4b16      	ldr	r3, [pc, #88]	@ (8000ec4 <stream_splice+0x194>)
 8000e6c:	67b0      	str	r0, [r6, #120]	@ 0x78
 8000e6e:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8000e72:	ee07 0a90 	vmov	s15, r0
 8000e76:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8000e7a:	f504 440c 	add.w	r4, r4, #35840	@ 0x8c00
 8000e7e:	ee17 0a90 	vmov	r0, s15
 8000e82:	f7ff fb0d 	bl	80004a0 <__aeabi_f2d>
 8000e86:	4642      	mov	r2, r8
 8000e88:	464b      	mov	r3, r9
 8000e8a:	f7ff f9a9 	bl	80001e0 <__aeabi_dsub>
 8000e8e:	4652      	mov	r2, sl
 8000e90:	465b      	mov	r3, fp
 8000e92:	f7ff fb5d 	bl	8000550 <__aeabi_dmul>
 8000e96:	f7ff fdf5 	bl	8000a84 <__aeabi_d2f>
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000e9a:	3503      	adds	r5, #3
 8000e9c:	f5b5 6fb4 	cmp.w	r5, #1440	@ 0x5a0
				mics[j].raw[ind] = ((float32_t) stream0[i + j] - 2048.0) * (1.0f / 2048.0f);		// convert raw ADC sample to range [-1, 1]
 8000ea0:	67a0      	str	r0, [r4, #120]	@ 0x78
	for (uint32_t i = 0; i < N_BLOCK; i += 3)
 8000ea2:	d1ad      	bne.n	8000e00 <stream_splice+0xd0>
}
 8000ea4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ea8:	20000020 	.word	0x20000020
 8000eac:	20000024 	.word	0x20000024
 8000eb0:	aaaaaaab 	.word	0xaaaaaaab
 8000eb4:	20000026 	.word	0x20000026
 8000eb8:	20000028 	.word	0x20000028
 8000ebc:	20000b64 	.word	0x20000b64
 8000ec0:	20000b66 	.word	0x20000b66
 8000ec4:	20000b68 	.word	0x20000b68
 8000ec8:	40a00000 	.word	0x40a00000
 8000ecc:	00000000 	.word	0x00000000

08000ed0 <compute_event_pos>:

uint8_t compute_event_pos(float32_t * x, float32_t * y, struct MicCoord * mics_xy, float32_t mic1_delay, float32_t mic2_delay)
{
 8000ed0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	const float32_t max_step = 0.2f;			// maximum dx/dy change per iteration in meters

	// distances from mic1 and mic2 to mic0
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000ed4:	eddf 7a90 	vldr	s15, [pc, #576]	@ 8001118 <compute_event_pos+0x248>
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;

	float32_t lambda = 1e-3f;

	float32_t old_res1 = 0, old_res2 = 0;
 8000ed8:	eddf 4a90 	vldr	s9, [pc, #576]	@ 800111c <compute_event_pos+0x24c>
{
 8000edc:	ed2d 8b0e 	vpush	{d8-d14}
		*y += dy;

		old_res1 = res1;
		old_res2 = res2;

		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000ee0:	a78b      	add	r7, pc, #556	@ (adr r7, 8001110 <compute_event_pos+0x240>)
 8000ee2:	e9d7 6700 	ldrd	r6, r7, [r7]
	const float32_t d10 = SPEED_OF_SOUND * mic1_delay;
 8000ee6:	ee60 8a27 	vmul.f32	s17, s0, s15
	const float32_t d20 = SPEED_OF_SOUND * mic2_delay;
 8000eea:	ee20 8aa7 	vmul.f32	s16, s1, s15
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000eee:	edd1 ba00 	vldr	s23, [r1]
	float32_t lambda = 1e-3f;
 8000ef2:	ed9f da8b 	vldr	s26, [pc, #556]	@ 8001120 <compute_event_pos+0x250>
		if (cost < 1e-8f)	return 1;
 8000ef6:	ed9f 9a8b 	vldr	s18, [pc, #556]	@ 8001124 <compute_event_pos+0x254>
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8000efa:	eddf aa8b 	vldr	s21, [pc, #556]	@ 8001128 <compute_event_pos+0x258>
		if (fabsf(det) < 1e-12f)
 8000efe:	eddf 9a8b 	vldr	s19, [pc, #556]	@ 800112c <compute_event_pos+0x25c>
float32_t clamp(float32_t in, float32_t abs_max)
{
	// clamp in between [-abs_max, abs_max]
	if (in > abs_max)
		return abs_max;
	else if (in < -abs_max)
 8000f02:	ed9f ea8b 	vldr	s28, [pc, #556]	@ 8001130 <compute_event_pos+0x260>
 8000f06:	eddf da8b 	vldr	s27, [pc, #556]	@ 8001134 <compute_event_pos+0x264>
{
 8000f0a:	4689      	mov	r9, r1
	float32_t old_res1 = 0, old_res2 = 0;
 8000f0c:	eeb0 4a64 	vmov.f32	s8, s9
{
 8000f10:	4680      	mov	r8, r0
 8000f12:	4614      	mov	r4, r2
		else						lambda *= 5.0f;			// punish bad step
 8000f14:	eeb1 aa04 	vmov.f32	s20, #20	@ 0x40a00000  5.0
			lambda *= 10.0f;
 8000f18:	eeb2 ba04 	vmov.f32	s22, #36	@ 0x41200000  10.0
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000f1c:	2532      	movs	r5, #50	@ 0x32
 8000f1e:	e057      	b.n	8000fd0 <compute_event_pos+0x100>
		float32_t g2 = j12 * res1 + j22 * res2;
 8000f20:	ee6c 7a27 	vmul.f32	s15, s24, s15
		float32_t g1 = j11 * res1 + j21 * res2;
 8000f24:	ee2c 7a07 	vmul.f32	s14, s24, s14
		float32_t g2 = j12 * res1 + j22 * res2;
 8000f28:	eeec 7aa3 	vfma.f32	s15, s25, s7
		float32_t g1 = j11 * res1 + j21 * res2;
 8000f2c:	eeac 7a85 	vfma.f32	s14, s25, s10
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000f30:	ee23 5a27 	vmul.f32	s10, s6, s15
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000f34:	ee67 7ae5 	vnmul.f32	s15, s15, s11
 8000f38:	eef0 5a45 	vmov.f32	s11, s10
 8000f3c:	eee6 5a47 	vfms.f32	s11, s12, s14
 8000f40:	eee3 7a07 	vfma.f32	s15, s6, s14
		float32_t dx = (-prod22 * g1 + prod12 * g2) / det;
 8000f44:	ee85 6aa2 	vdiv.f32	s12, s11, s5
		float32_t dy = (prod21 * g1 - prod11 * g2) / det;
 8000f48:	ee87 7aa2 	vdiv.f32	s14, s15, s5
	else if (in < -abs_max)
 8000f4c:	eeb4 6ace 	vcmpe.f32	s12, s28
 8000f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f54:	bfb8      	it	lt
 8000f56:	eeb0 6a4e 	vmovlt.f32	s12, s28
 8000f5a:	eeb4 6aed 	vcmpe.f32	s12, s27
 8000f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f62:	eeb4 7ace 	vcmpe.f32	s14, s28
 8000f66:	bf88      	it	hi
 8000f68:	eeb0 6a6d 	vmovhi.f32	s12, s27
 8000f6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f70:	bfb8      	it	lt
 8000f72:	eeb0 7a4e 	vmovlt.f32	s14, s28
 8000f76:	eeb4 7aed 	vcmpe.f32	s14, s27
 8000f7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f7e:	bf88      	it	hi
 8000f80:	eeb0 7a6d 	vmovhi.f32	s14, s27
		*x += dx;
 8000f84:	ee76 7a86 	vadd.f32	s15, s13, s12
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f88:	ee67 6a07 	vmul.f32	s13, s14, s14
		*x += dx;
 8000f8c:	edc8 7a00 	vstr	s15, [r8]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f90:	eef0 7a66 	vmov.f32	s15, s13
 8000f94:	eee6 7a06 	vfma.f32	s15, s12, s12
		*y += dy;
 8000f98:	edd9 5a00 	vldr	s11, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000f9c:	eef1 7ae7 	vsqrt.f32	s15, s15
		*y += dy;
 8000fa0:	ee77 ba25 	vadd.f32	s23, s14, s11
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000fa4:	ee17 0a90 	vmov	r0, s15
		*y += dy;
 8000fa8:	edc9 ba00 	vstr	s23, [r9]
		if (sqrtf(dx * dx + dy * dy) < 1e-5) return 1;
 8000fac:	f7ff fa78 	bl	80004a0 <__aeabi_f2d>
 8000fb0:	4632      	mov	r2, r6
 8000fb2:	463b      	mov	r3, r7
 8000fb4:	f7ff fd3e 	bl	8000a34 <__aeabi_dcmplt>
 8000fb8:	2800      	cmp	r0, #0
 8000fba:	f040 80a2 	bne.w	8001102 <compute_event_pos+0x232>
	for (uint8_t i = 0; i < 50; i++)
 8000fbe:	1e6b      	subs	r3, r5, #1
 8000fc0:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
		old_res2 = res2;
 8000fc4:	eef0 4a6c 	vmov.f32	s9, s25
		old_res1 = res1;
 8000fc8:	eeb0 4a4c 	vmov.f32	s8, s24
	for (uint8_t i = 0; i < 50; i++)
 8000fcc:	f000 8094 	beq.w	80010f8 <compute_event_pos+0x228>
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fd0:	edd4 2a01 	vldr	s5, [r4, #4]
 8000fd4:	edd8 6a00 	vldr	s13, [r8]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000fd8:	ed94 6a03 	vldr	s12, [r4, #12]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000fdc:	ed94 7a05 	vldr	s14, [r4, #20]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fe0:	ed94 2a00 	vldr	s4, [r4]
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000fe4:	edd4 5a02 	vldr	s11, [r4, #8]
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000fe8:	ed94 5a04 	vldr	s10, [r4, #16]
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000fec:	ee7b 7ae2 	vsub.f32	s15, s23, s5
 8000ff0:	ee76 1ac2 	vsub.f32	s3, s13, s4
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8000ff4:	ee3b 6ac6 	vsub.f32	s12, s23, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8000ff8:	ee3b 7ac7 	vsub.f32	s14, s23, s14
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8000ffc:	ee67 7aa7 	vmul.f32	s15, s15, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001000:	ee76 5ae5 	vsub.f32	s11, s13, s11
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8001004:	eee1 7aa1 	vfma.f32	s15, s3, s3
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001008:	ee66 3a06 	vmul.f32	s7, s12, s12
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 800100c:	ee36 5ac5 	vsub.f32	s10, s13, s10
 8001010:	ee27 3a07 	vmul.f32	s6, s14, s14
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001014:	eee5 3aa5 	vfma.f32	s7, s11, s11
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 8001018:	eea5 3a05 	vfma.f32	s6, s10, s10
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 800101c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8001020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float32_t r0 = sqrtf(powf(*x - mics_xy[0].x, 2) + powf(*y - mics_xy[0].y, 2));
 8001024:	eef1 1ae7 	vsqrt.f32	s3, s15
		float32_t r1 = sqrtf(powf(*x - mics_xy[1].x, 2) + powf(*y - mics_xy[1].y, 2));
 8001028:	eeb1 1ae3 	vsqrt.f32	s2, s7
		float32_t r2 = sqrtf(powf(*x - mics_xy[2].x, 2) + powf(*y - mics_xy[2].y, 2));
 800102c:	eef1 0ac3 	vsqrt.f32	s1, s6
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8001030:	d067      	beq.n	8001102 <compute_event_pos+0x232>
 8001032:	eef5 3a40 	vcmp.f32	s7, #0.0
 8001036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800103a:	d062      	beq.n	8001102 <compute_event_pos+0x232>
 800103c:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8001040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001044:	d05d      	beq.n	8001102 <compute_event_pos+0x232>
		float32_t res2 = r2 - r0 - d20;
 8001046:	ee70 cac8 	vsub.f32	s25, s1, s16
		float32_t res1 = r1 - r0 - d10;
 800104a:	ee31 ca68 	vsub.f32	s24, s2, s17
		float32_t res2 = r2 - r0 - d20;
 800104e:	ee7c cae1 	vsub.f32	s25, s25, s3
		float32_t res1 = r1 - r0 - d10;
 8001052:	ee3c ca61 	vsub.f32	s24, s24, s3
		float32_t cost = res1 * res1 + res2 * res2;
 8001056:	ee6c 3aac 	vmul.f32	s7, s25, s25
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 800105a:	ee64 7aa4 	vmul.f32	s15, s9, s9
		float32_t cost = res1 * res1 + res2 * res2;
 800105e:	eeec 3a0c 	vfma.f32	s7, s24, s24
		float32_t old_cost = old_res1 * old_res1 + old_res2 * old_res2;
 8001062:	eee4 7a04 	vfma.f32	s15, s8, s8
		if (cost < 1e-8f)	return 1;
 8001066:	eef4 3ac9 	vcmpe.f32	s7, s18
 800106a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800106e:	d448      	bmi.n	8001102 <compute_event_pos+0x232>
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001070:	ee32 2a66 	vsub.f32	s4, s4, s13
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 8001074:	ee72 2aeb 	vsub.f32	s5, s5, s23
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 8001078:	eef4 3ae7 	vcmpe.f32	s7, s15
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800107c:	ee82 3aa1 	vdiv.f32	s6, s5, s3
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001080:	ee82 0a21 	vdiv.f32	s0, s4, s3
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8001084:	eec5 2a20 	vdiv.f32	s5, s10, s1
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8001088:	eec7 3a20 	vdiv.f32	s7, s14, s1
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800108c:	eec6 7a01 	vdiv.f32	s15, s12, s2
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 8001090:	ee85 7a81 	vdiv.f32	s14, s11, s2
		float32_t j21 = (*x - mics_xy[2].x) / r2 - (*x - mics_xy[0].x) / r0;
 8001094:	ee32 5a80 	vadd.f32	s10, s5, s0
		float32_t j22 = (*y - mics_xy[2].y) / r2 - (*y - mics_xy[0].y) / r0;
 8001098:	ee73 3a83 	vadd.f32	s7, s7, s6
		float32_t j12 = (*y - mics_xy[1].y) / r1 - (*y - mics_xy[0].y) / r0;
 800109c:	ee77 7a83 	vadd.f32	s15, s15, s6
		float32_t j11 = (*x - mics_xy[1].x) / r1 - (*x - mics_xy[0].x) / r0;
 80010a0:	ee37 7a00 	vadd.f32	s14, s14, s0
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 80010a4:	ee65 5a05 	vmul.f32	s11, s10, s10
		float32_t prod12 = j11 * j12 + j21 * j22;
 80010a8:	ee25 3a23 	vmul.f32	s6, s10, s7
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 80010ac:	ee23 6aa3 	vmul.f32	s12, s7, s7
 80010b0:	eee7 5a07 	vfma.f32	s11, s14, s14
		float32_t prod12 = j11 * j12 + j21 * j22;
 80010b4:	eea7 3a27 	vfma.f32	s6, s14, s15
 80010b8:	eea7 6aa7 	vfma.f32	s12, s15, s15
		if (cost < old_cost)		lambda *= 0.3f;			// reward improvement
 80010bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010c0:	bf4c      	ite	mi
 80010c2:	ee2d da2a 	vmulmi.f32	s26, s26, s21
		else						lambda *= 5.0f;			// punish bad step
 80010c6:	ee2d da0a 	vmulpl.f32	s26, s26, s20
		float32_t det = prod11 * prod22 - prod12 * prod21;
 80010ca:	ee63 2a43 	vnmul.f32	s5, s6, s6
		float32_t prod11 = j11 * j11 + j21 * j21 + lambda;
 80010ce:	ee7d 5a25 	vadd.f32	s11, s26, s11
		float32_t prod22 = j12 * j12 + j22 * j22 + lambda;
 80010d2:	ee3d 6a06 	vadd.f32	s12, s26, s12
		float32_t det = prod11 * prod22 - prod12 * prod21;
 80010d6:	eee5 2a86 	vfma.f32	s5, s11, s12
		if (fabsf(det) < 1e-12f)
 80010da:	eeb0 2ae2 	vabs.f32	s4, s5
 80010de:	eeb4 2ae9 	vcmpe.f32	s4, s19
 80010e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010e6:	f57f af1b 	bpl.w	8000f20 <compute_event_pos+0x50>
	for (uint8_t i = 0; i < 50; i++)
 80010ea:	1e6b      	subs	r3, r5, #1
 80010ec:	f013 05ff 	ands.w	r5, r3, #255	@ 0xff
			lambda *= 10.0f;
 80010f0:	ee2d da0b 	vmul.f32	s26, s26, s22
	for (uint8_t i = 0; i < 50; i++)
 80010f4:	f47f af6c 	bne.w	8000fd0 <compute_event_pos+0x100>
}
 80010f8:	ecbd 8b0e 	vpop	{d8-d14}
 80010fc:	4628      	mov	r0, r5
 80010fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001102:	ecbd 8b0e 	vpop	{d8-d14}
		if (r0 == 0 || r1 == 0 || r2 == 0) return 1;
 8001106:	2501      	movs	r5, #1
}
 8001108:	4628      	mov	r0, r5
 800110a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800110e:	bf00      	nop
 8001110:	88e368f1 	.word	0x88e368f1
 8001114:	3ee4f8b5 	.word	0x3ee4f8b5
 8001118:	43ab8000 	.word	0x43ab8000
 800111c:	00000000 	.word	0x00000000
 8001120:	3a83126f 	.word	0x3a83126f
 8001124:	322bcc77 	.word	0x322bcc77
 8001128:	3e99999a 	.word	0x3e99999a
 800112c:	2b8cbccc 	.word	0x2b8cbccc
 8001130:	be4ccccd 	.word	0xbe4ccccd
 8001134:	3e4ccccd 	.word	0x3e4ccccd

08001138 <compute_envelope>:
}

void compute_envelope(struct MicProc * mics)
{
	// square signals and multiply with gain of 2
	for (uint32_t i = 0; i < N_MICS; i++)
 8001138:	f500 51fb 	add.w	r1, r0, #8032	@ 0x1f60
{
 800113c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800113e:	4605      	mov	r5, r0
 8001140:	f500 4059 	add.w	r0, r0, #55552	@ 0xd900
 8001144:	3118      	adds	r1, #24
 8001146:	3078      	adds	r0, #120	@ 0x78
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8001148:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
{
 800114c:	460a      	mov	r2, r1
			mics[i].envelope[j] = mics[i].samples[j] * mics[i].samples[j] * 2;
 800114e:	ecf3 7a01 	vldmia	r3!, {s15}
 8001152:	ee67 7aa7 	vmul.f32	s15, s15, s15
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8001156:	428b      	cmp	r3, r1
			mics[i].envelope[j] = mics[i].samples[j] * mics[i].samples[j] * 2;
 8001158:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800115c:	ece2 7a01 	vstmia	r2!, {s15}
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 8001160:	d1f5      	bne.n	800114e <compute_envelope+0x16>
	for (uint32_t i = 0; i < N_MICS; i++)
 8001162:	f503 5178 	add.w	r1, r3, #15872	@ 0x3e00
 8001166:	4281      	cmp	r1, r0
 8001168:	d1ee      	bne.n	8001148 <compute_envelope+0x10>
 800116a:	f505 463a 	add.w	r6, r5, #47616	@ 0xba00
 800116e:	f105 0424 	add.w	r4, r5, #36	@ 0x24
 8001172:	3624      	adds	r6, #36	@ 0x24

	// Lowpass filter to remove high frequencies accumulated during scaling
	for (uint32_t i = 0; i < N_MICS; i++)
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8001174:	f641 7754 	movw	r7, #8020	@ 0x1f54
 8001178:	19e2      	adds	r2, r4, r7
 800117a:	4620      	mov	r0, r4
 800117c:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 8001180:	4611      	mov	r1, r2
	for (uint32_t i = 0; i < N_MICS; i++)
 8001182:	f504 5478 	add.w	r4, r4, #15872	@ 0x3e00
		arm_fir_f32(&mics[i].lp_hfir, mics[i].envelope, mics[i].envelope, N_SAMPLE);
 8001186:	f000 fb6d 	bl	8001864 <arm_fir_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 800118a:	42b4      	cmp	r4, r6
 800118c:	d1f4      	bne.n	8001178 <compute_envelope+0x40>
 800118e:	f505 511b 	add.w	r1, r5, #9920	@ 0x26c0
 8001192:	f505 4560 	add.w	r5, r5, #57344	@ 0xe000
 */
__STATIC_FORCEINLINE arm_status arm_sqrt_f32(
  const float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8001196:	2000      	movs	r0, #0
 8001198:	3138      	adds	r1, #56	@ 0x38
 800119a:	35f8      	adds	r5, #248	@ 0xf8

	// square root output
	for (uint32_t i = 0; i < N_MICS; i++)
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 800119c:	f5a1 63f0 	sub.w	r3, r1, #1920	@ 0x780
 80011a0:	e005      	b.n	80011ae <compute_envelope+0x76>
 80011a2:	428b      	cmp	r3, r1
      *pOut = _sqrtf(in);
#elif defined(__GNUC_PYTHON__)
      *pOut = sqrtf(in);
#elif defined ( __GNUC__ )
  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
      __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 80011a4:	eef1 7ae7 	vsqrt.f32	s15, s15
 80011a8:	edc2 7a00 	vstr	s15, [r2]
 80011ac:	d00b      	beq.n	80011c6 <compute_envelope+0x8e>
 80011ae:	461a      	mov	r2, r3
			arm_sqrt_f32(mics[i].envelope[j], &mics[i].envelope[j]);
 80011b0:	ecf3 7a01 	vldmia	r3!, {s15}
    if (in >= 0.0f)
 80011b4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80011b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011bc:	daf1      	bge.n	80011a2 <compute_envelope+0x6a>
		for (uint32_t j = 0; j < N_SAMPLE; j++)
 80011be:	428b      	cmp	r3, r1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 80011c0:	f843 0c04 	str.w	r0, [r3, #-4]
 80011c4:	d1f3      	bne.n	80011ae <compute_envelope+0x76>
	for (uint32_t i = 0; i < N_MICS; i++)
 80011c6:	f503 5178 	add.w	r1, r3, #15872	@ 0x3e00
 80011ca:	42a9      	cmp	r1, r5
 80011cc:	d1e6      	bne.n	800119c <compute_envelope+0x64>
}
 80011ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080011d0 <main>:
{
 80011d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80011d4:	ed2d 8b06 	vpush	{d8-d10}
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 80011d8:	4d86      	ldr	r5, [pc, #536]	@ (80013f4 <main+0x224>)
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 80011da:	4f87      	ldr	r7, [pc, #540]	@ (80013f8 <main+0x228>)
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 80011dc:	4e87      	ldr	r6, [pc, #540]	@ (80013fc <main+0x22c>)
{
 80011de:	f5ad 4d4a 	sub.w	sp, sp, #51712	@ 0xca00
 80011e2:	b09f      	sub	sp, #124	@ 0x7c
	sysclock_init();
 80011e4:	f7ff fc9e 	bl	8000b24 <sysclock_init>
	struct MicCoord mics_xy[N_MICS] = {{.x = MIC0_XPOS, .y = MIC0_YPOS}, {.x = MIC1_XPOS, .y = MIC1_YPOS}, {.x = MIC2_XPOS, .y = MIC2_YPOS}};
 80011e8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80011ea:	ac0c      	add	r4, sp, #48	@ 0x30
 80011ec:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80011ee:	e895 0003 	ldmia.w	r5, {r0, r1}
 80011f2:	e884 0003 	stmia.w	r4, {r0, r1}
 80011f6:	f50d 5483 	add.w	r4, sp, #4192	@ 0x1060
 80011fa:	3418      	adds	r4, #24
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 80011fc:	4620      	mov	r0, r4
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 80011fe:	f44f 75f0 	mov.w	r5, #480	@ 0x1e0
		arm_rfft_fast_init_256_f32(&mics[i].hfft);
 8001202:	f001 fad5 	bl	80027b0 <arm_rfft_fast_init_256_f32>
		arm_fir_init_f32(&mics[i].bp_hfir, N_BP_TAPS, bandpass_taps, mics[i].bp_state, N_SAMPLE);
 8001206:	f104 0330 	add.w	r3, r4, #48	@ 0x30
 800120a:	f104 0018 	add.w	r0, r4, #24
 800120e:	212a      	movs	r1, #42	@ 0x2a
 8001210:	463a      	mov	r2, r7
 8001212:	9500      	str	r5, [sp, #0]
 8001214:	f000 fb60 	bl	80018d8 <arm_fir_init_f32>
		arm_fir_init_f32(&mics[i].lp_hfir, N_LP_TAPS, lowpass_taps, mics[i].lp_state, N_SAMPLE);
 8001218:	f604 0354 	addw	r3, r4, #2132	@ 0x854
 800121c:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8001220:	212a      	movs	r1, #42	@ 0x2a
 8001222:	9500      	str	r5, [sp, #0]
 8001224:	4632      	mov	r2, r6
 8001226:	f000 fb57 	bl	80018d8 <arm_fir_init_f32>
	for (uint32_t i = 0; i < N_MICS; i++)
 800122a:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 800122e:	f504 5478 	add.w	r4, r4, #15872	@ 0x3e00
 8001232:	3378      	adds	r3, #120	@ 0x78
 8001234:	42a3      	cmp	r3, r4
 8001236:	d1e1      	bne.n	80011fc <main+0x2c>
	arm_rfft_fast_init_256_f32(&xcorr_01_freq_hfft);
 8001238:	a812      	add	r0, sp, #72	@ 0x48
 800123a:	f001 fab9 	bl	80027b0 <arm_rfft_fast_init_256_f32>
	arm_rfft_fast_init_256_f32(&xcorr_02_freq_hfft);
 800123e:	a818      	add	r0, sp, #96	@ 0x60
 8001240:	f001 fab6 	bl	80027b0 <arm_rfft_fast_init_256_f32>
	uart2_set_fcpu(84000000);
 8001244:	486e      	ldr	r0, [pc, #440]	@ (8001400 <main+0x230>)
			float32_t mic02_delay = -((float32_t) lag02 * T_SAMPLE);
 8001246:	ed9f 8a6f 	vldr	s16, [pc, #444]	@ 8001404 <main+0x234>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 800124a:	eddf 9a6f 	vldr	s19, [pc, #444]	@ 8001408 <main+0x238>
 800124e:	ed9f aa6f 	vldr	s20, [pc, #444]	@ 800140c <main+0x23c>
 8001252:	f8df b1c8 	ldr.w	fp, [pc, #456]	@ 800141c <main+0x24c>
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 8001256:	ed9f 9a6e 	vldr	s18, [pc, #440]	@ 8001410 <main+0x240>
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 800125a:	eddf 8a6e 	vldr	s17, [pc, #440]	@ 8001414 <main+0x244>
	uart2_set_fcpu(84000000);
 800125e:	f001 fac5 	bl	80027ec <uart2_set_fcpu>
	uart2_dma1_config(115200, USART_DATA_8, USART_STOP_1);
 8001262:	2200      	movs	r2, #0
 8001264:	4611      	mov	r1, r2
 8001266:	f44f 30e1 	mov.w	r0, #115200	@ 0x1c200
 800126a:	f001 facf 	bl	800280c <uart2_dma1_config>
	spi1_dma2_init();
 800126e:	f7ff fc9b 	bl	8000ba8 <spi1_dma2_init>
	uint32_t last_trigger_sample = 0;
 8001272:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001276:	3318      	adds	r3, #24
 8001278:	f04f 0c00 	mov.w	ip, #0
 800127c:	f503 5667 	add.w	r6, r3, #14784	@ 0x39c0
 8001280:	f503 5477 	add.w	r4, r3, #15808	@ 0x3dc0
 8001284:	3638      	adds	r6, #56	@ 0x38
 8001286:	3438      	adds	r4, #56	@ 0x38
	uint32_t samples = 0;
 8001288:	46e1      	mov	r9, ip
	uint32_t ref_sample = 0;
 800128a:	f8cd c014 	str.w	ip, [sp, #20]
	uint8_t triggered = 0;									// has a microphone detected an event?
 800128e:	f8cd c008 	str.w	ip, [sp, #8]
	uint8_t window_ind = 0;
 8001292:	4665      	mov	r5, ip
 8001294:	f8cd c00c 	str.w	ip, [sp, #12]
		while (!!(DMA2_Stream0->CR & DMA_SxCR_CT) == dma_tgt);		// wait for stream to complete
 8001298:	f89b 2000 	ldrb.w	r2, [fp]
 800129c:	495e      	ldr	r1, [pc, #376]	@ (8001418 <main+0x248>)
 800129e:	690b      	ldr	r3, [r1, #16]
 80012a0:	f3c3 43c0 	ubfx	r3, r3, #19, #1
 80012a4:	4293      	cmp	r3, r2
 80012a6:	d0fa      	beq.n	800129e <main+0xce>
		dma_tgt = !dma_tgt;											// switch DMA targets
 80012a8:	fab2 f282 	clz	r2, r2
 80012ac:	0952      	lsrs	r2, r2, #5
 80012ae:	f88b 2000 	strb.w	r2, [fp]
		DMA2->LIFCR |= DMA_LIFCR_CTCIF0 | DMA_LIFCR_CHTIF0;			// clear transfer complete and half complete flag
 80012b2:	688b      	ldr	r3, [r1, #8]
		stream_splice(mics);
 80012b4:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
		DMA2->LIFCR |= DMA_LIFCR_CTCIF0 | DMA_LIFCR_CHTIF0;			// clear transfer complete and half complete flag
 80012b8:	f043 0330 	orr.w	r3, r3, #48	@ 0x30
 80012bc:	608b      	str	r3, [r1, #8]
		stream_splice(mics);
 80012be:	3018      	adds	r0, #24
 80012c0:	f7ff fd36 	bl	8000d30 <stream_splice>
			arm_fir_f32(&mics[i].bp_hfir, mics[i].raw, mics[i].samples, N_SAMPLE);
 80012c4:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 80012c8:	f50d 5183 	add.w	r1, sp, #4192	@ 0x1060
 80012cc:	3218      	adds	r2, #24
 80012ce:	3118      	adds	r1, #24
 80012d0:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 80012d4:	f502 52bf 	add.w	r2, r2, #6112	@ 0x17e0
 80012d8:	f501 5183 	add.w	r1, r1, #4192	@ 0x1060
 80012dc:	3018      	adds	r0, #24
 80012de:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 80012e2:	3218      	adds	r2, #24
 80012e4:	3118      	adds	r1, #24
 80012e6:	3018      	adds	r0, #24
 80012e8:	f000 fabc 	bl	8001864 <arm_fir_f32>
 80012ec:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 80012f0:	f50d 5183 	add.w	r1, sp, #4192	@ 0x1060
 80012f4:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 80012f8:	3218      	adds	r2, #24
 80012fa:	3118      	adds	r1, #24
 80012fc:	3018      	adds	r0, #24
 80012fe:	f502 42ab 	add.w	r2, r2, #21888	@ 0x5580
 8001302:	f501 419c 	add.w	r1, r1, #19968	@ 0x4e00
 8001306:	f500 5078 	add.w	r0, r0, #15872	@ 0x3e00
 800130a:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800130e:	3278      	adds	r2, #120	@ 0x78
 8001310:	3178      	adds	r1, #120	@ 0x78
 8001312:	3018      	adds	r0, #24
 8001314:	f000 faa6 	bl	8001864 <arm_fir_f32>
 8001318:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 800131c:	f50d 5183 	add.w	r1, sp, #4192	@ 0x1060
 8001320:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 8001324:	3218      	adds	r2, #24
 8001326:	3118      	adds	r1, #24
 8001328:	3018      	adds	r0, #24
 800132a:	f502 4213 	add.w	r2, r2, #37632	@ 0x9300
 800132e:	f501 410c 	add.w	r1, r1, #35840	@ 0x8c00
 8001332:	f500 40f8 	add.w	r0, r0, #31744	@ 0x7c00
 8001336:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800133a:	32f8      	adds	r2, #248	@ 0xf8
 800133c:	3178      	adds	r1, #120	@ 0x78
 800133e:	3018      	adds	r0, #24
 8001340:	f000 fa90 	bl	8001864 <arm_fir_f32>
		compute_envelope(mics);
 8001344:	f50d 5083 	add.w	r0, sp, #4192	@ 0x1060
 8001348:	3018      	adds	r0, #24
 800134a:	f7ff fef5 	bl	8001138 <compute_envelope>
			arm_copy_f32(mics[i].envelope, mics[i].buffer + window_ind * N_SAMPLE, N_SAMPLE); 		// copy envelope to buffer for processing later
 800134e:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001352:	3318      	adds	r3, #24
 8001354:	f503 511b 	add.w	r1, r3, #9920	@ 0x26c0
 8001358:	f503 5afb 	add.w	sl, r3, #8032	@ 0x1f60
 800135c:	ebc5 1705 	rsb	r7, r5, r5, lsl #4
 8001360:	3138      	adds	r1, #56	@ 0x38
 8001362:	f10a 0a18 	add.w	sl, sl, #24
 8001366:	eb01 11c7 	add.w	r1, r1, r7, lsl #7
 800136a:	012b      	lsls	r3, r5, #4
 800136c:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8001370:	4650      	mov	r0, sl
 8001372:	9304      	str	r3, [sp, #16]
 8001374:	f000 fae4 	bl	8001940 <arm_copy_f32>
 8001378:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 800137c:	3318      	adds	r3, #24
 800137e:	f503 41c9 	add.w	r1, r3, #25728	@ 0x6480
 8001382:	f503 40ba 	add.w	r0, r3, #23808	@ 0x5d00
 8001386:	01ff      	lsls	r7, r7, #7
 8001388:	3178      	adds	r1, #120	@ 0x78
 800138a:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800138e:	4439      	add	r1, r7
 8001390:	3078      	adds	r0, #120	@ 0x78
 8001392:	f000 fad5 	bl	8001940 <arm_copy_f32>
 8001396:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 800139a:	3318      	adds	r3, #24
 800139c:	f503 4122 	add.w	r1, r3, #41472	@ 0xa200
 80013a0:	f503 401b 	add.w	r0, r3, #39680	@ 0x9b00
 80013a4:	31f8      	adds	r1, #248	@ 0xf8
 80013a6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 80013aa:	4439      	add	r1, r7
 80013ac:	3078      	adds	r0, #120	@ 0x78
 80013ae:	f000 fac7 	bl	8001940 <arm_copy_f32>
		if (!triggered && samples - last_trigger_sample > N_UPDATE_DELAY)			// wait for event detection after N_UPDATE_DELAY samples since last event
 80013b2:	9b02      	ldr	r3, [sp, #8]
		samples += N_SAMPLE;
 80013b4:	f509 78f0 	add.w	r8, r9, #480	@ 0x1e0
		if (!triggered && samples - last_trigger_sample > N_UPDATE_DELAY)			// wait for event detection after N_UPDATE_DELAY samples since last event
 80013b8:	b9ab      	cbnz	r3, 80013e6 <main+0x216>
 80013ba:	9b03      	ldr	r3, [sp, #12]
 80013bc:	eba8 0203 	sub.w	r2, r8, r3
 80013c0:	f5b2 7ffa 	cmp.w	r2, #500	@ 0x1f4
 80013c4:	f200 8171 	bhi.w	80016aa <main+0x4da>
		if (++window_ind == N_WINDOW)
 80013c8:	3501      	adds	r5, #1
 80013ca:	b2ed      	uxtb	r5, r5
			window_ind = 0;
 80013cc:	2d02      	cmp	r5, #2
 80013ce:	bf08      	it	eq
 80013d0:	2500      	moveq	r5, #0
 80013d2:	46c1      	mov	r9, r8
 80013d4:	e760      	b.n	8001298 <main+0xc8>
				if (thresh_ind_sorted[i] != -1)
 80013d6:	460b      	mov	r3, r1
					ref_sample = thresh_ind_sorted[i] + window_ind * N_SAMPLE;				// calculate reference sample location in buffer
 80013d8:	9a04      	ldr	r2, [sp, #16]
 80013da:	1b52      	subs	r2, r2, r5
 80013dc:	eb03 1242 	add.w	r2, r3, r2, lsl #5
					last_trigger_sample = samples - (N_SAMPLE - thresh_ind_sorted[i]);		// compute global sample value
 80013e0:	444b      	add	r3, r9
					ref_sample = thresh_ind_sorted[i] + window_ind * N_SAMPLE;				// calculate reference sample location in buffer
 80013e2:	9205      	str	r2, [sp, #20]
					last_trigger_sample = samples - (N_SAMPLE - thresh_ind_sorted[i]);		// compute global sample value
 80013e4:	9303      	str	r3, [sp, #12]
		if (triggered && samples > last_trigger_sample + N_SAMPLES_AFTER)		// wait until enough samples have been taken after peak is detected
 80013e6:	9b03      	ldr	r3, [sp, #12]
 80013e8:	33e5      	adds	r3, #229	@ 0xe5
 80013ea:	4543      	cmp	r3, r8
 80013ec:	d318      	bcc.n	8001420 <main+0x250>
 80013ee:	2301      	movs	r3, #1
 80013f0:	9302      	str	r3, [sp, #8]
 80013f2:	e7e9      	b.n	80013c8 <main+0x1f8>
 80013f4:	08002b3c 	.word	0x08002b3c
 80013f8:	08002bfc 	.word	0x08002bfc
 80013fc:	08002b54 	.word	0x08002b54
 8001400:	0501bd00 	.word	0x0501bd00
 8001404:	37d1b717 	.word	0x37d1b717
 8001408:	3f99999a 	.word	0x3f99999a
 800140c:	be4ccccd 	.word	0xbe4ccccd
 8001410:	3e9c0ebf 	.word	0x3e9c0ebf
 8001414:	3f1c0ebf 	.word	0x3f1c0ebf
 8001418:	40026400 	.word	0x40026400
 800141c:	20000020 	.word	0x20000020
			int32_t start_sample = (int32_t) ref_sample - N_SAMPLES_BEFORE;
 8001420:	9905      	ldr	r1, [sp, #20]
 8001422:	f1a1 031a 	sub.w	r3, r1, #26
			if (start_sample > 0 && stop_sample < N_BUFFER)					// if N_FFT is not wrapped in buffer...
 8001426:	2b00      	cmp	r3, #0
 8001428:	f340 817c 	ble.w	8001724 <main+0x554>
 800142c:	f240 22da 	movw	r2, #730	@ 0x2da
 8001430:	4291      	cmp	r1, r2
 8001432:	f300 817a 	bgt.w	800172a <main+0x55a>
					arm_copy_f32(mics[i].buffer + start_sample, mics[i].fft_window, N_FFT);
 8001436:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 800143a:	3218      	adds	r2, #24
 800143c:	f502 501b 	add.w	r0, r2, #9920	@ 0x26c0
 8001440:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 8001444:	3038      	adds	r0, #56	@ 0x38
 8001446:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800144a:	3138      	adds	r1, #56	@ 0x38
 800144c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001450:	009f      	lsls	r7, r3, #2
 8001452:	f000 fa75 	bl	8001940 <arm_copy_f32>
 8001456:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 800145a:	3318      	adds	r3, #24
 800145c:	f503 40c9 	add.w	r0, r3, #25728	@ 0x6480
 8001460:	f503 41e7 	add.w	r1, r3, #29568	@ 0x7380
 8001464:	3078      	adds	r0, #120	@ 0x78
 8001466:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800146a:	4438      	add	r0, r7
 800146c:	3178      	adds	r1, #120	@ 0x78
 800146e:	f000 fa67 	bl	8001940 <arm_copy_f32>
 8001472:	f50d 5383 	add.w	r3, sp, #4192	@ 0x1060
 8001476:	3318      	adds	r3, #24
 8001478:	f503 4022 	add.w	r0, r3, #41472	@ 0xa200
 800147c:	30f8      	adds	r0, #248	@ 0xf8
 800147e:	f50d 4142 	add.w	r1, sp, #49664	@ 0xc200
 8001482:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001486:	4438      	add	r0, r7
 8001488:	3170      	adds	r1, #112	@ 0x70
 800148a:	f000 fa59 	bl	8001940 <arm_copy_f32>
						curr_sample = 0;
 800148e:	f50d 5a83 	add.w	sl, sp, #4192	@ 0x1060
 8001492:	f10a 0a18 	add.w	sl, sl, #24
				arm_rfft_fast_f32(&mics[i].hfft, mics[i].fft_window, mics[i].fft, 0);
 8001496:	f643 19f8 	movw	r9, #14840	@ 0x39f8
 800149a:	f243 57f8 	movw	r7, #13816	@ 0x35f8
 800149e:	2300      	movs	r3, #0
 80014a0:	eb0a 0209 	add.w	r2, sl, r9
 80014a4:	eb0a 0107 	add.w	r1, sl, r7
 80014a8:	4650      	mov	r0, sl
 80014aa:	f001 f8cb 	bl	8002644 <arm_rfft_fast_f32>
			for (uint32_t i = 0; i < N_MICS; i++)
 80014ae:	f50d 434a 	add.w	r3, sp, #51712	@ 0xca00
 80014b2:	f50a 5a78 	add.w	sl, sl, #15872	@ 0x3e00
 80014b6:	3378      	adds	r3, #120	@ 0x78
 80014b8:	4553      	cmp	r3, sl
 80014ba:	d1f0      	bne.n	800149e <main+0x2ce>
 80014bc:	f50d 4394 	add.w	r3, sp, #18944	@ 0x4a00
 80014c0:	f50d 4208 	add.w	r2, sp, #34816	@ 0x8800
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 80014c4:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 80014c8:	3378      	adds	r3, #120	@ 0x78
 80014ca:	f60d 0078 	addw	r0, sp, #2168	@ 0x878
 80014ce:	f60d 4178 	addw	r1, sp, #3192	@ 0xc78
 80014d2:	3278      	adds	r2, #120	@ 0x78
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 80014d4:	f647 4c04 	movw	ip, #31748	@ 0x7c04
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014d8:	edd3 6a00 	vldr	s13, [r3]
 80014dc:	edd2 7a01 	vldr	s15, [r2, #4]
 80014e0:	ed93 6a01 	vldr	s12, [r3, #4]
 80014e4:	edd2 5a00 	vldr	s11, [r2]
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 80014e8:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014ec:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_01 = mics[0].fft[i+1] * mics[1].fft[i] - mics[0].fft[i] * mics[1].fft[i+1];		// imag
 80014f0:	eea5 7a86 	vfma.f32	s14, s11, s12
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 80014f4:	eb03 070c 	add.w	r7, r3, ip
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80014f8:	3208      	adds	r2, #8
				float32_t re_01 = mics[0].fft[i] * mics[1].fft[i] + mics[0].fft[i+1] * mics[1].fft[i+1];		// real
 80014fa:	eee6 7aa5 	vfma.f32	s15, s13, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 80014fe:	3008      	adds	r0, #8
 8001500:	3108      	adds	r1, #8
				float32_t mag_01 = sqrtf(re_01 * re_01 + im_01 * im_01);
 8001502:	ee67 5a07 	vmul.f32	s11, s14, s14
 8001506:	eee7 5aa7 	vfma.f32	s11, s15, s15
 800150a:	eef1 4ae5 	vsqrt.f32	s9, s11
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800150e:	eec5 5a24 	vdiv.f32	s11, s10, s9
 8001512:	ee65 7aa7 	vmul.f32	s15, s11, s15
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001516:	ee65 5a87 	vmul.f32	s11, s11, s14
				xcorr_01_freq[i] = re_01 * (1 / mag_01);
 800151a:	edc0 7a00 	vstr	s15, [r0]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800151e:	edd7 7a00 	vldr	s15, [r7]
				xcorr_01_freq[i+1] = im_01 * (1 / mag_01);
 8001522:	edc0 5a01 	vstr	s11, [r0, #4]
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 8001526:	f503 47f8 	add.w	r7, r3, #31744	@ 0x7c00
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 800152a:	ee27 7ae6 	vnmul.f32	s14, s15, s13
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800152e:	edd7 5a00 	vldr	s11, [r7]
 8001532:	ee66 7a27 	vmul.f32	s15, s12, s15
				float32_t im_02 = mics[0].fft[i+1] * mics[2].fft[i] - mics[0].fft[i] * mics[2].fft[i+1];		// imag
 8001536:	eea6 7a25 	vfma.f32	s14, s12, s11
			for (uint32_t i = 2; i < N_FFT; i += 2)
 800153a:	3308      	adds	r3, #8
 800153c:	429c      	cmp	r4, r3
				float32_t re_02 = mics[0].fft[i] * mics[2].fft[i] + mics[0].fft[i+1] * mics[2].fft[i+1];		// real
 800153e:	eee6 7aa5 	vfma.f32	s15, s13, s11
				float32_t mag_02 = sqrtf(re_02 * re_02 + im_02 * im_02);
 8001542:	ee67 6a07 	vmul.f32	s13, s14, s14
 8001546:	eee7 6aa7 	vfma.f32	s13, s15, s15
 800154a:	eeb1 6ae6 	vsqrt.f32	s12, s13
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 800154e:	eec5 6a06 	vdiv.f32	s13, s10, s12
 8001552:	ee66 7aa7 	vmul.f32	s15, s13, s15
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 8001556:	ee66 6a87 	vmul.f32	s13, s13, s14
				xcorr_02_freq[i] = re_02 * (1 / mag_02);
 800155a:	edc1 7a00 	vstr	s15, [r1]
				xcorr_02_freq[i+1] = im_02 * (1 / mag_02);
 800155e:	edc1 6a01 	vstr	s13, [r1, #4]
			for (uint32_t i = 2; i < N_FFT; i += 2)
 8001562:	d1b9      	bne.n	80014d8 <main+0x308>
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 8001564:	f50d 4346 	add.w	r3, sp, #50688	@ 0xc600
 8001568:	ed93 7a1c 	vldr	s14, [r3, #112]	@ 0x70
 800156c:	3370      	adds	r3, #112	@ 0x70
			xcorr_02_freq[1] = mics[0].fft[1] * mics[2].fft[1];
 800156e:	f50d 4346 	add.w	r3, sp, #50688	@ 0xc600
 8001572:	edd3 7a1d 	vldr	s15, [r3, #116]	@ 0x74
 8001576:	3374      	adds	r3, #116	@ 0x74
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 8001578:	f50d 4380 	add.w	r3, sp, #16384	@ 0x4000
 800157c:	3378      	adds	r3, #120	@ 0x78
 800157e:	f603 13f8 	addw	r3, r3, #2552	@ 0x9f8
 8001582:	edd3 6a00 	vldr	s13, [r3]
			xcorr_02_freq[0] = mics[0].fft[0] * mics[2].fft[0];
 8001586:	ee27 7a26 	vmul.f32	s14, s14, s13
 800158a:	f60d 4378 	addw	r3, sp, #3192	@ 0xc78
 800158e:	ed83 7a00 	vstr	s14, [r3]
			xcorr_01_freq[0] = mics[0].fft[0] * mics[1].fft[0];
 8001592:	f50d 4300 	add.w	r3, sp, #32768	@ 0x8000
 8001596:	3378      	adds	r3, #120	@ 0x78
 8001598:	f503 63ff 	add.w	r3, r3, #2040	@ 0x7f8
 800159c:	ed93 7a00 	vldr	s14, [r3]
 80015a0:	ee27 7a26 	vmul.f32	s14, s14, s13
 80015a4:	f60d 0378 	addw	r3, sp, #2168	@ 0x878
 80015a8:	ed83 7a00 	vstr	s14, [r3]
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 80015ac:	f50d 4380 	add.w	r3, sp, #16384	@ 0x4000
 80015b0:	3378      	adds	r3, #120	@ 0x78
 80015b2:	f603 13fc 	addw	r3, r3, #2556	@ 0x9fc
 80015b6:	ed93 7a00 	vldr	s14, [r3]
			xcorr_02_freq[1] = mics[0].fft[1] * mics[2].fft[1];
 80015ba:	ee67 7a87 	vmul.f32	s15, s15, s14
 80015be:	f60d 437c 	addw	r3, sp, #3196	@ 0xc7c
 80015c2:	edc3 7a00 	vstr	s15, [r3]
			xcorr_01_freq[1] = mics[0].fft[1] * mics[1].fft[1];
 80015c6:	f50d 4300 	add.w	r3, sp, #32768	@ 0x8000
 80015ca:	3378      	adds	r3, #120	@ 0x78
 80015cc:	f203 73fc 	addw	r3, r3, #2044	@ 0x7fc
 80015d0:	edd3 7a00 	vldr	s15, [r3]
 80015d4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80015d8:	f60d 037c 	addw	r3, sp, #2172	@ 0x87c
 80015dc:	edc3 7a00 	vstr	s15, [r3]
			arm_rfft_fast_f32(&xcorr_01_freq_hfft, xcorr_01_freq, xcorr_01_time, 1);
 80015e0:	aa1e      	add	r2, sp, #120	@ 0x78
 80015e2:	2301      	movs	r3, #1
 80015e4:	f60d 0178 	addw	r1, sp, #2168	@ 0x878
 80015e8:	a812      	add	r0, sp, #72	@ 0x48
 80015ea:	f001 f82b 	bl	8002644 <arm_rfft_fast_f32>
			arm_rfft_fast_f32(&xcorr_02_freq_hfft, xcorr_02_freq, xcorr_02_time, 1);
 80015ee:	2301      	movs	r3, #1
 80015f0:	f50d 628f 	add.w	r2, sp, #1144	@ 0x478
 80015f4:	f60d 4178 	addw	r1, sp, #3192	@ 0xc78
 80015f8:	a818      	add	r0, sp, #96	@ 0x60
 80015fa:	f001 f823 	bl	8002644 <arm_rfft_fast_f32>
			arm_max_f32(xcorr_01_time, N_FFT, &dummy, &max_ind_01);
 80015fe:	ab08      	add	r3, sp, #32
 8001600:	aa07      	add	r2, sp, #28
 8001602:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001606:	a81e      	add	r0, sp, #120	@ 0x78
 8001608:	f000 f976 	bl	80018f8 <arm_max_f32>
			arm_max_f32(xcorr_02_time, N_FFT, &dummy, &max_ind_02);
 800160c:	ab09      	add	r3, sp, #36	@ 0x24
 800160e:	aa07      	add	r2, sp, #28
 8001610:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8001614:	f50d 608f 	add.w	r0, sp, #1144	@ 0x478
 8001618:	f000 f96e 	bl	80018f8 <arm_max_f32>
			if (max_ind_01 > N_FFT / 2)
 800161c:	ab08      	add	r3, sp, #32
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 800161e:	af0a      	add	r7, sp, #40	@ 0x28
			if (max_ind_01 > N_FFT / 2)
 8001620:	681b      	ldr	r3, [r3, #0]
			coords.xy[0] = (MIC0_XPOS + MIC1_XPOS + MIC2_XPOS) / 3.0f;
 8001622:	ed87 9a00 	vstr	s18, [r7]
			if (max_ind_01 > N_FFT / 2)
 8001626:	2b80      	cmp	r3, #128	@ 0x80
				lag01 = (int32_t) max_ind_01 - N_FFT;
 8001628:	bf88      	it	hi
 800162a:	f5a3 7380 	subhi.w	r3, r3, #256	@ 0x100
				lag01 = max_ind_01;
 800162e:	ee00 3a10 	vmov	s0, r3
			if (max_ind_02 > N_FFT / 2)
 8001632:	ab09      	add	r3, sp, #36	@ 0x24
			float32_t mic01_delay = -((float32_t) lag01 * T_SAMPLE);
 8001634:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
			if (max_ind_02 > N_FFT / 2)
 8001638:	681b      	ldr	r3, [r3, #0]
			coords.xy[1] = (MIC0_YPOS + MIC1_YPOS + MIC2_YPOS) / 3.0f;
 800163a:	edc7 8a01 	vstr	s17, [r7, #4]
			if (max_ind_02 > N_FFT / 2)
 800163e:	2b80      	cmp	r3, #128	@ 0x80
				lag02 = (int32_t) max_ind_02 - N_FFT;
 8001640:	bf88      	it	hi
 8001642:	f5a3 7380 	subhi.w	r3, r3, #256	@ 0x100
			float32_t mic02_delay = -((float32_t) lag02 * T_SAMPLE);
 8001646:	ee07 3a90 	vmov	s15, r3
 800164a:	eef8 0ae7 	vcvt.f32.s32	s1, s15
			uint8_t valid = compute_event_pos(&coords.xy[0], &coords.xy[1], mics_xy, mic01_delay, mic02_delay);
 800164e:	ee28 0a40 	vnmul.f32	s0, s16, s0
 8001652:	ee68 0a60 	vnmul.f32	s1, s16, s1
 8001656:	aa0c      	add	r2, sp, #48	@ 0x30
 8001658:	a90b      	add	r1, sp, #44	@ 0x2c
 800165a:	4638      	mov	r0, r7
 800165c:	f7ff fc38 	bl	8000ed0 <compute_event_pos>
			if (!valid || coords.xy[0] > 1.2f || coords.xy[0] < -0.2f || coords.xy[1] > 1.2f || coords.xy[1] < -0.2f)
 8001660:	b1c0      	cbz	r0, 8001694 <main+0x4c4>
 8001662:	edd7 7a00 	vldr	s15, [r7]
 8001666:	eef4 7ae9 	vcmpe.f32	s15, s19
 800166a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800166e:	dc11      	bgt.n	8001694 <main+0x4c4>
 8001670:	eef4 7aca 	vcmpe.f32	s15, s20
 8001674:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001678:	d40c      	bmi.n	8001694 <main+0x4c4>
 800167a:	edd7 7a01 	vldr	s15, [r7, #4]
 800167e:	eef4 7ae9 	vcmpe.f32	s15, s19
 8001682:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001686:	dc05      	bgt.n	8001694 <main+0x4c4>
 8001688:	eef4 7aca 	vcmpe.f32	s15, s20
 800168c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001690:	f140 8099 	bpl.w	80017c6 <main+0x5f6>
				coords.xy[0] = -1.0f;
 8001694:	ab0a      	add	r3, sp, #40	@ 0x28
 8001696:	4a4e      	ldr	r2, [pc, #312]	@ (80017d0 <main+0x600>)
 8001698:	601a      	str	r2, [r3, #0]
				uart2_dma1_write(8, coords.ser);
 800169a:	4619      	mov	r1, r3
 800169c:	2008      	movs	r0, #8
				coords.xy[1] = -1.0f;
 800169e:	605a      	str	r2, [r3, #4]
				uart2_dma1_write(8, coords.ser);
 80016a0:	f001 f9d6 	bl	8002a50 <uart2_dma1_write>
			triggered = 0;
 80016a4:	2300      	movs	r3, #0
 80016a6:	9302      	str	r3, [sp, #8]
 80016a8:	e68e      	b.n	80013c8 <main+0x1f8>
 80016aa:	f60d 4078 	addw	r0, sp, #3192	@ 0xc78

int32_t thresh_search(float32_t * src, uint32_t len, float32_t thresh)
{
	for (uint32_t i = 0; i < len; i++)
	{
		if (src[i] > thresh)
 80016ae:	ed9f 7a49 	vldr	s14, [pc, #292]	@ 80017d4 <main+0x604>
 80016b2:	4651      	mov	r1, sl
 80016b4:	f100 070c 	add.w	r7, r0, #12
	uint8_t window_ind = 0;
 80016b8:	460a      	mov	r2, r1
	for (uint32_t i = 0; i < len; i++)
 80016ba:	2300      	movs	r3, #0
 80016bc:	e003      	b.n	80016c6 <main+0x4f6>
 80016be:	3301      	adds	r3, #1
 80016c0:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 80016c4:	d025      	beq.n	8001712 <main+0x542>
		if (src[i] > thresh)
 80016c6:	ecf2 7a01 	vldmia	r2!, {s15}
 80016ca:	eef4 7ac7 	vcmpe.f32	s15, s14
 80016ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80016d2:	ddf4      	ble.n	80016be <main+0x4ee>
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, ENERGY_THRESH);
 80016d4:	f840 3b04 	str.w	r3, [r0], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 80016d8:	4287      	cmp	r7, r0
 80016da:	f501 5178 	add.w	r1, r1, #15872	@ 0x3e00
 80016de:	d1eb      	bne.n	80016b8 <main+0x4e8>
}

void simple_sort3(int32_t * src, int32_t * dst)
{

	if (src[0] <= src[1] && src[0] <= src[2])
 80016e0:	f8dd 2c78 	ldr.w	r2, [sp, #3192]	@ 0xc78
 80016e4:	f8dd 3c7c 	ldr.w	r3, [sp, #3196]	@ 0xc7c
 80016e8:	f8dd 1c80 	ldr.w	r1, [sp, #3200]	@ 0xc80
 80016ec:	429a      	cmp	r2, r3
 80016ee:	dd5b      	ble.n	80017a8 <main+0x5d8>
		{
			dst[1] = src[2];
			dst[2] = src[1];
		}
	}
	else if (src[1] <= src[0] && src[1] <= src[2])
 80016f0:	428b      	cmp	r3, r1
 80016f2:	dc62      	bgt.n	80017ba <main+0x5ea>
	{
		dst[0] = src[1];

		if (src[0] <= src[2])
 80016f4:	428a      	cmp	r2, r1
 80016f6:	4608      	mov	r0, r1
		dst[0] = src[1];
 80016f8:	4619      	mov	r1, r3
		if (src[0] <= src[2])
 80016fa:	dd60      	ble.n	80017be <main+0x5ee>
			dst[2] = src[2];
		}
		else
		{
			dst[1] = src[2];
			dst[2] = src[0];
 80016fc:	4613      	mov	r3, r2
			dst[1] = src[2];
 80016fe:	4602      	mov	r2, r0
				if (thresh_ind_sorted[i] != -1)
 8001700:	1c48      	adds	r0, r1, #1
 8001702:	f47f ae68 	bne.w	80013d6 <main+0x206>
 8001706:	1c51      	adds	r1, r2, #1
 8001708:	d15b      	bne.n	80017c2 <main+0x5f2>
 800170a:	1c5a      	adds	r2, r3, #1
 800170c:	f43f ae5c 	beq.w	80013c8 <main+0x1f8>
 8001710:	e662      	b.n	80013d8 <main+0x208>
	return -1;
 8001712:	f04f 33ff 	mov.w	r3, #4294967295
				thresh_ind[i] = thresh_search(mics[i].envelope, N_SAMPLE, ENERGY_THRESH);
 8001716:	f840 3b04 	str.w	r3, [r0], #4
			for (uint32_t i = 0; i < N_MICS; i++)
 800171a:	4287      	cmp	r7, r0
 800171c:	f501 5178 	add.w	r1, r1, #15872	@ 0x3e00
 8001720:	d1ca      	bne.n	80016b8 <main+0x4e8>
 8001722:	e7dd      	b.n	80016e0 <main+0x510>
				if (start_sample < 0)
 8001724:	d001      	beq.n	800172a <main+0x55a>
					curr_sample = (int32_t)N_BUFFER + start_sample;			// if start is on other end of buffer, move pointer back
 8001726:	f201 33a6 	addw	r3, r1, #934	@ 0x3a6
				for (uint32_t i = 0; i < N_FFT; i++)
 800172a:	f50d 5283 	add.w	r2, sp, #4192	@ 0x1060
 800172e:	3218      	adds	r2, #24
 8001730:	f502 5157 	add.w	r1, r2, #13760	@ 0x35c0
 8001734:	f502 40e7 	add.w	r0, r2, #29568	@ 0x7380
 8001738:	f50d 4742 	add.w	r7, sp, #49664	@ 0xc200
 800173c:	3138      	adds	r1, #56	@ 0x38
 800173e:	3078      	adds	r0, #120	@ 0x78
 8001740:	3770      	adds	r7, #112	@ 0x70
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 8001742:	f641 1e3e 	movw	lr, #6462	@ 0x193e
 8001746:	f642 0cbe 	movw	ip, #10430	@ 0x28be
 800174a:	f50d 5983 	add.w	r9, sp, #4192	@ 0x1060
 800174e:	f603 12be 	addw	r2, r3, #2494	@ 0x9be
 8001752:	f109 0918 	add.w	r9, r9, #24
 8001756:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800175a:	f8d2 9000 	ldr.w	r9, [r2]
 800175e:	f841 9b04 	str.w	r9, [r1], #4
 8001762:	f50d 5983 	add.w	r9, sp, #4192	@ 0x1060
 8001766:	eb03 020e 	add.w	r2, r3, lr
 800176a:	f109 0918 	add.w	r9, r9, #24
 800176e:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 8001772:	f8d2 9000 	ldr.w	r9, [r2]
 8001776:	f840 9b04 	str.w	r9, [r0], #4
 800177a:	f50d 5983 	add.w	r9, sp, #4192	@ 0x1060
 800177e:	eb03 020c 	add.w	r2, r3, ip
 8001782:	f109 0918 	add.w	r9, r9, #24
 8001786:	eb09 0282 	add.w	r2, r9, r2, lsl #2
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 800178a:	3301      	adds	r3, #1
						mics[j].fft_window[i] = mics[j].buffer[curr_sample];	// copy buffer sample to FFT window
 800178c:	6812      	ldr	r2, [r2, #0]
 800178e:	f847 2b04 	str.w	r2, [r7], #4
					if (++curr_sample == N_BUFFER)								// wrap pointer back to front on overflow
 8001792:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
 8001796:	d002      	beq.n	800179e <main+0x5ce>
				for (uint32_t i = 0; i < N_FFT; i++)
 8001798:	42b1      	cmp	r1, r6
 800179a:	d1d6      	bne.n	800174a <main+0x57a>
 800179c:	e677      	b.n	800148e <main+0x2be>
 800179e:	42b1      	cmp	r1, r6
 80017a0:	f43f ae75 	beq.w	800148e <main+0x2be>
						curr_sample = 0;
 80017a4:	2300      	movs	r3, #0
 80017a6:	e7d0      	b.n	800174a <main+0x57a>
	if (src[0] <= src[1] && src[0] <= src[2])
 80017a8:	428a      	cmp	r2, r1
 80017aa:	dca9      	bgt.n	8001700 <main+0x530>
		if (src[1] <= src[2])
 80017ac:	428b      	cmp	r3, r1
 80017ae:	4608      	mov	r0, r1
		dst[0] = src[0];
 80017b0:	4611      	mov	r1, r2
		if (src[1] <= src[2])
 80017b2:	dca4      	bgt.n	80016fe <main+0x52e>
			dst[1] = src[0];
			dst[2] = src[1];
		}
		else
		{
			dst[1] = src[1];
 80017b4:	461a      	mov	r2, r3
			dst[2] = src[0];
 80017b6:	4603      	mov	r3, r0
 80017b8:	e7a2      	b.n	8001700 <main+0x530>
	else if (src[1] <= src[0] && src[1] <= src[2])
 80017ba:	4610      	mov	r0, r2
 80017bc:	e7fa      	b.n	80017b4 <main+0x5e4>
			dst[2] = src[2];
 80017be:	4603      	mov	r3, r0
 80017c0:	e79e      	b.n	8001700 <main+0x530>
				if (thresh_ind_sorted[i] != -1)
 80017c2:	4613      	mov	r3, r2
 80017c4:	e608      	b.n	80013d8 <main+0x208>
				uart2_dma1_write(8, coords.ser);
 80017c6:	a90a      	add	r1, sp, #40	@ 0x28
 80017c8:	2008      	movs	r0, #8
 80017ca:	f001 f941 	bl	8002a50 <uart2_dma1_write>
 80017ce:	e769      	b.n	80016a4 <main+0x4d4>
 80017d0:	bf800000 	.word	0xbf800000
 80017d4:	3f19999a 	.word	0x3f19999a

080017d8 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80017d8:	e7fe      	b.n	80017d8 <NMI_Handler>
 80017da:	bf00      	nop

080017dc <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80017dc:	e7fe      	b.n	80017dc <HardFault_Handler>
 80017de:	bf00      	nop

080017e0 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80017e0:	e7fe      	b.n	80017e0 <MemManage_Handler>
 80017e2:	bf00      	nop

080017e4 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80017e4:	e7fe      	b.n	80017e4 <BusFault_Handler>
 80017e6:	bf00      	nop

080017e8 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80017e8:	e7fe      	b.n	80017e8 <UsageFault_Handler>
 80017ea:	bf00      	nop

080017ec <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80017ec:	4770      	bx	lr
 80017ee:	bf00      	nop

080017f0 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 80017f0:	4770      	bx	lr
 80017f2:	bf00      	nop

080017f4 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 80017f4:	4770      	bx	lr
 80017f6:	bf00      	nop

080017f8 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80017f8:	f000 bfec 	b.w	80027d4 <HAL_IncTick>

080017fc <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80017fc:	4a03      	ldr	r2, [pc, #12]	@ (800180c <SystemInit+0x10>)
 80017fe:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8001802:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001806:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800180a:	4770      	bx	lr
 800180c:	e000ed00 	.word	0xe000ed00

08001810 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001810:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001848 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit  
 8001814:	f7ff fff2 	bl	80017fc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001818:	480c      	ldr	r0, [pc, #48]	@ (800184c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800181a:	490d      	ldr	r1, [pc, #52]	@ (8001850 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800181c:	4a0d      	ldr	r2, [pc, #52]	@ (8001854 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800181e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001820:	e002      	b.n	8001828 <LoopCopyDataInit>

08001822 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001822:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001824:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001826:	3304      	adds	r3, #4

08001828 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001828:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800182a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800182c:	d3f9      	bcc.n	8001822 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800182e:	4a0a      	ldr	r2, [pc, #40]	@ (8001858 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001830:	4c0a      	ldr	r4, [pc, #40]	@ (800185c <LoopFillZerobss+0x22>)
  movs r3, #0
 8001832:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001834:	e001      	b.n	800183a <LoopFillZerobss>

08001836 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001836:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001838:	3204      	adds	r2, #4

0800183a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800183a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800183c:	d3fb      	bcc.n	8001836 <FillZerobss>
 
/* Call static constructors */
    bl __libc_init_array
 800183e:	f001 f94d 	bl	8002adc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001842:	f7ff fcc5 	bl	80011d0 <main>
  bx  lr    
 8001846:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001848:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 800184c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001850:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 8001854:	0800365c 	.word	0x0800365c
  ldr r2, =_sbss
 8001858:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 800185c:	200016ac 	.word	0x200016ac

08001860 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001860:	e7fe      	b.n	8001860 <ADC_IRQHandler>
	...

08001864 <arm_fir_f32>:
ARM_DSP_ATTRIBUTE void arm_fir_f32(
  const arm_fir_instance_f32 * S,
  const float32_t * pSrc,
        float32_t * pDst,
        uint32_t blockSize)
{
 8001864:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001868:	4690      	mov	r8, r2
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
        float32_t *pStateCurnt;                        /* Points to the current sample of the state */
        float32_t *px;                                 /* Temporary pointer for state buffer */
  const float32_t *pb;                                 /* Temporary pointer for coefficient buffer */
        float32_t acc0;                                /* Accumulator */
        uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
 800186a:	8802      	ldrh	r2, [r0, #0]
        float32_t *pState = S->pState;                 /* State pointer */
 800186c:	6846      	ldr	r6, [r0, #4]
  const float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
 800186e:	f8d0 9008 	ldr.w	r9, [r0, #8]
        float32_t c0;                                           /* Temporary variable to hold coefficient value */
#endif

  /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
  /* pStateCurnt points to the location where the new input data should be written */
  pStateCurnt = &(S->pState[(numTaps - 1U)]);
 8001872:	f102 4080 	add.w	r0, r2, #1073741824	@ 0x40000000
 8001876:	3801      	subs	r0, #1
 8001878:	eb06 0580 	add.w	r5, r6, r0, lsl #2
  /* Initialize blkCnt with number of taps */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 800187c:	b33b      	cbz	r3, 80018ce <arm_fir_f32+0x6a>
 800187e:	460f      	mov	r7, r1
 8001880:	461c      	mov	r4, r3
  blkCnt = blockSize;
 8001882:	4619      	mov	r1, r3
        float32_t *pState = S->pState;                 /* State pointer */
 8001884:	4633      	mov	r3, r6
  {
    /* Copy one sample at a time into state buffer */
    *pStateCurnt++ = *pSrc++;
 8001886:	f857 0b04 	ldr.w	r0, [r7], #4
 800188a:	f845 0b04 	str.w	r0, [r5], #4

    /* Set the accumulator to zero */
    acc0 = 0.0f;
 800188e:	eddf 7a11 	vldr	s15, [pc, #68]	@ 80018d4 <arm_fir_f32+0x70>
    pb = pCoeffs;

    i = numTaps;

    /* Perform the multiply-accumulates */
    while (i > 0U)
 8001892:	b152      	cbz	r2, 80018aa <arm_fir_f32+0x46>
    i = numTaps;
 8001894:	4610      	mov	r0, r2
    pb = pCoeffs;
 8001896:	46ce      	mov	lr, r9
    px = pState;
 8001898:	469c      	mov	ip, r3
    {
      /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
      acc0 += *px++ * *pb++;
 800189a:	ecfc 6a01 	vldmia	ip!, {s13}
 800189e:	ecbe 7a01 	vldmia	lr!, {s14}
    while (i > 0U)
 80018a2:	3801      	subs	r0, #1
      acc0 += *px++ * *pb++;
 80018a4:	eee6 7a87 	vfma.f32	s15, s13, s14
    while (i > 0U)
 80018a8:	d1f7      	bne.n	800189a <arm_fir_f32+0x36>
  while (blkCnt > 0U)
 80018aa:	3901      	subs	r1, #1

      i--;
    }

    /* Store result in destination buffer. */
    *pDst++ = acc0;
 80018ac:	ece8 7a01 	vstmia	r8!, {s15}

    /* Advance state pointer by 1 for the next sample */
    pState = pState + 1U;
 80018b0:	f103 0304 	add.w	r3, r3, #4
  while (blkCnt > 0U)
 80018b4:	d1e7      	bne.n	8001886 <arm_fir_f32+0x22>
 80018b6:	eb06 0184 	add.w	r1, r6, r4, lsl #2
  tapCnt = (numTaps - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  /* Copy remaining data */
  while (tapCnt > 0U)
 80018ba:	1e53      	subs	r3, r2, #1
 80018bc:	d005      	beq.n	80018ca <arm_fir_f32+0x66>
  {
    *pStateCurnt++ = *pState++;
 80018be:	f851 2b04 	ldr.w	r2, [r1], #4
 80018c2:	f846 2b04 	str.w	r2, [r6], #4
  while (tapCnt > 0U)
 80018c6:	3b01      	subs	r3, #1
 80018c8:	d1f9      	bne.n	80018be <arm_fir_f32+0x5a>

    /* Decrement loop counter */
    tapCnt--;
  }

}
 80018ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        float32_t *pState = S->pState;                 /* State pointer */
 80018ce:	4631      	mov	r1, r6
 80018d0:	e7f3      	b.n	80018ba <arm_fir_f32+0x56>
 80018d2:	bf00      	nop
 80018d4:	00000000 	.word	0x00000000

080018d8 <arm_fir_init_f32>:
        arm_fir_instance_f32 * S,
        uint16_t numTaps,
  const float32_t * pCoeffs,
        float32_t * pState,
        uint32_t blockSize)
{
 80018d8:	b510      	push	{r4, lr}
 80018da:	4604      	mov	r4, r0

  /* Clear state buffer. The size is always (blockSize + numTaps - 1) */
#if defined(ARM_MATH_MVEF) && !defined(ARM_MATH_AUTOVECTORIZE)
  memset(pState, 0, (numTaps + (blockSize - 1U) + blockSize) * sizeof(float32_t));
#else
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80018dc:	9802      	ldr	r0, [sp, #8]
  S->numTaps = numTaps;
 80018de:	8021      	strh	r1, [r4, #0]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80018e0:	f100 3cff 	add.w	ip, r0, #4294967295
 80018e4:	448c      	add	ip, r1
  S->pCoeffs = pCoeffs;
 80018e6:	60a2      	str	r2, [r4, #8]
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));
 80018e8:	2100      	movs	r1, #0
 80018ea:	ea4f 028c 	mov.w	r2, ip, lsl #2
 80018ee:	4618      	mov	r0, r3
 80018f0:	f001 f8ec 	bl	8002acc <memset>
#endif
  /* Assign state pointer */
  S->pState = pState;
 80018f4:	6060      	str	r0, [r4, #4]
}
 80018f6:	bd10      	pop	{r4, pc}

080018f8 <arm_max_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = (blockSize - 1U);

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 80018f8:	2901      	cmp	r1, #1
{
 80018fa:	b410      	push	{r4}
  out = *pSrc++;
 80018fc:	ecf0 7a01 	vldmia	r0!, {s15}
  while (blkCnt > 0U)
 8001900:	d017      	beq.n	8001932 <arm_max_f32+0x3a>
 8001902:	f04f 0c01 	mov.w	ip, #1
  outIndex = 0U;
 8001906:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal = *pSrc++;
 8001908:	ecb0 7a01 	vldmia	r0!, {s14}

    /* compare for the maximum value */
    if (out < maxVal)
    {
      /* Update the maximum value and it's index */
      out = maxVal;
 800190c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001910:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001914:	bf48      	it	mi
 8001916:	4664      	movmi	r4, ip
  while (blkCnt > 0U)
 8001918:	f10c 0c01 	add.w	ip, ip, #1
      out = maxVal;
 800191c:	bf48      	it	mi
 800191e:	eef0 7a47 	vmovmi.f32	s15, s14
  while (blkCnt > 0U)
 8001922:	4561      	cmp	r1, ip
 8001924:	d1f0      	bne.n	8001908 <arm_max_f32+0x10>
    /* Decrement loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 8001926:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 800192a:	601c      	str	r4, [r3, #0]
}
 800192c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001930:	4770      	bx	lr
  outIndex = 0U;
 8001932:	2400      	movs	r4, #0
  *pResult = out;
 8001934:	edc2 7a00 	vstr	s15, [r2]
  *pIndex = outIndex;
 8001938:	601c      	str	r4, [r3, #0]
}
 800193a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800193e:	4770      	bx	lr

08001940 <arm_copy_f32>:
  /* Initialize blkCnt with number of samples */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_LOOPUNROLL) */

  while (blkCnt > 0U)
 8001940:	b12a      	cbz	r2, 800194e <arm_copy_f32+0xe>
  {
    /* C = A */

    /* Copy and store result in destination buffer */
    *pDst++ = *pSrc++;
 8001942:	f850 3b04 	ldr.w	r3, [r0], #4
 8001946:	f841 3b04 	str.w	r3, [r1], #4
  while (blkCnt > 0U)
 800194a:	3a01      	subs	r2, #1
 800194c:	d1f9      	bne.n	8001942 <arm_copy_f32+0x2>

    /* Decrement loop counter */
    blkCnt--;
  }
}
 800194e:	4770      	bx	lr

08001950 <arm_bitreversal_32>:
  const uint16_t bitRevLen,
  const uint16_t *pBitRevTab)
{
  uint32_t a, b, i, tmp;

  for (i = 0; i < bitRevLen; )
 8001950:	b331      	cbz	r1, 80019a0 <arm_bitreversal_32+0x50>
{
 8001952:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  for (i = 0; i < bitRevLen; )
 8001956:	f04f 0e00 	mov.w	lr, #0
 800195a:	f102 0802 	add.w	r8, r2, #2
  {
     a = pBitRevTab[i    ] >> 2;
 800195e:	f832 c01e 	ldrh.w	ip, [r2, lr, lsl #1]
     b = pBitRevTab[i + 1] >> 2;
 8001962:	f838 301e 	ldrh.w	r3, [r8, lr, lsl #1]
     a = pBitRevTab[i    ] >> 2;
 8001966:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
     b = pBitRevTab[i + 1] >> 2;
 800196a:	089b      	lsrs	r3, r3, #2

     //real
     tmp = pSrc[a];
 800196c:	f850 702c 	ldr.w	r7, [r0, ip, lsl #2]
     pSrc[a] = pSrc[b];
 8001970:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]
 8001974:	f840 602c 	str.w	r6, [r0, ip, lsl #2]
     tmp = pSrc[a];
 8001978:	ea4f 058c 	mov.w	r5, ip, lsl #2
     pSrc[a] = pSrc[b];
 800197c:	009c      	lsls	r4, r3, #2
     pSrc[b] = tmp;
 800197e:	f840 7023 	str.w	r7, [r0, r3, lsl #2]

     //complex
     tmp = pSrc[a+1];
 8001982:	f105 0c04 	add.w	ip, r5, #4
     pSrc[a+1] = pSrc[b+1];
 8001986:	1d23      	adds	r3, r4, #4
     pSrc[b+1] = tmp;

    i += 2;
 8001988:	f10e 0e02 	add.w	lr, lr, #2
     tmp = pSrc[a+1];
 800198c:	f850 500c 	ldr.w	r5, [r0, ip]
     pSrc[a+1] = pSrc[b+1];
 8001990:	58c4      	ldr	r4, [r0, r3]
 8001992:	f840 400c 	str.w	r4, [r0, ip]
  for (i = 0; i < bitRevLen; )
 8001996:	458e      	cmp	lr, r1
     pSrc[b+1] = tmp;
 8001998:	50c5      	str	r5, [r0, r3]
  for (i = 0; i < bitRevLen; )
 800199a:	d3e0      	bcc.n	800195e <arm_bitreversal_32+0xe>
  }
}
 800199c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80019a0:	4770      	bx	lr
 80019a2:	bf00      	nop

080019a4 <arm_cfft_f32>:
ARM_DSP_ATTRIBUTE void arm_cfft_f32(
  const arm_cfft_instance_f32 * S,
        float32_t * p1,
        uint8_t ifftFlag,
        uint8_t bitReverseFlag)
{
 80019a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019a8:	ed2d 8b0a 	vpush	{d8-d12}
 80019ac:	b08f      	sub	sp, #60	@ 0x3c
  uint32_t  L = S->fftLen, l;
  float32_t invL, * pSrc;

  if (ifftFlag == 1U)
 80019ae:	2a01      	cmp	r2, #1
  uint32_t  L = S->fftLen, l;
 80019b0:	8805      	ldrh	r5, [r0, #0]
{
 80019b2:	9202      	str	r2, [sp, #8]
 80019b4:	4683      	mov	fp, r0
 80019b6:	460c      	mov	r4, r1
 80019b8:	9301      	str	r3, [sp, #4]
  if (ifftFlag == 1U)
 80019ba:	f000 8138 	beq.w	8001c2e <arm_cfft_f32+0x28a>
      *pSrc = -*pSrc;
      pSrc += 2;
    }
  }

  switch (L)
 80019be:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 80019c2:	f000 8146 	beq.w	8001c52 <arm_cfft_f32+0x2ae>
 80019c6:	d835      	bhi.n	8001a34 <arm_cfft_f32+0x90>
 80019c8:	2d40      	cmp	r5, #64	@ 0x40
 80019ca:	f000 8124 	beq.w	8001c16 <arm_cfft_f32+0x272>
 80019ce:	d84a      	bhi.n	8001a66 <arm_cfft_f32+0xc2>
 80019d0:	2d10      	cmp	r5, #16
 80019d2:	d04a      	beq.n	8001a6a <arm_cfft_f32+0xc6>
 80019d4:	2d20      	cmp	r5, #32
 80019d6:	f000 813c 	beq.w	8001c52 <arm_cfft_f32+0x2ae>
  case 4096:
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
    break;
  }

  if ( bitReverseFlag )
 80019da:	9b01      	ldr	r3, [sp, #4]
 80019dc:	b133      	cbz	r3, 80019ec <arm_cfft_f32+0x48>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 80019de:	f8db 2008 	ldr.w	r2, [fp, #8]
 80019e2:	f8bb 100c 	ldrh.w	r1, [fp, #12]
 80019e6:	4620      	mov	r0, r4
 80019e8:	f7ff ffb2 	bl	8001950 <arm_bitreversal_32>

  if (ifftFlag == 1U)
 80019ec:	9b02      	ldr	r3, [sp, #8]
 80019ee:	2b01      	cmp	r3, #1
 80019f0:	d134      	bne.n	8001a5c <arm_cfft_f32+0xb8>
  {
    invL = 1.0f / (float32_t)L;
 80019f2:	ee07 5a90 	vmov	s15, r5
 80019f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80019fa:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80019fe:	eec7 6a27 	vdiv.f32	s13, s14, s15

    /* Conjugate and scale output data */
    pSrc = p1;
    for (l= 0; l < L; l++)
 8001a02:	b35d      	cbz	r5, 8001a5c <arm_cfft_f32+0xb8>
 8001a04:	3408      	adds	r4, #8
 8001a06:	2300      	movs	r3, #0
 8001a08:	3301      	adds	r3, #1
 8001a0a:	429d      	cmp	r5, r3
 8001a0c:	f104 0408 	add.w	r4, r4, #8
    {
      *pSrc++ *=   invL ;
 8001a10:	ed14 7a04 	vldr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 8001a14:	ed54 7a03 	vldr	s15, [r4, #-12]
      *pSrc++ *=   invL ;
 8001a18:	ee27 7a26 	vmul.f32	s14, s14, s13
      *pSrc    = -(*pSrc) * invL;
 8001a1c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
      *pSrc++ *=   invL ;
 8001a20:	ed04 7a04 	vstr	s14, [r4, #-16]
      *pSrc    = -(*pSrc) * invL;
 8001a24:	ed44 7a03 	vstr	s15, [r4, #-12]
    for (l= 0; l < L; l++)
 8001a28:	d1ee      	bne.n	8001a08 <arm_cfft_f32+0x64>
      pSrc++;
    }
  }
}
 8001a2a:	b00f      	add	sp, #60	@ 0x3c
 8001a2c:	ecbd 8b0a 	vpop	{d8-d12}
 8001a30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 8001a34:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
 8001a38:	f000 810b 	beq.w	8001c52 <arm_cfft_f32+0x2ae>
 8001a3c:	f200 80e7 	bhi.w	8001c0e <arm_cfft_f32+0x26a>
 8001a40:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
 8001a44:	f000 80e7 	beq.w	8001c16 <arm_cfft_f32+0x272>
 8001a48:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
 8001a4c:	d00d      	beq.n	8001a6a <arm_cfft_f32+0xc6>
  if ( bitReverseFlag )
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	2b00      	cmp	r3, #0
 8001a52:	d1c4      	bne.n	80019de <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 8001a54:	9b02      	ldr	r3, [sp, #8]
 8001a56:	2b01      	cmp	r3, #1
 8001a58:	f000 80d0 	beq.w	8001bfc <arm_cfft_f32+0x258>
}
 8001a5c:	b00f      	add	sp, #60	@ 0x3c
 8001a5e:	ecbd 8b0a 	vpop	{d8-d12}
 8001a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch (L)
 8001a66:	2d80      	cmp	r5, #128	@ 0x80
 8001a68:	d1f1      	bne.n	8001a4e <arm_cfft_f32+0xaa>
  L >>= 1;
 8001a6a:	0869      	lsrs	r1, r5, #1
  const float32_t * tw = (float32_t *) S->pTwiddle;
 8001a6c:	f8db 2004 	ldr.w	r2, [fp, #4]
  pMid1 = p1 + L;
 8001a70:	0088      	lsls	r0, r1, #2
 8001a72:	3010      	adds	r0, #16
  float32_t * p2 = p1 + L;
 8001a74:	eb04 0685 	add.w	r6, r4, r5, lsl #2
  for (l = L >> 2; l > 0; l-- )
 8001a78:	f104 0310 	add.w	r3, r4, #16
 8001a7c:	ea4f 0ed5 	mov.w	lr, r5, lsr #3
 8001a80:	eb04 0c00 	add.w	ip, r4, r0
 8001a84:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 8001a88:	4430      	add	r0, r6
 8001a8a:	f102 0810 	add.w	r8, r2, #16
 8001a8e:	f106 0710 	add.w	r7, r6, #16
    t2[0] = p2[0];
 8001a92:	ed17 1a04 	vldr	s2, [r7, #-16]
    t2[1] = p2[1];
 8001a96:	ed57 1a03 	vldr	s3, [r7, #-12]
    t4[0] = pMid2[0];
 8001a9a:	ed10 5a04 	vldr	s10, [r0, #-16]
    t4[1] = pMid2[1];
 8001a9e:	ed50 5a03 	vldr	s11, [r0, #-12]
    t2[2] = p2[2];
 8001aa2:	ed57 8a02 	vldr	s17, [r7, #-8]
    t2[3] = p2[3];
 8001aa6:	ed17 8a01 	vldr	s16, [r7, #-4]
    t4[2] = pMid2[2];
 8001aaa:	ed10 7a02 	vldr	s14, [r0, #-8]
    t4[3] = pMid2[3];
 8001aae:	ed50 7a01 	vldr	s15, [r0, #-4]
    t1[0] = p1[0];
 8001ab2:	ed13 4a04 	vldr	s8, [r3, #-16]
    t1[1] = p1[1];
 8001ab6:	ed53 4a03 	vldr	s9, [r3, #-12]
    t1[2] = p1[2];
 8001aba:	ed13 6a02 	vldr	s12, [r3, #-8]
    t1[3] = p1[3];
 8001abe:	ed53 6a01 	vldr	s13, [r3, #-4]
    t3[0] = pMid1[0];
 8001ac2:	ed1c 2a04 	vldr	s4, [ip, #-16]
    t3[1] = pMid1[1];
 8001ac6:	ed5c 2a03 	vldr	s5, [ip, #-12]
    t3[2] = pMid1[2];
 8001aca:	ed1c 0a02 	vldr	s0, [ip, #-8]
    t3[3] = pMid1[3];
 8001ace:	ed5c 0a01 	vldr	s1, [ip, #-4]
    *p1++ = t1[0] + t2[0];
 8001ad2:	ee74 ba01 	vadd.f32	s23, s8, s2
    *p1++ = t1[1] + t2[1];
 8001ad6:	ee34 baa1 	vadd.f32	s22, s9, s3
    *pMid1++ = t3[0] + t4[0];
 8001ada:	ee72 9a05 	vadd.f32	s19, s4, s10
    *pMid1++ = t3[1] + t4[1];
 8001ade:	ee32 9aa5 	vadd.f32	s18, s5, s11
    *pMid1++ = t3[2] + t4[2];
 8001ae2:	ee30 3a07 	vadd.f32	s6, s0, s14
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 8001ae6:	ee70 3aa7 	vadd.f32	s7, s1, s15
    *p1++ = t1[2] + t2[2];
 8001aea:	ee76 aa28 	vadd.f32	s21, s12, s17
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001aee:	ee36 aa88 	vadd.f32	s20, s13, s16
    *p1++ = t1[0] + t2[0];
 8001af2:	ed43 ba04 	vstr	s23, [r3, #-16]
    *p1++ = t1[1] + t2[1];
 8001af6:	ed03 ba03 	vstr	s22, [r3, #-12]
    *p1++ = t1[2] + t2[2];
 8001afa:	ed43 aa02 	vstr	s21, [r3, #-8]
    *p1++ = t1[3] + t2[3];    /* col 1 */
 8001afe:	ed03 aa01 	vstr	s20, [r3, #-4]
    *pMid1++ = t3[0] + t4[0];
 8001b02:	ed4c 9a04 	vstr	s19, [ip, #-16]
    *pMid1++ = t3[1] + t4[1];
 8001b06:	ed0c 9a03 	vstr	s18, [ip, #-12]
    *pMid1++ = t3[2] + t4[2];
 8001b0a:	ed0c 3a02 	vstr	s6, [ip, #-8]
    *pMid1++ = t3[3] + t4[3]; /* col 1 */
 8001b0e:	ed4c 3a01 	vstr	s7, [ip, #-4]
    twI = *tw++;
 8001b12:	ed58 3a03 	vldr	s7, [r8, #-12]
    twR = *tw++;
 8001b16:	ed18 3a04 	vldr	s6, [r8, #-16]
    t2[0] = t1[0] - t2[0];
 8001b1a:	ee34 4a41 	vsub.f32	s8, s8, s2
    t2[1] = t1[1] - t2[1];
 8001b1e:	ee74 4ae1 	vsub.f32	s9, s9, s3
    t4[1] = t4[1] - t3[1];
 8001b22:	ee75 5ae2 	vsub.f32	s11, s11, s5
    t4[0] = t4[0] - t3[0];
 8001b26:	ee35 5a42 	vsub.f32	s10, s10, s4
    m1 = t2[1] * twI;
 8001b2a:	ee24 1aa3 	vmul.f32	s2, s9, s7
    *p2++ = m2 - m3;
 8001b2e:	ee63 1ac4 	vnmul.f32	s3, s7, s8
    *pMid2++ = m0 - m1;
 8001b32:	ee23 2a65 	vnmul.f32	s4, s6, s11
    *p2++ = m0 + m1;
 8001b36:	eea4 1a03 	vfma.f32	s2, s8, s6
  for (l = L >> 2; l > 0; l-- )
 8001b3a:	3310      	adds	r3, #16
 8001b3c:	459e      	cmp	lr, r3
    m3 = t4[0] * twR;
 8001b3e:	ee65 2a03 	vmul.f32	s5, s10, s6
    *p2++ = m2 - m3;
 8001b42:	eeb0 4a61 	vmov.f32	s8, s3
 8001b46:	eea4 4a83 	vfma.f32	s8, s9, s6
  for (l = L >> 2; l > 0; l-- )
 8001b4a:	f10c 0c10 	add.w	ip, ip, #16
 8001b4e:	f108 0810 	add.w	r8, r8, #16
    *pMid2++ = m0 - m1;
 8001b52:	eef0 4a42 	vmov.f32	s9, s4
 8001b56:	eee5 4a23 	vfma.f32	s9, s10, s7
  for (l = L >> 2; l > 0; l-- )
 8001b5a:	f107 0710 	add.w	r7, r7, #16
 8001b5e:	f100 0010 	add.w	r0, r0, #16
    *pMid2++ = m2 + m3;
 8001b62:	eeb0 5a62 	vmov.f32	s10, s5
 8001b66:	eea5 5aa3 	vfma.f32	s10, s11, s7
    *p2++ = m2 - m3;
 8001b6a:	ed07 4a07 	vstr	s8, [r7, #-28]	@ 0xffffffe4
    *p2++ = m0 + m1;
 8001b6e:	ed07 1a08 	vstr	s2, [r7, #-32]	@ 0xffffffe0
    *pMid2++ = m0 - m1;
 8001b72:	ed40 4a08 	vstr	s9, [r0, #-32]	@ 0xffffffe0
    *pMid2++ = m2 + m3;
 8001b76:	ed00 5a07 	vstr	s10, [r0, #-28]	@ 0xffffffe4
    twI = *tw++;
 8001b7a:	ed58 5a05 	vldr	s11, [r8, #-20]	@ 0xffffffec
    twR = *tw++;
 8001b7e:	ed18 5a06 	vldr	s10, [r8, #-24]	@ 0xffffffe8
    t2[2] = t1[2] - t2[2];
 8001b82:	ee36 6a68 	vsub.f32	s12, s12, s17
    t2[3] = t1[3] - t2[3];    /* for col 2 */
 8001b86:	ee76 6ac8 	vsub.f32	s13, s13, s16
    t4[3] = t4[3] - t3[3];    /* for col 2 */
 8001b8a:	ee77 7ae0 	vsub.f32	s15, s15, s1
    t4[2] = t4[2] - t3[2];
 8001b8e:	ee37 7a40 	vsub.f32	s14, s14, s0
    m1 = t2[3] * twI;
 8001b92:	ee26 3aa5 	vmul.f32	s6, s13, s11
    *p2++ = m2 - m3;
 8001b96:	ee65 3ac6 	vnmul.f32	s7, s11, s12
    *pMid2++ = m0 - m1;
 8001b9a:	ee25 4a67 	vnmul.f32	s8, s10, s15
    *p2++ = m0 + m1;
 8001b9e:	eea6 3a05 	vfma.f32	s6, s12, s10
    m3 = t4[2] * twR;
 8001ba2:	ee67 4a05 	vmul.f32	s9, s14, s10
    *p2++ = m2 - m3;
 8001ba6:	eeb0 6a63 	vmov.f32	s12, s7
 8001baa:	eea6 6a85 	vfma.f32	s12, s13, s10
    *pMid2++ = m0 - m1;
 8001bae:	eef0 6a44 	vmov.f32	s13, s8
 8001bb2:	eee7 6a25 	vfma.f32	s13, s14, s11
    *pMid2++ = m2 + m3;
 8001bb6:	eeb0 7a64 	vmov.f32	s14, s9
 8001bba:	eea7 7aa5 	vfma.f32	s14, s15, s11
    *p2++ = m0 + m1;
 8001bbe:	ed07 3a06 	vstr	s6, [r7, #-24]	@ 0xffffffe8
    *p2++ = m2 - m3;
 8001bc2:	ed07 6a05 	vstr	s12, [r7, #-20]	@ 0xffffffec
    *pMid2++ = m0 - m1;
 8001bc6:	ed40 6a06 	vstr	s13, [r0, #-24]	@ 0xffffffe8
    *pMid2++ = m2 + m3;
 8001bca:	ed00 7a05 	vstr	s14, [r0, #-20]	@ 0xffffffec
  for (l = L >> 2; l > 0; l-- )
 8001bce:	f47f af60 	bne.w	8001a92 <arm_cfft_f32+0xee>
  arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 2U);
 8001bd2:	b28f      	uxth	r7, r1
 8001bd4:	2302      	movs	r3, #2
 8001bd6:	4639      	mov	r1, r7
 8001bd8:	4620      	mov	r0, r4
 8001bda:	f000 fa79 	bl	80020d0 <arm_radix8_butterfly_f32>
  arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 2U);
 8001bde:	2302      	movs	r3, #2
 8001be0:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001be4:	4639      	mov	r1, r7
 8001be6:	4630      	mov	r0, r6
 8001be8:	f000 fa72 	bl	80020d0 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001bec:	9b01      	ldr	r3, [sp, #4]
 8001bee:	2b00      	cmp	r3, #0
 8001bf0:	f47f aef5 	bne.w	80019de <arm_cfft_f32+0x3a>
  if (ifftFlag == 1U)
 8001bf4:	9b02      	ldr	r3, [sp, #8]
 8001bf6:	2b01      	cmp	r3, #1
 8001bf8:	f47f af30 	bne.w	8001a5c <arm_cfft_f32+0xb8>
    invL = 1.0f / (float32_t)L;
 8001bfc:	ee07 5a90 	vmov	s15, r5
 8001c00:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8001c04:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8001c08:	eec7 6a27 	vdiv.f32	s13, s14, s15
    for (l= 0; l < L; l++)
 8001c0c:	e6fa      	b.n	8001a04 <arm_cfft_f32+0x60>
  switch (L)
 8001c0e:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 8001c12:	f47f af1c 	bne.w	8001a4e <arm_cfft_f32+0xaa>
    arm_radix8_butterfly_f32 ( p1, L, (float32_t *) S->pTwiddle, 1);
 8001c16:	2301      	movs	r3, #1
 8001c18:	f8db 2004 	ldr.w	r2, [fp, #4]
 8001c1c:	4629      	mov	r1, r5
 8001c1e:	4620      	mov	r0, r4
 8001c20:	f000 fa56 	bl	80020d0 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8001c24:	9b01      	ldr	r3, [sp, #4]
 8001c26:	2b00      	cmp	r3, #0
 8001c28:	f43f af14 	beq.w	8001a54 <arm_cfft_f32+0xb0>
 8001c2c:	e6d7      	b.n	80019de <arm_cfft_f32+0x3a>
    for (l = 0; l < L; l++)
 8001c2e:	2d00      	cmp	r5, #0
 8001c30:	f000 8233 	beq.w	800209a <arm_cfft_f32+0x6f6>
 8001c34:	f101 030c 	add.w	r3, r1, #12
 8001c38:	2200      	movs	r2, #0
      *pSrc = -*pSrc;
 8001c3a:	ed53 7a02 	vldr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001c3e:	3201      	adds	r2, #1
      *pSrc = -*pSrc;
 8001c40:	eef1 7a67 	vneg.f32	s15, s15
    for (l = 0; l < L; l++)
 8001c44:	4295      	cmp	r5, r2
      *pSrc = -*pSrc;
 8001c46:	ed43 7a02 	vstr	s15, [r3, #-8]
    for (l = 0; l < L; l++)
 8001c4a:	f103 0308 	add.w	r3, r3, #8
 8001c4e:	d1f4      	bne.n	8001c3a <arm_cfft_f32+0x296>
 8001c50:	e6b5      	b.n	80019be <arm_cfft_f32+0x1a>
    uint32_t    L  = S->fftLen >> 1;
 8001c52:	086b      	lsrs	r3, r5, #1
    float32_t * p3 = p2 + L;
 8001c54:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    p1ap3_0 = p1[0] + p3[0];
 8001c58:	ed91 6a00 	vldr	s12, [r1]
    p1ap3_1 = p1[1] + p3[1];
 8001c5c:	edd1 5a01 	vldr	s11, [r1, #4]
    p1ap3_0 = p1[0] + p3[0];
 8001c60:	ed94 7a00 	vldr	s14, [r4]
    p1ap3_1 = p1[1] + p3[1];
 8001c64:	edd4 7a01 	vldr	s15, [r4, #4]
    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8001c68:	f8db 6004 	ldr.w	r6, [fp, #4]
 8001c6c:	9606      	str	r6, [sp, #24]
    float32_t * p4 = p3 + L;
 8001c6e:	eb01 0283 	add.w	r2, r1, r3, lsl #2
    p1ap3_0 = p1[0] + p3[0];
 8001c72:	ee77 6a06 	vadd.f32	s13, s14, s12
    p1sp3_0 = p1[0] - p3[0];
 8001c76:	ee37 7a46 	vsub.f32	s14, s14, s12
    p1ap3_1 = p1[1] + p3[1];
 8001c7a:	ee37 6aa5 	vadd.f32	s12, s15, s11
    p1sp3_1 = p1[1] - p3[1];
 8001c7e:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001c82:	edd2 5a00 	vldr	s11, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001c86:	ed92 2a01 	vldr	s4, [r2, #4]
 8001c8a:	9203      	str	r2, [sp, #12]
    float32_t * p2 = p1 + L;
 8001c8c:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001c90:	ed90 5a00 	vldr	s10, [r0]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001c94:	edd0 2a01 	vldr	s5, [r0, #4]
    float32_t * p3 = p2 + L;
 8001c98:	9105      	str	r1, [sp, #20]
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001c9a:	ee36 3aa5 	vadd.f32	s6, s13, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001c9e:	ee77 3aa5 	vadd.f32	s7, s15, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001ca2:	ee33 3a05 	vadd.f32	s6, s6, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001ca6:	ee77 4a02 	vadd.f32	s9, s14, s4
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001caa:	ed84 3a00 	vstr	s6, [r4]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001cae:	ee76 6ac5 	vsub.f32	s13, s13, s10
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001cb2:	ee77 7a85 	vadd.f32	s15, s15, s10
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001cb6:	ee73 3ac5 	vsub.f32	s7, s7, s10
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001cba:	ee34 5ae2 	vsub.f32	s10, s9, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001cbe:	edd2 4a01 	vldr	s9, [r2, #4]
    float32_t * p2 = p1 + L;
 8001cc2:	9004      	str	r0, [sp, #16]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001cc4:	ee36 4a62 	vsub.f32	s8, s12, s5
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001cc8:	ee76 6ae5 	vsub.f32	s13, s13, s11
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001ccc:	ee77 7ae5 	vsub.f32	s15, s15, s11
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001cd0:	ee37 7a22 	vadd.f32	s14, s14, s5
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001cd4:	edd0 5a01 	vldr	s11, [r0, #4]
 8001cd8:	950d      	str	r5, [sp, #52]	@ 0x34
 8001cda:	ee36 6a24 	vadd.f32	s12, s12, s9
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001cde:	ee37 7a42 	vsub.f32	s14, s14, s4
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001ce2:	ee34 4a42 	vsub.f32	s8, s8, s4
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001ce6:	ee36 6a25 	vadd.f32	s12, s12, s11
    L >>= 1;
 8001cea:	085f      	lsrs	r7, r3, #1
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001cec:	ed84 6a01 	vstr	s12, [r4, #4]
 8001cf0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *p2++ = t2[0];
 8001cf4:	ed80 7a00 	vstr	s14, [r0]
    *p2++ = t2[1];
 8001cf8:	edc0 3a01 	vstr	s7, [r0, #4]
    *p3++ = t3[0];
 8001cfc:	edc1 6a00 	vstr	s13, [r1]
    *p3++ = t3[1];
 8001d00:	ed81 4a01 	vstr	s8, [r1, #4]
    *p4++ = t4[0];
 8001d04:	ed82 5a00 	vstr	s10, [r2]
    *p4++ = t4[1];
 8001d08:	edc2 7a01 	vstr	s15, [r2, #4]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d0c:	1eba      	subs	r2, r7, #2
    L >>= 1;
 8001d0e:	9708      	str	r7, [sp, #32]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d10:	0857      	lsrs	r7, r2, #1
 8001d12:	9707      	str	r7, [sp, #28]
 8001d14:	3b0c      	subs	r3, #12
 8001d16:	930b      	str	r3, [sp, #44]	@ 0x2c
 8001d18:	f106 0820 	add.w	r8, r6, #32
    tw3 += twMod3;
 8001d1c:	f106 0310 	add.w	r3, r6, #16
 8001d20:	f106 0930 	add.w	r9, r6, #48	@ 0x30
 8001d24:	9e07      	ldr	r6, [sp, #28]
 8001d26:	9309      	str	r3, [sp, #36]	@ 0x24
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001d28:	f1a0 0c0c 	sub.w	ip, r0, #12
 8001d2c:	469a      	mov	sl, r3
 8001d2e:	0133      	lsls	r3, r6, #4
 8001d30:	460a      	mov	r2, r1
 8001d32:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
 8001d36:	930a      	str	r3, [sp, #40]	@ 0x28
 8001d38:	eb08 1306 	add.w	r3, r8, r6, lsl #4
 8001d3c:	f102 0e10 	add.w	lr, r2, #16
 8001d40:	461d      	mov	r5, r3
 8001d42:	9a03      	ldr	r2, [sp, #12]
 8001d44:	e9dd 360b 	ldrd	r3, r6, [sp, #44]	@ 0x2c
 8001d48:	f1a2 0c0c 	sub.w	ip, r2, #12
 8001d4c:	f104 0710 	add.w	r7, r4, #16
 8001d50:	3010      	adds	r0, #16
 8001d52:	390c      	subs	r1, #12
 8001d54:	3210      	adds	r2, #16
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001d56:	ed12 8a02 	vldr	s16, [r2, #-8]
 8001d5a:	ed50 2a02 	vldr	s5, [r0, #-8]
      p1ap3_0 = p1[0] + p3[0];
 8001d5e:	ed1e 6a02 	vldr	s12, [lr, #-8]
 8001d62:	ed17 3a02 	vldr	s6, [r7, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001d66:	ed12 2a01 	vldr	s4, [r2, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001d6a:	ed1e 7a01 	vldr	s14, [lr, #-4]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001d6e:	ed50 aa01 	vldr	s21, [r0, #-4]
      p1ap3_1 = p1[1] + p3[1];
 8001d72:	ed57 6a01 	vldr	s13, [r7, #-4]
      p1ap3_0 = p1[0] + p3[0];
 8001d76:	ee33 4a06 	vadd.f32	s8, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001d7a:	ee72 7a88 	vadd.f32	s15, s5, s16
      p1ap3_1 = p1[1] + p3[1];
 8001d7e:	ee76 4a87 	vadd.f32	s9, s13, s14
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001d82:	ee77 7a84 	vadd.f32	s15, s15, s8
      p1sp3_0 = p1[0] - p3[0];
 8001d86:	ee33 3a46 	vsub.f32	s6, s6, s12
      *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001d8a:	ed47 7a02 	vstr	s15, [r7, #-8]
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001d8e:	ed52 5a01 	vldr	s11, [r2, #-4]
 8001d92:	ed50 7a01 	vldr	s15, [r0, #-4]
 8001d96:	ee77 7aa5 	vadd.f32	s15, s15, s11
      p1sp3_1 = p1[1] - p3[1];
 8001d9a:	ee76 6ac7 	vsub.f32	s13, s13, s14
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001d9e:	ee77 7aa4 	vadd.f32	s15, s15, s9
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001da2:	ee73 9a42 	vsub.f32	s19, s6, s4
      *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001da6:	ed47 7a01 	vstr	s15, [r7, #-4]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001daa:	edd3 ba02 	vldr	s23, [r3, #8]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001dae:	ed9c 6a02 	vldr	s12, [ip, #8]
 8001db2:	edd6 1a02 	vldr	s3, [r6, #8]
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001db6:	edd1 5a02 	vldr	s11, [r1, #8]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001dba:	ed93 ba01 	vldr	s22, [r3, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001dbe:	ed9c 1a01 	vldr	s2, [ip, #4]
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001dc2:	ed91 0a01 	vldr	s0, [r1, #4]
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001dc6:	ed96 aa01 	vldr	s20, [r6, #4]
      p1ap3_0 = pEnd1[ 0] + pEnd3[0];
 8001dca:	ee31 ca86 	vadd.f32	s24, s3, s12
 8001dce:	ee75 0aab 	vadd.f32	s1, s11, s23
      p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8001dd2:	ee3a 5a01 	vadd.f32	s10, s20, s2
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001dd6:	ee70 7a8c 	vadd.f32	s15, s1, s24
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001dda:	ee36 9ae2 	vsub.f32	s18, s13, s5
      *pEnd1-- = p1ap3_0 + pEnd2[ 0] + pEnd4[ 0];
 8001dde:	edc6 7a02 	vstr	s15, [r6, #8]
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001de2:	edd3 8a01 	vldr	s17, [r3, #4]
 8001de6:	edd1 7a01 	vldr	s15, [r1, #4]
 8001dea:	ee77 7aa8 	vadd.f32	s15, s15, s17
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001dee:	ee35 7aeb 	vsub.f32	s14, s11, s23
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001df2:	ee77 7a85 	vadd.f32	s15, s15, s10
      t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001df6:	ee39 9a08 	vadd.f32	s18, s18, s16
      *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8001dfa:	edc6 7a01 	vstr	s15, [r6, #4]
      twI = *tw2++;
 8001dfe:	ed5a 8a01 	vldr	s17, [sl, #-4]
      twR = *tw2++;
 8001e02:	ed5a 7a02 	vldr	s15, [sl, #-8]
      t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001e06:	ee79 9aaa 	vadd.f32	s19, s19, s21
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001e0a:	ee7c 5a65 	vsub.f32	s11, s24, s11
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001e0e:	ee71 3a8b 	vadd.f32	s7, s3, s22
      m0 = -t3[3] * twR;
 8001e12:	ee70 0acc 	vsub.f32	s1, s1, s24
      t3[3] = p1ap3_0 - pEnd2[ 0] - pEnd4[ 0];
 8001e16:	ee75 5aeb 	vsub.f32	s11, s11, s23
      m1 = t2[1] * twI;
 8001e1a:	ee29 ca28 	vmul.f32	s24, s18, s17
      *p2++ = m2 - m3;
 8001e1e:	ee68 bae9 	vnmul.f32	s23, s17, s19
      *p2++ = m0 + m1;
 8001e22:	eea9 caa7 	vfma.f32	s24, s19, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e26:	f108 0810 	add.w	r8, r8, #16
 8001e2a:	3708      	adds	r7, #8
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001e2c:	ee73 3ac6 	vsub.f32	s7, s7, s12
      *p2++ = m2 - m3;
 8001e30:	eef0 9a6b 	vmov.f32	s19, s23
 8001e34:	eee9 9a27 	vfma.f32	s19, s18, s15
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e38:	3e08      	subs	r6, #8
 8001e3a:	f10a 0a08 	add.w	sl, sl, #8
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001e3e:	ee37 9a41 	vsub.f32	s18, s14, s2
      t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8001e42:	ee73 3ac0 	vsub.f32	s7, s7, s0
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001e46:	ee35 5a40 	vsub.f32	s10, s10, s0
      t2[2] = pEnd2[0] - pEnd4[0] + p1sp3_1;
 8001e4a:	ee39 9a0a 	vadd.f32	s18, s18, s20
      t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8001e4e:	ee35 5a4b 	vsub.f32	s10, s10, s22
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001e52:	ee36 6a0b 	vadd.f32	s12, s12, s22
      m3 = t2[3] * twR;
 8001e56:	ee23 baa7 	vmul.f32	s22, s7, s15
      *pEnd2-- = m0 - m1;
 8001e5a:	ee67 7ac9 	vnmul.f32	s15, s15, s18
      *p2++ = m2 - m3;
 8001e5e:	ed40 9a01 	vstr	s19, [r0, #-4]
      *pEnd2-- = m2 + m3;
 8001e62:	eef0 9a4b 	vmov.f32	s19, s22
      *pEnd2-- = m0 - m1;
 8001e66:	eee3 7aa8 	vfma.f32	s15, s7, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e6a:	3008      	adds	r0, #8
 8001e6c:	3908      	subs	r1, #8
      *pEnd2-- = m2 + m3;
 8001e6e:	eee9 9a28 	vfma.f32	s19, s18, s17
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001e72:	f10e 0e08 	add.w	lr, lr, #8
 8001e76:	f1ac 0c08 	sub.w	ip, ip, #8
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001e7a:	ee34 4a62 	vsub.f32	s8, s8, s5
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001e7e:	ee74 4aea 	vsub.f32	s9, s9, s21
      *p2++ = m0 + m1;
 8001e82:	ed00 ca04 	vstr	s24, [r0, #-16]
      *pEnd2-- = m2 + m3;
 8001e86:	edc1 9a03 	vstr	s19, [r1, #12]
      *pEnd2-- = m0 - m1;
 8001e8a:	edc1 7a04 	vstr	s15, [r1, #16]
      twI = tw3[1];
 8001e8e:	ed58 7a07 	vldr	s15, [r8, #-28]	@ 0xffffffe4
      twR = tw3[0];
 8001e92:	ed58 3a08 	vldr	s7, [r8, #-32]	@ 0xffffffe0
      t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001e96:	ee34 4a48 	vsub.f32	s8, s8, s16
      t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001e9a:	ee74 4ac2 	vsub.f32	s9, s9, s4
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001e9e:	ee76 6ac8 	vsub.f32	s13, s13, s16
      m1 = t3[1] * twI;
 8001ea2:	ee64 8aa7 	vmul.f32	s17, s9, s15
      *p3++ = m2 - m3;
 8001ea6:	ee27 8ac4 	vnmul.f32	s16, s15, s8
      m3 =  t3[3] * twI;
 8001eaa:	ee65 5aa7 	vmul.f32	s11, s11, s15
      *pEnd3-- = m0 - m1;
 8001eae:	ee67 7ac5 	vnmul.f32	s15, s15, s10
      *p3++ = m0 + m1;
 8001eb2:	eee4 8a23 	vfma.f32	s17, s8, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001eb6:	4545      	cmp	r5, r8
 8001eb8:	f109 0918 	add.w	r9, r9, #24
      *p3++ = m2 - m3;
 8001ebc:	eeb0 4a48 	vmov.f32	s8, s16
 8001ec0:	eea4 4aa3 	vfma.f32	s8, s9, s7
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001ec4:	f102 0208 	add.w	r2, r2, #8
 8001ec8:	f1a3 0308 	sub.w	r3, r3, #8
      *pEnd3-- = m3 - m2;
 8001ecc:	eee5 5a63 	vfms.f32	s11, s10, s7
      *pEnd3-- = m0 - m1;
 8001ed0:	eee3 7aa0 	vfma.f32	s15, s7, s1
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 8001ed4:	ee37 7a4a 	vsub.f32	s14, s14, s20
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001ed8:	ee33 3a6a 	vsub.f32	s6, s6, s21
      *p3++ = m0 + m1;
 8001edc:	ed4e 8a04 	vstr	s17, [lr, #-16]
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001ee0:	ee36 6a40 	vsub.f32	s12, s12, s0
      *p3++ = m2 - m3;
 8001ee4:	ed0e 4a03 	vstr	s8, [lr, #-12]
      *pEnd3-- = m0 - m1;
 8001ee8:	edcc 7a04 	vstr	s15, [ip, #16]
      *pEnd3-- = m3 - m2;
 8001eec:	edcc 5a03 	vstr	s11, [ip, #12]
      twR = tw4[0];
 8001ef0:	ed19 5a0c 	vldr	s10, [r9, #-48]	@ 0xffffffd0
      twI = tw4[1];
 8001ef4:	ed59 5a0b 	vldr	s11, [r9, #-44]	@ 0xffffffd4
      t4[2] = pEnd2[ 0] - pEnd4[ 0] - p1sp3_1;
 8001ef8:	ee77 7a01 	vadd.f32	s15, s14, s2
      t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001efc:	ee33 3a02 	vadd.f32	s6, s6, s4
      t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8001f00:	ee36 7a61 	vsub.f32	s14, s12, s3
      t4[1] = p1sp3_1 + p2[0] - p4[0];
 8001f04:	ee76 6aa2 	vadd.f32	s13, s13, s5
      *p4++ = m2 - m3;
 8001f08:	ee25 4ac3 	vnmul.f32	s8, s11, s6
      *pEnd4-- = m0 - m1;
 8001f0c:	ee65 4a67 	vnmul.f32	s9, s10, s15
      m3 = t4[3] * twR;
 8001f10:	ee27 6a05 	vmul.f32	s12, s14, s10
      *p4++ = m2 - m3;
 8001f14:	eea6 4a85 	vfma.f32	s8, s13, s10
      m1 = t4[1] * twI;
 8001f18:	ee66 3aa5 	vmul.f32	s7, s13, s11
      *pEnd4-- = m0 - m1;
 8001f1c:	eef0 6a64 	vmov.f32	s13, s9
 8001f20:	eee7 6a25 	vfma.f32	s13, s14, s11
      *pEnd4-- = m2 + m3;
 8001f24:	eeb0 7a46 	vmov.f32	s14, s12
      *p4++ = m0 + m1;
 8001f28:	eee3 3a05 	vfma.f32	s7, s6, s10
      *pEnd4-- = m2 + m3;
 8001f2c:	eea7 7aa5 	vfma.f32	s14, s15, s11
      *p4++ = m0 + m1;
 8001f30:	ed42 3a04 	vstr	s7, [r2, #-16]
      *p4++ = m2 - m3;
 8001f34:	ed02 4a03 	vstr	s8, [r2, #-12]
      *pEnd4-- = m0 - m1;
 8001f38:	edc3 6a04 	vstr	s13, [r3, #16]
      *pEnd4-- = m2 + m3;
 8001f3c:	ed83 7a03 	vstr	s14, [r3, #12]
    for (l = (L - 2) >> 1; l > 0; l-- )
 8001f40:	f47f af09 	bne.w	8001d56 <arm_cfft_f32+0x3b2>
 8001f44:	e9dd 0309 	ldrd	r0, r3, [sp, #36]	@ 0x24
 8001f48:	4418      	add	r0, r3
 8001f4a:	9b07      	ldr	r3, [sp, #28]
 8001f4c:	9f05      	ldr	r7, [sp, #20]
 8001f4e:	9906      	ldr	r1, [sp, #24]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001f50:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 8001f54:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8001f56:	00da      	lsls	r2, r3, #3
 8001f58:	3208      	adds	r2, #8
 8001f5a:	eb07 0c02 	add.w	ip, r7, r2
 8001f5e:	eb04 0e02 	add.w	lr, r4, r2
 8001f62:	9f03      	ldr	r7, [sp, #12]
    p1ap3_0 = p1[0] + p3[0];
 8001f64:	ed9c 5a00 	vldr	s10, [ip]
 8001f68:	edde 7a00 	vldr	s15, [lr]
    p1ap3_1 = p1[1] + p3[1];
 8001f6c:	eddc 5a01 	vldr	s11, [ip, #4]
 8001f70:	ed9e 7a01 	vldr	s14, [lr, #4]
 8001f74:	3301      	adds	r3, #1
 8001f76:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8001f7a:	eb07 0802 	add.w	r8, r7, r2
    p1ap3_0 = p1[0] + p3[0];
 8001f7e:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8001f82:	9904      	ldr	r1, [sp, #16]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001f84:	edd8 4a00 	vldr	s9, [r8]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001f88:	edd8 2a01 	vldr	s5, [r8, #4]
    p1ap3_0 = p1[0] + p3[0];
 8001f8c:	ee77 6a85 	vadd.f32	s13, s15, s10
    p1sp3_0 = p1[0] - p3[0];
 8001f90:	188f      	adds	r7, r1, r2
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001f92:	ed97 4a00 	vldr	s8, [r7]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001f96:	ed97 3a01 	vldr	s6, [r7, #4]
 8001f9a:	9906      	ldr	r1, [sp, #24]
    p1ap3_1 = p1[1] + p3[1];
 8001f9c:	ee37 6a25 	vadd.f32	s12, s14, s11
    p1sp3_1 = p1[1] - p3[1];
 8001fa0:	ee37 7a65 	vsub.f32	s14, s14, s11
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001fa4:	ee76 5aa4 	vadd.f32	s11, s13, s9
    p1sp3_0 = p1[0] - p3[0];
 8001fa8:	ee77 7ac5 	vsub.f32	s15, s15, s10
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001fac:	ee75 5a84 	vadd.f32	s11, s11, s8
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8001fb0:	ee37 5aa2 	vadd.f32	s10, s15, s5
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8001fb4:	edce 5a00 	vstr	s11, [lr]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001fb8:	edd8 5a01 	vldr	s11, [r8, #4]
 8001fbc:	ed97 2a01 	vldr	s4, [r7, #4]
 8001fc0:	ee76 5a25 	vadd.f32	s11, s12, s11
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001fc4:	ee77 3a44 	vsub.f32	s7, s14, s8
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001fc8:	ee75 5a82 	vadd.f32	s11, s11, s4
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001fcc:	ee77 7a83 	vadd.f32	s15, s15, s6
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8001fd0:	edce 5a01 	vstr	s11, [lr, #4]
 8001fd4:	440a      	add	r2, r1
    twI = tw2[1];
 8001fd6:	edd2 5a01 	vldr	s11, [r2, #4]
    twR = tw2[0];
 8001fda:	edd2 1a00 	vldr	s3, [r2]
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8001fde:	ee77 7ae2 	vsub.f32	s15, s15, s5
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8001fe2:	ee73 3aa4 	vadd.f32	s7, s7, s9
    *p2++ = m2 - m3;
 8001fe6:	ee25 2ae7 	vnmul.f32	s4, s11, s15
    m1 = t2[1] * twI;
 8001fea:	ee63 5aa5 	vmul.f32	s11, s7, s11
    *p2++ = m2 - m3;
 8001fee:	eea3 2aa1 	vfma.f32	s4, s7, s3
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8001ff2:	460a      	mov	r2, r1
 8001ff4:	4631      	mov	r1, r6
    *p2++ = m0 + m1;
 8001ff6:	eee7 5aa1 	vfma.f32	s11, s15, s3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8001ffa:	ee76 7ac4 	vsub.f32	s15, s13, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8001ffe:	ee76 6a43 	vsub.f32	s13, s12, s6
    *p2++ = m2 - m3;
 8002002:	ed87 2a01 	vstr	s4, [r7, #4]
    *p2++ = m0 + m1;
 8002006:	edc7 5a00 	vstr	s11, [r7]
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 800200a:	ee77 7ae4 	vsub.f32	s15, s15, s9
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 800200e:	ee76 6ae2 	vsub.f32	s13, s13, s5
    twI = tw3[1];
 8002012:	ed90 6a01 	vldr	s12, [r0, #4]
    twR = tw3[0];
 8002016:	edd0 3a00 	vldr	s7, [r0]
    *p3++ = m2 - m3;
 800201a:	ee66 5a67 	vnmul.f32	s11, s12, s15
    m1 = t3[1] * twI;
 800201e:	ee26 6a86 	vmul.f32	s12, s13, s12
    *p3++ = m2 - m3;
 8002022:	eee6 5aa3 	vfma.f32	s11, s13, s7
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8002026:	4620      	mov	r0, r4
    *p3++ = m0 + m1;
 8002028:	eea7 6aa3 	vfma.f32	s12, s15, s7
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 800202c:	ee77 7a04 	vadd.f32	s15, s14, s8
    *p3++ = m0 + m1;
 8002030:	ed8c 6a00 	vstr	s12, [ip]
    *p3++ = m2 - m3;
 8002034:	edcc 5a01 	vstr	s11, [ip, #4]
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8002038:	ee75 6a43 	vsub.f32	s13, s10, s6
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 800203c:	ee77 7ae4 	vsub.f32	s15, s15, s9
    twI = tw4[1];
 8002040:	ed93 7a01 	vldr	s14, [r3, #4]
    twR = tw4[0];
 8002044:	edd3 5a00 	vldr	s11, [r3]
    *p4++ = m2 - m3;
 8002048:	ee27 6a66 	vnmul.f32	s12, s14, s13
    m1 = t4[1] * twI;
 800204c:	ee27 7a87 	vmul.f32	s14, s15, s14
    *p4++ = m2 - m3;
 8002050:	eea7 6aa5 	vfma.f32	s12, s15, s11
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8002054:	2304      	movs	r3, #4
    *p4++ = m0 + m1;
 8002056:	eea6 7aa5 	vfma.f32	s14, s13, s11
    *p4++ = m2 - m3;
 800205a:	ed88 6a01 	vstr	s12, [r8, #4]
    *p4++ = m0 + m1;
 800205e:	ed88 7a00 	vstr	s14, [r8]
    arm_radix8_butterfly_f32 (pCol1, L, (float32_t *) S->pTwiddle, 4U);
 8002062:	f000 f835 	bl	80020d0 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol2, L, (float32_t *) S->pTwiddle, 4U);
 8002066:	9804      	ldr	r0, [sp, #16]
 8002068:	f8db 2004 	ldr.w	r2, [fp, #4]
 800206c:	2304      	movs	r3, #4
 800206e:	4631      	mov	r1, r6
 8002070:	f000 f82e 	bl	80020d0 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol3, L, (float32_t *) S->pTwiddle, 4U);
 8002074:	9805      	ldr	r0, [sp, #20]
 8002076:	f8db 2004 	ldr.w	r2, [fp, #4]
 800207a:	2304      	movs	r3, #4
 800207c:	4631      	mov	r1, r6
 800207e:	f000 f827 	bl	80020d0 <arm_radix8_butterfly_f32>
    arm_radix8_butterfly_f32 (pCol4, L, (float32_t *) S->pTwiddle, 4U);
 8002082:	2304      	movs	r3, #4
 8002084:	9803      	ldr	r0, [sp, #12]
 8002086:	f8db 2004 	ldr.w	r2, [fp, #4]
 800208a:	4631      	mov	r1, r6
 800208c:	f000 f820 	bl	80020d0 <arm_radix8_butterfly_f32>
  if ( bitReverseFlag )
 8002090:	9b01      	ldr	r3, [sp, #4]
 8002092:	2b00      	cmp	r3, #0
 8002094:	f43f acde 	beq.w	8001a54 <arm_cfft_f32+0xb0>
 8002098:	e4a1      	b.n	80019de <arm_cfft_f32+0x3a>
 800209a:	9b01      	ldr	r3, [sp, #4]
 800209c:	2b00      	cmp	r3, #0
 800209e:	f43f acdd 	beq.w	8001a5c <arm_cfft_f32+0xb8>
    arm_bitreversal_32 ((uint32_t*) p1, S->bitRevLength, S->pBitRevTable);
 80020a2:	6882      	ldr	r2, [r0, #8]
 80020a4:	8981      	ldrh	r1, [r0, #12]
 80020a6:	4620      	mov	r0, r4
 80020a8:	f7ff fc52 	bl	8001950 <arm_bitreversal_32>
  if (ifftFlag == 1U)
 80020ac:	e4a1      	b.n	80019f2 <arm_cfft_f32+0x4e>
 80020ae:	bf00      	nop

080020b0 <arm_cfft_init_128_f32>:

  @par          Use of this function is mandatory only for the Helium and Neon versions of the FFT.
                Other versions can still initialize directly the data structure using 
                variables declared in arm_const_structs.h
 */
CFFTINIT_F32(128,64)
 80020b0:	4b06      	ldr	r3, [pc, #24]	@ (80020cc <arm_cfft_init_128_f32+0x1c>)
 80020b2:	8999      	ldrh	r1, [r3, #12]
 80020b4:	8181      	strh	r1, [r0, #12]
 80020b6:	e9d3 3201 	ldrd	r3, r2, [r3, #4]
 80020ba:	f04f 0c80 	mov.w	ip, #128	@ 0x80
 80020be:	e9c0 3201 	strd	r3, r2, [r0, #4]
 80020c2:	f8a0 c000 	strh.w	ip, [r0]
 80020c6:	2000      	movs	r0, #0
 80020c8:	4770      	bx	lr
 80020ca:	bf00      	nop
 80020cc:	08003644 	.word	0x08003644

080020d0 <arm_radix8_butterfly_f32>:
ARM_DSP_ATTRIBUTE void arm_radix8_butterfly_f32(
  float32_t * pSrc,
  uint16_t fftLen,
  const float32_t * pCoef,
  uint16_t twidCoefModifier)
{
 80020d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80020d4:	ed2d 8b10 	vpush	{d8-d15}
 80020d8:	b08f      	sub	sp, #60	@ 0x3c
 80020da:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
 80020de:	4603      	mov	r3, r0
 80020e0:	3304      	adds	r3, #4
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 80020e2:	ed9f cabc 	vldr	s24, [pc, #752]	@ 80023d4 <arm_radix8_butterfly_f32+0x304>
{
 80020e6:	900c      	str	r0, [sp, #48]	@ 0x30
 80020e8:	468a      	mov	sl, r1
   n2 = fftLen;
 80020ea:	468b      	mov	fp, r1
 80020ec:	930d      	str	r3, [sp, #52]	@ 0x34
      n2 = n2 >> 3;
 80020ee:	ea4f 07db 	mov.w	r7, fp, lsr #3
 80020f2:	eb07 0187 	add.w	r1, r7, r7, lsl #2
 80020f6:	ea4f 00cb 	mov.w	r0, fp, lsl #3
 80020fa:	9000      	str	r0, [sp, #0]
 80020fc:	00c8      	lsls	r0, r1, #3
 80020fe:	ebc7 01c7 	rsb	r1, r7, r7, lsl #3
 8002102:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8002104:	9002      	str	r0, [sp, #8]
 8002106:	ea4f 09c7 	mov.w	r9, r7, lsl #3
 800210a:	00c8      	lsls	r0, r1, #3
 800210c:	ea4f 1807 	mov.w	r8, r7, lsl #4
 8002110:	9005      	str	r0, [sp, #20]
 8002112:	f108 0104 	add.w	r1, r8, #4
 8002116:	f109 0004 	add.w	r0, r9, #4
 800211a:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 800211e:	eb03 1247 	add.w	r2, r3, r7, lsl #5
 8002122:	4418      	add	r0, r3
 8002124:	4419      	add	r1, r3
 8002126:	017b      	lsls	r3, r7, #5
 8002128:	9301      	str	r3, [sp, #4]
 800212a:	0133      	lsls	r3, r6, #4
 800212c:	eb02 1507 	add.w	r5, r2, r7, lsl #4
 8002130:	9303      	str	r3, [sp, #12]
 8002132:	00f3      	lsls	r3, r6, #3
 8002134:	eba5 04c6 	sub.w	r4, r5, r6, lsl #3
 8002138:	9304      	str	r3, [sp, #16]
 800213a:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
      i1 = 0;
 800213c:	9b00      	ldr	r3, [sp, #0]
      n2 = n2 >> 3;
 800213e:	9709      	str	r7, [sp, #36]	@ 0x24
      i1 = 0;
 8002140:	eb02 0cc7 	add.w	ip, r2, r7, lsl #3
 8002144:	f04f 0e00 	mov.w	lr, #0
 8002148:	eb04 1747 	add.w	r7, r4, r7, lsl #5
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 800214c:	edd5 9a00 	vldr	s19, [r5]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8002150:	ed94 4a00 	vldr	s8, [r4]
 8002154:	ed97 9a00 	vldr	s18, [r7]
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002158:	ed11 2a01 	vldr	s4, [r1, #-4]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 800215c:	ed92 6a00 	vldr	s12, [r2]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002160:	ed9c 5a00 	vldr	s10, [ip]
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002164:	ed56 3a01 	vldr	s7, [r6, #-4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002168:	ed50 7a01 	vldr	s15, [r0, #-4]
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 800216c:	ee34 8a09 	vadd.f32	s16, s8, s18
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002170:	ee37 0a85 	vadd.f32	s0, s15, s10
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002174:	ee32 3a29 	vadd.f32	s6, s4, s19
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002178:	ee33 7a86 	vadd.f32	s14, s7, s12
         r2 = r2 + r4;
 800217c:	ee70 5a08 	vadd.f32	s11, s0, s16
         r1 = r1 + r3;
 8002180:	ee77 6a03 	vadd.f32	s13, s14, s6
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 8002184:	ee77 7ac5 	vsub.f32	s15, s15, s10
         pSrc[2 * i1] = r1 + r2;
 8002188:	ee36 5aa5 	vadd.f32	s10, s13, s11
         pSrc[2 * i5] = r1 - r2;
 800218c:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i1] = r1 + r2;
 8002190:	ed06 5a01 	vstr	s10, [r6, #-4]
         pSrc[2 * i5] = r1 - r2;
 8002194:	edc2 6a00 	vstr	s13, [r2]
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002198:	ed9c ba01 	vldr	s22, [ip, #4]
 800219c:	edd0 ba00 	vldr	s23, [r0]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80021a0:	ed94 1a01 	vldr	s2, [r4, #4]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80021a4:	edd2 aa01 	vldr	s21, [r2, #4]
 80021a8:	edd6 5a00 	vldr	s11, [r6]
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80021ac:	edd7 2a01 	vldr	s5, [r7, #4]
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80021b0:	ed91 aa00 	vldr	s20, [r1]
 80021b4:	edd5 1a01 	vldr	s3, [r5, #4]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 80021b8:	ee7b 6acb 	vsub.f32	s13, s23, s22
         r1 = (r6 - r8) * C81;
 80021bc:	ee37 5ac4 	vsub.f32	s10, s15, s8
         r2 = (s6 - s8) * C81;
 80021c0:	ee76 4ac1 	vsub.f32	s9, s13, s2
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 80021c4:	ee75 0aea 	vsub.f32	s1, s11, s21
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 80021c8:	ee73 3ac6 	vsub.f32	s7, s7, s12
         r1 = (r6 - r8) * C81;
 80021cc:	ee35 5a09 	vadd.f32	s10, s10, s18
         r2 = (s6 - s8) * C81;
 80021d0:	ee34 6aa2 	vadd.f32	s12, s9, s5
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 80021d4:	eef0 8a60 	vmov.f32	s17, s1
         t1 = r5 - r1;
 80021d8:	eef0 4a63 	vmov.f32	s9, s7
 80021dc:	eee5 4a4c 	vfms.f32	s9, s10, s24
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 80021e0:	44de      	add	lr, fp
      } while (i1 < fftLen);
 80021e2:	45f2      	cmp	sl, lr
         t2 = s5 - r2;
 80021e4:	eee6 8a4c 	vfms.f32	s17, s12, s24
         r6 = (r6 + r8) * C81;
 80021e8:	ee77 7ac9 	vsub.f32	s15, s15, s18
         s6 = (s6 + s8) * C81;
 80021ec:	ee76 6ae2 	vsub.f32	s13, s13, s5
         r6 = (r6 + r8) * C81;
 80021f0:	ee77 7a84 	vadd.f32	s15, s15, s8
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 80021f4:	ee32 9a69 	vsub.f32	s18, s4, s19
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 80021f8:	ee3a 4a61 	vsub.f32	s8, s20, s3
         s6 = (s6 + s8) * C81;
 80021fc:	ee76 6a81 	vadd.f32	s13, s13, s2
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002200:	ee75 5aaa 	vadd.f32	s11, s11, s21
 8002204:	ee39 2ac2 	vsub.f32	s4, s19, s4
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8002208:	ee7a aa21 	vadd.f32	s21, s20, s3
 800220c:	ee71 1aca 	vsub.f32	s3, s3, s20
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002210:	ee7b ba8b 	vadd.f32	s23, s23, s22
         r5 = r5 + r1;
 8002214:	eee5 3a0c 	vfma.f32	s7, s10, s24
         s7 = s7 + s6;
 8002218:	eeb0 aa44 	vmov.f32	s20, s8
 800221c:	eeb0 ba64 	vmov.f32	s22, s9
         r7 = r7 + r6;
 8002220:	eeb0 5a49 	vmov.f32	s10, s18
 8002224:	eef0 9a68 	vmov.f32	s19, s17
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002228:	ee31 1a22 	vadd.f32	s2, s2, s5
         r7 = r7 + r6;
 800222c:	eea7 5a8c 	vfma.f32	s10, s15, s24
         s5 = s5 + r2;
 8002230:	eee6 0a0c 	vfma.f32	s1, s12, s24
         s7 = s7 + s6;
 8002234:	eea6 aa8c 	vfma.f32	s20, s13, s24
         t2 = r1 - s3;
 8002238:	ee35 6aea 	vsub.f32	s12, s11, s21
 800223c:	eee6 1a8c 	vfma.f32	s3, s13, s24
         t1 = r1 - r3;
 8002240:	ee37 7a43 	vsub.f32	s14, s14, s6
         r1 = r1 + s3;
 8002244:	eee7 9acc 	vfms.f32	s19, s15, s24
 8002248:	eea6 bacc 	vfms.f32	s22, s13, s24
 800224c:	eea7 2a8c 	vfma.f32	s4, s15, s24
         r2 = r2 + r4;
 8002250:	ee7b 2a81 	vadd.f32	s5, s23, s2
         pSrc[2 * i3]     = t1 + s3;
 8002254:	ee77 6a41 	vsub.f32	s13, s14, s2
         r1 = r1 + s3;
 8002258:	ee75 7aaa 	vadd.f32	s15, s11, s21
         pSrc[2 * i3 + 1] = t2 - r3;
 800225c:	ee36 3a40 	vsub.f32	s6, s12, s0
         pSrc[2 * i7]     = t1 - s3;
 8002260:	ee37 7a6b 	vsub.f32	s14, s14, s23
         pSrc[2 * i7 + 1] = t2 + r3;
 8002264:	ee36 6a48 	vsub.f32	s12, s12, s16
         pSrc[2 * i1 + 1] = r1 + r2;
 8002268:	ee77 aaa2 	vadd.f32	s21, s15, s5
         pSrc[2 * i7]     = t1 - s3;
 800226c:	ee37 7a01 	vadd.f32	s14, s14, s2
         pSrc[2 * i5 + 1] = r1 - r2;
 8002270:	ee77 7ae2 	vsub.f32	s15, s15, s5
         pSrc[2 * i2]     = r5 + s7;
 8002274:	ee33 1a8a 	vadd.f32	s2, s7, s20
         pSrc[2 * i3]     = t1 + s3;
 8002278:	ee76 2aab 	vadd.f32	s5, s13, s23
         pSrc[2 * i4]     = t1 - s8;
 800227c:	ee74 4aa1 	vadd.f32	s9, s9, s3
         pSrc[2 * i3 + 1] = t2 - r3;
 8002280:	ee33 3a08 	vadd.f32	s6, s6, s16
         pSrc[2 * i2 + 1] = s5 - r7;
 8002284:	ee70 1ac5 	vsub.f32	s3, s1, s10
         pSrc[2 * i7 + 1] = t2 + r3;
 8002288:	ee36 6a00 	vadd.f32	s12, s12, s0
         pSrc[2 * i8]     = r5 - s7;
 800228c:	ee73 3aca 	vsub.f32	s7, s7, s20
         pSrc[2 * i6]     = t1 + s8;
 8002290:	ee34 4a0b 	vadd.f32	s8, s8, s22
         pSrc[2 * i8 + 1] = s5 + r7;
 8002294:	ee35 5a20 	vadd.f32	s10, s10, s1
         pSrc[2 * i6 + 1] = t2 - r8;
 8002298:	ee78 5a82 	vadd.f32	s11, s17, s4
         pSrc[2 * i4 + 1] = t2 + r8;
 800229c:	ee79 6a29 	vadd.f32	s13, s18, s19
         pSrc[2 * i1 + 1] = r1 + r2;
 80022a0:	edc6 aa00 	vstr	s21, [r6]
         pSrc[2 * i5 + 1] = r1 - r2;
 80022a4:	edc2 7a01 	vstr	s15, [r2, #4]
      } while (i1 < fftLen);
 80022a8:	441e      	add	r6, r3
         pSrc[2 * i3]     = t1 + s3;
 80022aa:	ed41 2a01 	vstr	s5, [r1, #-4]
      } while (i1 < fftLen);
 80022ae:	441a      	add	r2, r3
         pSrc[2 * i7]     = t1 - s3;
 80022b0:	ed85 7a00 	vstr	s14, [r5]
         pSrc[2 * i3 + 1] = t2 - r3;
 80022b4:	ed81 3a00 	vstr	s6, [r1]
         pSrc[2 * i7 + 1] = t2 + r3;
 80022b8:	ed85 6a01 	vstr	s12, [r5, #4]
      } while (i1 < fftLen);
 80022bc:	4419      	add	r1, r3
         pSrc[2 * i2]     = r5 + s7;
 80022be:	ed00 1a01 	vstr	s2, [r0, #-4]
      } while (i1 < fftLen);
 80022c2:	441d      	add	r5, r3
         pSrc[2 * i8]     = r5 - s7;
 80022c4:	edc7 3a00 	vstr	s7, [r7]
         pSrc[2 * i6]     = t1 + s8;
 80022c8:	ed8c 4a00 	vstr	s8, [ip]
         pSrc[2 * i4]     = t1 - s8;
 80022cc:	edc4 4a00 	vstr	s9, [r4]
         pSrc[2 * i2 + 1] = s5 - r7;
 80022d0:	edc0 1a00 	vstr	s3, [r0]
         pSrc[2 * i8 + 1] = s5 + r7;
 80022d4:	ed87 5a01 	vstr	s10, [r7, #4]
      } while (i1 < fftLen);
 80022d8:	4418      	add	r0, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 80022da:	edcc 5a01 	vstr	s11, [ip, #4]
      } while (i1 < fftLen);
 80022de:	441f      	add	r7, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 80022e0:	edc4 6a01 	vstr	s13, [r4, #4]
      } while (i1 < fftLen);
 80022e4:	449c      	add	ip, r3
 80022e6:	441c      	add	r4, r3
 80022e8:	f63f af30 	bhi.w	800214c <arm_radix8_butterfly_f32+0x7c>

      if (n2 < 8)
 80022ec:	461f      	mov	r7, r3
 80022ee:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80022f0:	2b07      	cmp	r3, #7
 80022f2:	f240 81a1 	bls.w	8002638 <arm_radix8_butterfly_f32+0x568>
 80022f6:	9d01      	ldr	r5, [sp, #4]
 80022f8:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 80022fa:	9c02      	ldr	r4, [sp, #8]
 80022fc:	9803      	ldr	r0, [sp, #12]
 80022fe:	9904      	ldr	r1, [sp, #16]
 8002300:	9a05      	ldr	r2, [sp, #20]
 8002302:	3508      	adds	r5, #8
 8002304:	f109 0908 	add.w	r9, r9, #8
 8002308:	1973      	adds	r3, r6, r5
 800230a:	3408      	adds	r4, #8
 800230c:	9308      	str	r3, [sp, #32]
 800230e:	eb06 0309 	add.w	r3, r6, r9
 8002312:	3008      	adds	r0, #8
 8002314:	9307      	str	r3, [sp, #28]
 8002316:	1933      	adds	r3, r6, r4
 8002318:	3108      	adds	r1, #8
 800231a:	9306      	str	r3, [sp, #24]
 800231c:	1833      	adds	r3, r6, r0
 800231e:	3208      	adds	r2, #8
 8002320:	9305      	str	r3, [sp, #20]
 8002322:	1873      	adds	r3, r6, r1
 8002324:	f108 080c 	add.w	r8, r8, #12
 8002328:	9304      	str	r3, [sp, #16]
 800232a:	18b3      	adds	r3, r6, r2
 800232c:	9303      	str	r3, [sp, #12]
 800232e:	eb06 0308 	add.w	r3, r6, r8
 8002332:	9301      	str	r3, [sp, #4]
 8002334:	f106 030c 	add.w	r3, r6, #12
 8002338:	9302      	str	r3, [sp, #8]
         break;

      ia1 = 0;
      j = 1;
 800233a:	f04f 0901 	mov.w	r9, #1
      ia1 = 0;
 800233e:	f04f 0800 	mov.w	r8, #0
 8002342:	463b      	mov	r3, r7

      do
      {
         /*  index calculation for the coefficients */
         id  = ia1 + twidCoefModifier;
 8002344:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8002346:	4490      	add	r8, r2
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 8002348:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800234a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800234e:	ed92 fa00 	vldr	s30, [r2]
         co3 = pCoef[2 * ia2];
 8002352:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002356:	edd2 ea00 	vldr	s29, [r2]
         co4 = pCoef[2 * ia3];
 800235a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800235e:	ed92 ea00 	vldr	s28, [r2]
         co5 = pCoef[2 * ia4];
 8002362:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002366:	edd2 da00 	vldr	s27, [r2]
         co6 = pCoef[2 * ia5];
 800236a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800236e:	ed92 da00 	vldr	s26, [r2]
         co7 = pCoef[2 * ia6];
 8002372:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002376:	eb08 0148 	add.w	r1, r8, r8, lsl #1
 800237a:	edd2 ca00 	vldr	s25, [r2]
         co8 = pCoef[2 * ia7];
 800237e:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002382:	edd2 ba00 	vldr	s23, [r2]
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
         si8 = pCoef[2 * ia7 + 1];
 8002386:	ed92 ba01 	vldr	s22, [r2, #4]
 800238a:	eba2 1201 	sub.w	r2, r2, r1, lsl #4
         si2 = pCoef[2 * ia1 + 1];
 800238e:	edd2 aa01 	vldr	s21, [r2, #4]
         si3 = pCoef[2 * ia2 + 1];
 8002392:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8002396:	ed92 aa01 	vldr	s20, [r2, #4]
         si4 = pCoef[2 * ia3 + 1];
 800239a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800239e:	edd2 9a01 	vldr	s19, [r2, #4]
         si5 = pCoef[2 * ia4 + 1];
 80023a2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80023a6:	ed92 9a01 	vldr	s18, [r2, #4]
         si6 = pCoef[2 * ia5 + 1];
 80023aa:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80023ae:	edd2 8a01 	vldr	s17, [r2, #4]
         si7 = pCoef[2 * ia6 + 1];
 80023b2:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 80023b6:	edd2 7a01 	vldr	s15, [r2, #4]
         si8 = pCoef[2 * ia7 + 1];
 80023ba:	e9dd c701 	ldrd	ip, r7, [sp, #4]
 80023be:	e9dd 6503 	ldrd	r6, r5, [sp, #12]
 80023c2:	e9dd 4005 	ldrd	r4, r0, [sp, #20]
 80023c6:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
         si7 = pCoef[2 * ia6 + 1];
 80023ca:	edcd 7a00 	vstr	s15, [sp]

         i1 = j;
 80023ce:	46ce      	mov	lr, r9
 80023d0:	e002      	b.n	80023d8 <arm_radix8_butterfly_f32+0x308>
 80023d2:	bf00      	nop
 80023d4:	3f3504f3 	.word	0x3f3504f3
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80023d8:	edd5 4a00 	vldr	s9, [r5]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80023dc:	ed1c 7a01 	vldr	s14, [ip, #-4]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80023e0:	edd6 fa00 	vldr	s31, [r6]
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80023e4:	edd4 6a00 	vldr	s13, [r4]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80023e8:	edd2 3a00 	vldr	s7, [r2]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80023ec:	ed90 3a00 	vldr	s6, [r0]
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80023f0:	ed57 5a01 	vldr	s11, [r7, #-4]
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80023f4:	edd1 7a00 	vldr	s15, [r1]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80023f8:	ed97 1a00 	vldr	s2, [r7]
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80023fc:	ee74 0aaf 	vadd.f32	s1, s9, s31
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8002400:	ee37 0a83 	vadd.f32	s0, s15, s6
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8002404:	ee37 5a26 	vadd.f32	s10, s14, s13
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8002408:	ee35 6aa3 	vadd.f32	s12, s11, s7
            r2 = r2 + r4;
 800240c:	ee30 4a20 	vadd.f32	s8, s0, s1
            r1 = r1 + r3;
 8002410:	ee36 2a05 	vadd.f32	s4, s12, s10
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 8002414:	ee77 7ac3 	vsub.f32	s15, s15, s6
            pSrc[2 * i1] = r1 + r2;
 8002418:	ee32 3a04 	vadd.f32	s6, s4, s8
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 800241c:	ee75 5ae3 	vsub.f32	s11, s11, s7
            pSrc[2 * i1] = r1 + r2;
 8002420:	ed07 3a01 	vstr	s6, [r7, #-4]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002424:	ed90 3a01 	vldr	s6, [r0, #4]
 8002428:	edd1 3a01 	vldr	s7, [r1, #4]
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 800242c:	ed92 8a01 	vldr	s16, [r2, #4]
            r2 = r1 - r2;
 8002430:	ee32 2a44 	vsub.f32	s4, s4, s8
            t1 = r1 - r3;
 8002434:	ee36 6a45 	vsub.f32	s12, s12, s10
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002438:	ed95 4a01 	vldr	s8, [r5, #4]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 800243c:	ee33 5ac3 	vsub.f32	s10, s7, s6
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8002440:	ee73 3a83 	vadd.f32	s7, s7, s6
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 8002444:	ee37 3ae4 	vsub.f32	s6, s15, s9
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8002448:	ee77 1a66 	vsub.f32	s3, s14, s13
            r1 = (r6 - r8) * C81;
 800244c:	ee33 3a2f 	vadd.f32	s6, s6, s31
 8002450:	ee76 6ac7 	vsub.f32	s13, s13, s14
            r6 = (r6 + r8) * C81;
 8002454:	ee77 7aef 	vsub.f32	s15, s15, s31
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8002458:	ed96 7a01 	vldr	s14, [r6, #4]
            s1 = (s6 - s8) * C81;
 800245c:	ee75 fa44 	vsub.f32	s31, s10, s8
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 8002460:	ee71 2a48 	vsub.f32	s5, s2, s16
            r6 = (r6 + r8) * C81;
 8002464:	ee77 7aa4 	vadd.f32	s15, s15, s9
            s1 = (s6 - s8) * C81;
 8002468:	ee7f fa87 	vadd.f32	s31, s31, s14
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 800246c:	eef0 4a65 	vmov.f32	s9, s11
 8002470:	eee3 4a4c 	vfms.f32	s9, s6, s24
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 8002474:	44de      	add	lr, fp
         } while (i1 < fftLen);
 8002476:	45f2      	cmp	sl, lr
            r5 = r5 + r1;
 8002478:	eee3 5a0c 	vfma.f32	s11, s6, s24
            t2 = s5 - s1;
 800247c:	eeb0 3a62 	vmov.f32	s6, s5
 8002480:	eeaf 3acc 	vfms.f32	s6, s31, s24
 8002484:	eee7 6a8c 	vfma.f32	s13, s15, s24
            s6 = (s6 + s8) * C81;
 8002488:	ee35 5a47 	vsub.f32	s10, s10, s14
            s6 = t2 - r8;
 800248c:	ee73 6a26 	vadd.f32	s13, s6, s13
 8002490:	eea7 3acc 	vfms.f32	s6, s15, s24
            s6 = (s6 + s8) * C81;
 8002494:	ee35 5a04 	vadd.f32	s10, s10, s8
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8002498:	ee31 1a08 	vadd.f32	s2, s2, s16
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 800249c:	ee34 4a07 	vadd.f32	s8, s8, s14
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80024a0:	ed9c 8a00 	vldr	s16, [ip]
 80024a4:	ed94 7a01 	vldr	s14, [r4, #4]
            s5 = s5 + s1;
 80024a8:	eeef 2a8c 	vfma.f32	s5, s31, s24
 80024ac:	eef0 fa43 	vmov.f32	s31, s6
            r7 = r7 + r6;
 80024b0:	eeb0 3a61 	vmov.f32	s6, s3
 80024b4:	eea7 3a8c 	vfma.f32	s6, s15, s24
            t2 = t2 + r8;
 80024b8:	ee71 7aaf 	vadd.f32	s15, s3, s31
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80024bc:	ee78 1a07 	vadd.f32	s3, s16, s14
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 80024c0:	ee78 fa47 	vsub.f32	s31, s16, s14
            t2 = s1 - s3;
 80024c4:	ee37 7a48 	vsub.f32	s14, s14, s16
            s7 = s7 + s6;
 80024c8:	eeb0 8a6f 	vmov.f32	s16, s31
 80024cc:	eea5 7a0c 	vfma.f32	s14, s10, s24
 80024d0:	eea5 8a0c 	vfma.f32	s16, s10, s24
            t1 = t1 - s8;
 80024d4:	ee37 7a24 	vadd.f32	s14, s14, s9
 80024d8:	eee5 4a4c 	vfms.f32	s9, s10, s24
            t2 = s1 - s3;
 80024dc:	ee31 5a61 	vsub.f32	s10, s2, s3
            r6 = t1 + s8;
 80024e0:	ee74 4aaf 	vadd.f32	s9, s9, s31
 80024e4:	ee75 fa60 	vsub.f32	s31, s10, s1
            s1 = t2 - r3;
 80024e8:	ee35 5a40 	vsub.f32	s10, s10, s0
            s1 = s1 + s3;
 80024ec:	ee71 1a21 	vadd.f32	s3, s2, s3
            s1 = t2 - r3;
 80024f0:	ee35 5a20 	vadd.f32	s10, s10, s1
            s2 = s2 + s4;
 80024f4:	ee33 1a84 	vadd.f32	s2, s7, s8
            r1 = t1 + s3;
 80024f8:	ee76 0a44 	vsub.f32	s1, s12, s8
 80024fc:	ee36 6a63 	vsub.f32	s12, s12, s7
 8002500:	ee70 0aa3 	vadd.f32	s1, s1, s7
            t1 = t1 - s3;
 8002504:	ee34 6a06 	vadd.f32	s12, s8, s12
            pSrc[2 * i1 + 1] = s1 + s2;
 8002508:	ee71 3a81 	vadd.f32	s7, s3, s2
            pSrc[2 * i5 + 1] = p3 - p4;
 800250c:	ee22 4a49 	vnmul.f32	s8, s4, s18
            s2 = s1 - s2;
 8002510:	ee31 1ac1 	vsub.f32	s2, s3, s2
            pSrc[2 * i1 + 1] = s1 + s2;
 8002514:	edc7 3a00 	vstr	s7, [r7]
            pSrc[2 * i5 + 1] = p3 - p4;
 8002518:	eead 4a81 	vfma.f32	s8, s27, s2
         } while (i1 < fftLen);
 800251c:	441f      	add	r7, r3
            p2 = si5 * s2;
 800251e:	ee69 1a01 	vmul.f32	s3, s18, s2
            p2 = si3 * s1;
 8002522:	ee2a 1a05 	vmul.f32	s2, s20, s10
            pSrc[2 * i5]     = p1 + p2;
 8002526:	eeed 1a82 	vfma.f32	s3, s27, s4
            pSrc[2 * i3]     = p1 + p2;
 800252a:	eeb0 2a41 	vmov.f32	s4, s2
            t2 = t2 + r3;
 800252e:	ee70 fa2f 	vadd.f32	s31, s0, s31
            p2 = si7 * t2;
 8002532:	eddd 3a00 	vldr	s7, [sp]
            pSrc[2 * i5]     = p1 + p2;
 8002536:	edc2 1a00 	vstr	s3, [r2]
            pSrc[2 * i3]     = p1 + p2;
 800253a:	eeae 2aa0 	vfma.f32	s4, s29, s1
            pSrc[2 * i3 + 1] = p3 - p4;
 800253e:	ee60 0aca 	vnmul.f32	s1, s1, s20
            s1 = s5 - r7;
 8002542:	ee32 1ac3 	vsub.f32	s2, s5, s6
            pSrc[2 * i3 + 1] = p3 - p4;
 8002546:	eeee 0a85 	vfma.f32	s1, s29, s10
            p2 = si7 * t2;
 800254a:	ee23 5aaf 	vmul.f32	s10, s7, s31
            pSrc[2 * i7 + 1] = p3 - p4;
 800254e:	ee66 3a63 	vnmul.f32	s7, s12, s7
            pSrc[2 * i7]     = p1 + p2;
 8002552:	eeac 5a86 	vfma.f32	s10, s25, s12
            r1 = r5 + s7;
 8002556:	ee35 6a88 	vadd.f32	s12, s11, s16
            r5 = r5 - s7;
 800255a:	ee35 8ac8 	vsub.f32	s16, s11, s16
            pSrc[2 * i5 + 1] = p3 - p4;
 800255e:	ed82 4a01 	vstr	s8, [r2, #4]
            s5 = s5 + r7;
 8002562:	ee33 3a22 	vadd.f32	s6, s6, s5
            p2 = si2 * s1;
 8002566:	ee6a 1a81 	vmul.f32	s3, s21, s2
            pSrc[2 * i8 + 1] = p3 - p4;
 800256a:	ee28 4a4b 	vnmul.f32	s8, s16, s22
            pSrc[2 * i2 + 1] = p3 - p4;
 800256e:	ee26 0a6a 	vnmul.f32	s0, s12, s21
            pSrc[2 * i2]     = p1 + p2;
 8002572:	eeef 1a06 	vfma.f32	s3, s30, s12
         } while (i1 < fftLen);
 8002576:	441a      	add	r2, r3
            pSrc[2 * i8 + 1] = p3 - p4;
 8002578:	eeab 4a83 	vfma.f32	s8, s23, s6
            p2 = si8 * s5;
 800257c:	ee6b 2a03 	vmul.f32	s5, s22, s6
            p2 = si4 * t2;
 8002580:	ee29 6aa7 	vmul.f32	s12, s19, s15
            pSrc[2 * i4 + 1] = p3 - p4;
 8002584:	ee27 3a69 	vnmul.f32	s6, s14, s19
            pSrc[2 * i2 + 1] = p3 - p4;
 8002588:	eeaf 0a01 	vfma.f32	s0, s30, s2
            p2 = si6 * s6;
 800258c:	ee68 5aa6 	vmul.f32	s11, s17, s13
            pSrc[2 * i6 + 1] = p3 - p4;
 8002590:	ee24 1ae8 	vnmul.f32	s2, s9, s17
            pSrc[2 * i4]     = p1 + p2;
 8002594:	eeae 6a07 	vfma.f32	s12, s28, s14
            pSrc[2 * i4 + 1] = p3 - p4;
 8002598:	eeb0 7a43 	vmov.f32	s14, s6
            pSrc[2 * i7 + 1] = p3 - p4;
 800259c:	eeec 3aaf 	vfma.f32	s7, s25, s31
            pSrc[2 * i8]     = p1 + p2;
 80025a0:	eeeb 2a88 	vfma.f32	s5, s23, s16
            pSrc[2 * i6]     = p1 + p2;
 80025a4:	eeed 5a24 	vfma.f32	s11, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
 80025a8:	eead 1a26 	vfma.f32	s2, s26, s13
            pSrc[2 * i4 + 1] = p3 - p4;
 80025ac:	eeae 7a27 	vfma.f32	s14, s28, s15
            pSrc[2 * i3]     = p1 + p2;
 80025b0:	ed0c 2a01 	vstr	s4, [ip, #-4]
            pSrc[2 * i3 + 1] = p3 - p4;
 80025b4:	edcc 0a00 	vstr	s1, [ip]
            pSrc[2 * i7]     = p1 + p2;
 80025b8:	ed84 5a00 	vstr	s10, [r4]
            pSrc[2 * i7 + 1] = p3 - p4;
 80025bc:	edc4 3a01 	vstr	s7, [r4, #4]
         } while (i1 < fftLen);
 80025c0:	449c      	add	ip, r3
            pSrc[2 * i2]     = p1 + p2;
 80025c2:	edc1 1a00 	vstr	s3, [r1]
            pSrc[2 * i2 + 1] = p3 - p4;
 80025c6:	ed81 0a01 	vstr	s0, [r1, #4]
         } while (i1 < fftLen);
 80025ca:	441c      	add	r4, r3
            pSrc[2 * i8]     = p1 + p2;
 80025cc:	edc6 2a00 	vstr	s5, [r6]
            pSrc[2 * i8 + 1] = p3 - p4;
 80025d0:	ed86 4a01 	vstr	s8, [r6, #4]
         } while (i1 < fftLen);
 80025d4:	4419      	add	r1, r3
            pSrc[2 * i6]     = p1 + p2;
 80025d6:	edc0 5a00 	vstr	s11, [r0]
            pSrc[2 * i6 + 1] = p3 - p4;
 80025da:	ed80 1a01 	vstr	s2, [r0, #4]
         } while (i1 < fftLen);
 80025de:	441e      	add	r6, r3
            pSrc[2 * i4]     = p1 + p2;
 80025e0:	ed85 6a00 	vstr	s12, [r5]
         } while (i1 < fftLen);
 80025e4:	4418      	add	r0, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 80025e6:	ed85 7a01 	vstr	s14, [r5, #4]
         } while (i1 < fftLen);
 80025ea:	441d      	add	r5, r3
 80025ec:	f63f aef4 	bhi.w	80023d8 <arm_radix8_butterfly_f32+0x308>

         j++;
      } while (j < n2);
 80025f0:	9a08      	ldr	r2, [sp, #32]
 80025f2:	3208      	adds	r2, #8
 80025f4:	9208      	str	r2, [sp, #32]
 80025f6:	9a07      	ldr	r2, [sp, #28]
 80025f8:	3208      	adds	r2, #8
 80025fa:	9207      	str	r2, [sp, #28]
 80025fc:	9a06      	ldr	r2, [sp, #24]
 80025fe:	3208      	adds	r2, #8
 8002600:	9206      	str	r2, [sp, #24]
 8002602:	9a05      	ldr	r2, [sp, #20]
 8002604:	3208      	adds	r2, #8
 8002606:	9205      	str	r2, [sp, #20]
 8002608:	9a04      	ldr	r2, [sp, #16]
 800260a:	3208      	adds	r2, #8
 800260c:	9204      	str	r2, [sp, #16]
 800260e:	9a03      	ldr	r2, [sp, #12]
 8002610:	3208      	adds	r2, #8
 8002612:	9203      	str	r2, [sp, #12]
 8002614:	9a02      	ldr	r2, [sp, #8]
 8002616:	3208      	adds	r2, #8
 8002618:	9202      	str	r2, [sp, #8]
 800261a:	9a01      	ldr	r2, [sp, #4]
 800261c:	3208      	adds	r2, #8
 800261e:	9201      	str	r2, [sp, #4]
 8002620:	9a09      	ldr	r2, [sp, #36]	@ 0x24
         j++;
 8002622:	f109 0901 	add.w	r9, r9, #1
      } while (j < n2);
 8002626:	454a      	cmp	r2, r9
 8002628:	f47f ae8c 	bne.w	8002344 <arm_radix8_butterfly_f32+0x274>

      twidCoefModifier <<= 3;
 800262c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800262e:	00db      	lsls	r3, r3, #3
 8002630:	b29b      	uxth	r3, r3
 8002632:	930a      	str	r3, [sp, #40]	@ 0x28
      n2 = n2 >> 3;
 8002634:	4693      	mov	fp, r2
 8002636:	e55a      	b.n	80020ee <arm_radix8_butterfly_f32+0x1e>
   } while (n2 > 7);
}
 8002638:	b00f      	add	sp, #60	@ 0x3c
 800263a:	ecbd 8b10 	vpop	{d8-d15}
 800263e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002642:	bf00      	nop

08002644 <arm_rfft_fast_f32>:
ARM_DSP_ATTRIBUTE void arm_rfft_fast_f32(
  const arm_rfft_fast_instance_f32 * S,
  float32_t * p,
  float32_t * pOut,
  uint8_t ifftFlag)
{
 8002644:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002648:	4615      	mov	r5, r2
 800264a:	4607      	mov	r7, r0
 800264c:	460c      	mov	r4, r1
   const arm_cfft_instance_f32 * Sint = &(S->Sint);

   /* Calculation of Real FFT */
   if (ifftFlag)
 800264e:	461a      	mov	r2, r3
 8002650:	2b00      	cmp	r3, #0
 8002652:	d056      	beq.n	8002702 <arm_rfft_fast_f32+0xbe>
   xAR = pA[0];
 8002654:	edd1 7a00 	vldr	s15, [r1]
   xAI = pA[1];
 8002658:	edd1 6a01 	vldr	s13, [r1, #4]
 800265c:	8800      	ldrh	r0, [r0, #0]
 800265e:	6979      	ldr	r1, [r7, #20]
   *pOut++ = 0.5f * ( xAR + xAI );
 8002660:	ee37 7aa6 	vadd.f32	s14, s15, s13
   *pOut++ = 0.5f * ( xAR - xAI );
 8002664:	ee77 7ae6 	vsub.f32	s15, s15, s13
   *pOut++ = 0.5f * ( xAR + xAI );
 8002668:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
   k = (S->Sint).fftLen - 1;
 800266c:	1e43      	subs	r3, r0, #1
   *pOut++ = 0.5f * ( xAR + xAI );
 800266e:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( xAR - xAI );
 8002672:	ee67 7a84 	vmul.f32	s15, s15, s8
   while (k > 0)
 8002676:	2b00      	cmp	r3, #0
   *pOut++ = 0.5f * ( xAR + xAI );
 8002678:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( xAR - xAI );
 800267c:	edc5 7a01 	vstr	s15, [r5, #4]
   pB  =  p + 2*k ;
 8002680:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
   while (k > 0)
 8002684:	dd36      	ble.n	80026f4 <arm_rfft_fast_f32+0xb0>
 8002686:	f101 0e10 	add.w	lr, r1, #16
 800268a:	ebac 00c0 	sub.w	r0, ip, r0, lsl #3
 800268e:	f104 0110 	add.w	r1, r4, #16
 8002692:	f1ac 0c08 	sub.w	ip, ip, #8
 8002696:	f105 0610 	add.w	r6, r5, #16
      xBI =   pB[1]    ;
 800269a:	eddc 6a03 	vldr	s13, [ip, #12]
      xBR =   pB[0]    ;
 800269e:	eddc 7a02 	vldr	s15, [ip, #8]
      xAR =  pA[0];
 80026a2:	ed11 7a02 	vldr	s14, [r1, #-8]
      xAI =  pA[1];
 80026a6:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 80026aa:	ed1e 6a02 	vldr	s12, [lr, #-8]
      twI = *pCoeff++;
 80026ae:	ed5e 5a01 	vldr	s11, [lr, #-4]
      t1a = xAR - xBR ;
 80026b2:	ee77 4a67 	vsub.f32	s9, s14, s15
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80026b6:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80026ba:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80026be:	eee6 7a64 	vfms.f32	s15, s12, s9
   while (k > 0)
 80026c2:	f1ac 0c08 	sub.w	ip, ip, #8
 80026c6:	3608      	adds	r6, #8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80026c8:	eea5 7aa4 	vfma.f32	s14, s11, s9
   while (k > 0)
 80026cc:	4560      	cmp	r0, ip
 80026ce:	f10e 0e08 	add.w	lr, lr, #8
      t1b = xAI + xBI ;
 80026d2:	ee76 6a85 	vadd.f32	s13, s13, s10
   while (k > 0)
 80026d6:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80026da:	eee5 7ae6 	vfms.f32	s15, s11, s13
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80026de:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80026e2:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80026e6:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
 80026ea:	ed46 7a04 	vstr	s15, [r6, #-16]
      *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
 80026ee:	ed06 7a03 	vstr	s14, [r6, #-12]
   while (k > 0)
 80026f2:	d1d2      	bne.n	800269a <arm_rfft_fast_f32+0x56>
   {
      /*  Real FFT compression */
      merge_rfft_f32(S, p, pOut);
      /* Complex radix-4 IFFT process */
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 80026f4:	4629      	mov	r1, r5
 80026f6:	4638      	mov	r0, r7
 80026f8:	2301      	movs	r3, #1
      arm_cfft_f32( Sint, p, ifftFlag, 1);

      /*  Real FFT extraction */
      stage_rfft_f32(S, p, pOut);
   }
}
 80026fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      arm_cfft_f32( Sint, pOut, ifftFlag, 1);
 80026fe:	f7ff b951 	b.w	80019a4 <arm_cfft_f32>
      arm_cfft_f32( Sint, p, ifftFlag, 1);
 8002702:	2301      	movs	r3, #1
 8002704:	f7ff f94e 	bl	80019a4 <arm_cfft_f32>
   t1b = xBI + xAI  ;
 8002708:	edd4 7a01 	vldr	s15, [r4, #4]
   xBR = pB[0];
 800270c:	ed94 6a00 	vldr	s12, [r4]
   k = (S->Sint).fftLen - 1;
 8002710:	883e      	ldrh	r6, [r7, #0]
 8002712:	6978      	ldr	r0, [r7, #20]
   t1b = xBI + xAI  ;
 8002714:	ee77 7aa7 	vadd.f32	s15, s15, s15
   *pOut++ = 0.5f * ( t1a + t1b );
 8002718:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 800271c:	eeb0 7a67 	vmov.f32	s14, s15
 8002720:	eea6 7a26 	vfma.f32	s14, s12, s13
   k = (S->Sint).fftLen - 1;
 8002724:	3e01      	subs	r6, #1
   *pOut++ = 0.5f * ( t1a + t1b );
 8002726:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
   *pOut++ = 0.5f * ( t1a - t1b );
 800272a:	eed6 7a26 	vfnms.f32	s15, s12, s13
 800272e:	3010      	adds	r0, #16
 8002730:	f105 0210 	add.w	r2, r5, #16
   *pOut++ = 0.5f * ( t1a + t1b );
 8002734:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 8002738:	ee27 7a04 	vmul.f32	s14, s14, s8
   *pOut++ = 0.5f * ( t1a - t1b );
 800273c:	ee67 7a84 	vmul.f32	s15, s15, s8
   *pOut++ = 0.5f * ( t1a + t1b );
 8002740:	ed85 7a00 	vstr	s14, [r5]
   *pOut++ = 0.5f * ( t1a - t1b );
 8002744:	edc5 7a01 	vstr	s15, [r5, #4]
   pA += 2;
 8002748:	f104 0110 	add.w	r1, r4, #16
 800274c:	3b08      	subs	r3, #8
      xAR = pA[0];
 800274e:	ed11 7a02 	vldr	s14, [r1, #-8]
      xBI = pB[1];
 8002752:	edd3 6a03 	vldr	s13, [r3, #12]
      xBR = pB[0];
 8002756:	edd3 7a02 	vldr	s15, [r3, #8]
      xAI = pA[1];
 800275a:	ed11 5a01 	vldr	s10, [r1, #-4]
      twR = *pCoeff++;
 800275e:	ed10 6a02 	vldr	s12, [r0, #-8]
      twI = *pCoeff++;
 8002762:	ed50 5a01 	vldr	s11, [r0, #-4]
      t1a = xBR - xAR ;
 8002766:	ee77 4ac7 	vsub.f32	s9, s15, s14
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 800276a:	ee77 7a87 	vadd.f32	s15, s15, s14
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 800276e:	ee35 7a66 	vsub.f32	s14, s10, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002772:	eee6 7a24 	vfma.f32	s15, s12, s9
      k--;
 8002776:	3e01      	subs	r6, #1
   } while (k > 0);
 8002778:	3208      	adds	r2, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 800277a:	eea5 7aa4 	vfma.f32	s14, s11, s9
   } while (k > 0);
 800277e:	2e00      	cmp	r6, #0
 8002780:	f100 0008 	add.w	r0, r0, #8
      t1b = xBI + xAI ;
 8002784:	ee76 6a85 	vadd.f32	s13, s13, s10
   } while (k > 0);
 8002788:	f101 0108 	add.w	r1, r1, #8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 800278c:	eee5 7aa6 	vfma.f32	s15, s11, s13
   } while (k > 0);
 8002790:	f1a3 0308 	sub.w	r3, r3, #8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 8002794:	eea6 7a66 	vfms.f32	s14, s12, s13
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 8002798:	ee67 7a84 	vmul.f32	s15, s15, s8
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 800279c:	ee27 7a04 	vmul.f32	s14, s14, s8
      *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
 80027a0:	ed42 7a04 	vstr	s15, [r2, #-16]
      *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
 80027a4:	ed02 7a03 	vstr	s14, [r2, #-12]
   } while (k > 0);
 80027a8:	dcd1      	bgt.n	800274e <arm_rfft_fast_f32+0x10a>
}
 80027aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80027ae:	bf00      	nop

080027b0 <arm_rfft_fast_init_256_f32>:
#else
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {

  arm_status status;

  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 80027b0:	b150      	cbz	r0, 80027c8 <arm_rfft_fast_init_256_f32+0x18>
ARM_DSP_ATTRIBUTE arm_status arm_rfft_fast_init_256_f32( arm_rfft_fast_instance_f32 * S ) {
 80027b2:	b510      	push	{r4, lr}
 80027b4:	4604      	mov	r4, r0

  status=arm_cfft_init_128_f32(&(S->Sint));
 80027b6:	f7ff fc7b 	bl	80020b0 <arm_cfft_init_128_f32>
  if (status != ARM_MATH_SUCCESS)
 80027ba:	b920      	cbnz	r0, 80027c6 <arm_rfft_fast_init_256_f32+0x16>
  {
    return(status);
  }
  S->fftLenRFFT = 256U;

  S->pTwiddleRFFT    = (float32_t *) twiddleCoef_rfft_256;
 80027bc:	4b04      	ldr	r3, [pc, #16]	@ (80027d0 <arm_rfft_fast_init_256_f32+0x20>)
 80027be:	6163      	str	r3, [r4, #20]
  S->fftLenRFFT = 256U;
 80027c0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80027c4:	8222      	strh	r2, [r4, #16]

  return ARM_MATH_SUCCESS;
}
 80027c6:	bd10      	pop	{r4, pc}
  if( !S ) return ARM_MATH_ARGUMENT_ERROR;
 80027c8:	f04f 30ff 	mov.w	r0, #4294967295
}
 80027cc:	4770      	bx	lr
 80027ce:	bf00      	nop
 80027d0:	08002ca4 	.word	0x08002ca4

080027d4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80027d4:	4a03      	ldr	r2, [pc, #12]	@ (80027e4 <HAL_IncTick+0x10>)
 80027d6:	4b04      	ldr	r3, [pc, #16]	@ (80027e8 <HAL_IncTick+0x14>)
 80027d8:	6811      	ldr	r1, [r2, #0]
 80027da:	781b      	ldrb	r3, [r3, #0]
 80027dc:	440b      	add	r3, r1
 80027de:	6013      	str	r3, [r2, #0]
}
 80027e0:	4770      	bx	lr
 80027e2:	bf00      	nop
 80027e4:	200016a4 	.word	0x200016a4
 80027e8:	20000000 	.word	0x20000000

080027ec <uart2_set_fcpu>:

unsigned long f_cpu;

/** Functions ----------------------------------------------------------------*/
void uart2_set_fcpu(unsigned long freq)
{
 80027ec:	b480      	push	{r7}
 80027ee:	b083      	sub	sp, #12
 80027f0:	af00      	add	r7, sp, #0
 80027f2:	6078      	str	r0, [r7, #4]
	f_cpu = freq;
 80027f4:	4a04      	ldr	r2, [pc, #16]	@ (8002808 <uart2_set_fcpu+0x1c>)
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	6013      	str	r3, [r2, #0]
}
 80027fa:	bf00      	nop
 80027fc:	370c      	adds	r7, #12
 80027fe:	46bd      	mov	sp, r7
 8002800:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002804:	4770      	bx	lr
 8002806:	bf00      	nop
 8002808:	200016a8 	.word	0x200016a8

0800280c <uart2_dma1_config>:

	return USART_OK;
}

uart_err_type_t uart2_dma1_config(uint32_t baud, uart_data_type_t ndata, uart_stop_type_t nstop)
{
 800280c:	b5b0      	push	{r4, r5, r7, lr}
 800280e:	b086      	sub	sp, #24
 8002810:	af00      	add	r7, sp, #0
 8002812:	60f8      	str	r0, [r7, #12]
 8002814:	460b      	mov	r3, r1
 8002816:	72fb      	strb	r3, [r7, #11]
 8002818:	4613      	mov	r3, r2
 800281a:	72bb      	strb	r3, [r7, #10]
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;	// enable UART2 clock
 800281c:	4b85      	ldr	r3, [pc, #532]	@ (8002a34 <uart2_dma1_config+0x228>)
 800281e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002820:	4a84      	ldr	r2, [pc, #528]	@ (8002a34 <uart2_dma1_config+0x228>)
 8002822:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8002826:	6413      	str	r3, [r2, #64]	@ 0x40
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;	// enable GPIOA clock
 8002828:	4b82      	ldr	r3, [pc, #520]	@ (8002a34 <uart2_dma1_config+0x228>)
 800282a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800282c:	4a81      	ldr	r2, [pc, #516]	@ (8002a34 <uart2_dma1_config+0x228>)
 800282e:	f043 0301 	orr.w	r3, r3, #1
 8002832:	6313      	str	r3, [r2, #48]	@ 0x30
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;		// enable DMA1 clock
 8002834:	4b7f      	ldr	r3, [pc, #508]	@ (8002a34 <uart2_dma1_config+0x228>)
 8002836:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002838:	4a7e      	ldr	r2, [pc, #504]	@ (8002a34 <uart2_dma1_config+0x228>)
 800283a:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800283e:	6313      	str	r3, [r2, #48]	@ 0x30

	/* Setup DMA1 for transmission */
	// disable DMA1 to configure
	DMA1_Stream6->CR &= ~DMA_SxCR_EN;
 8002840:	4b7d      	ldr	r3, [pc, #500]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002842:	681b      	ldr	r3, [r3, #0]
 8002844:	4a7c      	ldr	r2, [pc, #496]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002846:	f023 0301 	bic.w	r3, r3, #1
 800284a:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 800284c:	bf00      	nop
 800284e:	4b7a      	ldr	r3, [pc, #488]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002850:	681b      	ldr	r3, [r3, #0]
 8002852:	f003 0301 	and.w	r3, r3, #1
 8002856:	2b00      	cmp	r3, #0
 8002858:	d1f9      	bne.n	800284e <uart2_dma1_config+0x42>

	// select stream 6, channel 4 for USART2_TX
	DMA1_Stream6->CR &= ~DMA_SxCR_CHSEL;
 800285a:	4b77      	ldr	r3, [pc, #476]	@ (8002a38 <uart2_dma1_config+0x22c>)
 800285c:	681b      	ldr	r3, [r3, #0]
 800285e:	4a76      	ldr	r2, [pc, #472]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002860:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
 8002864:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_CHSEL_2;
 8002866:	4b74      	ldr	r3, [pc, #464]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002868:	681b      	ldr	r3, [r3, #0]
 800286a:	4a73      	ldr	r2, [pc, #460]	@ (8002a38 <uart2_dma1_config+0x22c>)
 800286c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8002870:	6013      	str	r3, [r2, #0]

	// disable direct mode
	DMA1_Stream6->FCR |= DMA_SxFCR_DMDIS;
 8002872:	4b71      	ldr	r3, [pc, #452]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002874:	695b      	ldr	r3, [r3, #20]
 8002876:	4a70      	ldr	r2, [pc, #448]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002878:	f043 0304 	orr.w	r3, r3, #4
 800287c:	6153      	str	r3, [r2, #20]

	// normal mode, low priority, 1 byte data size (memory and peripheral)
	DMA1_Stream6->CR &= ~(DMA_SxCR_DBM | DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE);
 800287e:	4b6e      	ldr	r3, [pc, #440]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002880:	681b      	ldr	r3, [r3, #0]
 8002882:	4a6d      	ldr	r2, [pc, #436]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002884:	f423 23ef 	bic.w	r3, r3, #489472	@ 0x77800
 8002888:	6013      	str	r3, [r2, #0]

	// memory increment mode
	DMA1_Stream6->CR |= DMA_SxCR_MINC;
 800288a:	4b6b      	ldr	r3, [pc, #428]	@ (8002a38 <uart2_dma1_config+0x22c>)
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	4a6a      	ldr	r2, [pc, #424]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002890:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8002894:	6013      	str	r3, [r2, #0]

	// fixed peripheral pointer
	DMA1_Stream6->CR &= ~DMA_SxCR_PINC;
 8002896:	4b68      	ldr	r3, [pc, #416]	@ (8002a38 <uart2_dma1_config+0x22c>)
 8002898:	681b      	ldr	r3, [r3, #0]
 800289a:	4a67      	ldr	r2, [pc, #412]	@ (8002a38 <uart2_dma1_config+0x22c>)
 800289c:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 80028a0:	6013      	str	r3, [r2, #0]

	// disable circular mode
	DMA1_Stream6->CR &= ~DMA_SxCR_CIRC;
 80028a2:	4b65      	ldr	r3, [pc, #404]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028a4:	681b      	ldr	r3, [r3, #0]
 80028a6:	4a64      	ldr	r2, [pc, #400]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028a8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 80028ac:	6013      	str	r3, [r2, #0]

	// memory to peripheral mode
	DMA1_Stream6->CR &= ~DMA_SxCR_DIR_1;
 80028ae:	4b62      	ldr	r3, [pc, #392]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028b0:	681b      	ldr	r3, [r3, #0]
 80028b2:	4a61      	ldr	r2, [pc, #388]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028b4:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80028b8:	6013      	str	r3, [r2, #0]
	DMA1_Stream6->CR |= DMA_SxCR_DIR_0;
 80028ba:	4b5f      	ldr	r3, [pc, #380]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028bc:	681b      	ldr	r3, [r3, #0]
 80028be:	4a5e      	ldr	r2, [pc, #376]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028c0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80028c4:	6013      	str	r3, [r2, #0]

	// peripheral address is USART2_DR
	DMA1_Stream6->PAR = (uint32_t)&(USART2->DR);
 80028c6:	4b5c      	ldr	r3, [pc, #368]	@ (8002a38 <uart2_dma1_config+0x22c>)
 80028c8:	4a5c      	ldr	r2, [pc, #368]	@ (8002a3c <uart2_dma1_config+0x230>)
 80028ca:	609a      	str	r2, [r3, #8]

	/* Setup UART2 for transmission using DMA1 */
	// alternate function mode on TX (PA2) and RX (PA3)
	GPIOA->MODER |= GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;
 80028cc:	4b5c      	ldr	r3, [pc, #368]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028ce:	681b      	ldr	r3, [r3, #0]
 80028d0:	4a5b      	ldr	r2, [pc, #364]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028d2:	f043 03a0 	orr.w	r3, r3, #160	@ 0xa0
 80028d6:	6013      	str	r3, [r2, #0]
	GPIOA->MODER &= ~(GPIO_MODER_MODER2_0 | GPIO_MODER_MODER3_0);
 80028d8:	4b59      	ldr	r3, [pc, #356]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028da:	681b      	ldr	r3, [r3, #0]
 80028dc:	4a58      	ldr	r2, [pc, #352]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028de:	f023 0350 	bic.w	r3, r3, #80	@ 0x50
 80028e2:	6013      	str	r3, [r2, #0]

	// select alternate function mode 7 for each
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL2 | GPIO_AFRL_AFRL3);
 80028e4:	4b56      	ldr	r3, [pc, #344]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028e6:	6a1b      	ldr	r3, [r3, #32]
 80028e8:	4a55      	ldr	r2, [pc, #340]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028ea:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80028ee:	6213      	str	r3, [r2, #32]
	GPIOA->AFR[0] |= GPIO_AFRL_AFRL2_0 | GPIO_AFRL_AFRL3_0 |
 80028f0:	4b53      	ldr	r3, [pc, #332]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028f2:	6a1b      	ldr	r3, [r3, #32]
 80028f4:	4a52      	ldr	r2, [pc, #328]	@ (8002a40 <uart2_dma1_config+0x234>)
 80028f6:	f443 43ee 	orr.w	r3, r3, #30464	@ 0x7700
 80028fa:	6213      	str	r3, [r2, #32]
					GPIO_AFRL_AFRL2_1 | GPIO_AFRL_AFRL3_1 |
					GPIO_AFRL_AFRL2_2 | GPIO_AFRL_AFRL3_2;

	USART2->CR1 |= USART_CR1_UE;			// UART2 enable
 80028fc:	4b51      	ldr	r3, [pc, #324]	@ (8002a44 <uart2_dma1_config+0x238>)
 80028fe:	68db      	ldr	r3, [r3, #12]
 8002900:	4a50      	ldr	r2, [pc, #320]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002902:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002906:	60d3      	str	r3, [r2, #12]

	if (ndata == USART_DATA_8)
 8002908:	7afb      	ldrb	r3, [r7, #11]
 800290a:	2b00      	cmp	r3, #0
 800290c:	d106      	bne.n	800291c <uart2_dma1_config+0x110>
	{
		USART2->CR1 &= ~USART_CR1_M;		// 1 start, 8 data, n stop
 800290e:	4b4d      	ldr	r3, [pc, #308]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002910:	68db      	ldr	r3, [r3, #12]
 8002912:	4a4c      	ldr	r2, [pc, #304]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002914:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8002918:	60d3      	str	r3, [r2, #12]
 800291a:	e00b      	b.n	8002934 <uart2_dma1_config+0x128>
	}
	else if (ndata == USART_DATA_9)
 800291c:	7afb      	ldrb	r3, [r7, #11]
 800291e:	2b01      	cmp	r3, #1
 8002920:	d106      	bne.n	8002930 <uart2_dma1_config+0x124>
	{
		USART2->CR1 |= USART_CR1_M;			// 1 start, 9 data, n stop
 8002922:	4b48      	ldr	r3, [pc, #288]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002924:	68db      	ldr	r3, [r3, #12]
 8002926:	4a47      	ldr	r2, [pc, #284]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002928:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800292c:	60d3      	str	r3, [r2, #12]
 800292e:	e001      	b.n	8002934 <uart2_dma1_config+0x128>
	}
	else
	{
		return USART_INVALID_NDATA;
 8002930:	2302      	movs	r3, #2
 8002932:	e07b      	b.n	8002a2c <uart2_dma1_config+0x220>
	}

	if (nstop == USART_STOP_1)
 8002934:	7abb      	ldrb	r3, [r7, #10]
 8002936:	2b00      	cmp	r3, #0
 8002938:	d106      	bne.n	8002948 <uart2_dma1_config+0x13c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 1 stop bit
 800293a:	4b42      	ldr	r3, [pc, #264]	@ (8002a44 <uart2_dma1_config+0x238>)
 800293c:	691b      	ldr	r3, [r3, #16]
 800293e:	4a41      	ldr	r2, [pc, #260]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002940:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002944:	6113      	str	r3, [r2, #16]
 8002946:	e021      	b.n	800298c <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_HALF)
 8002948:	7abb      	ldrb	r3, [r7, #10]
 800294a:	2b01      	cmp	r3, #1
 800294c:	d10c      	bne.n	8002968 <uart2_dma1_config+0x15c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// half stop bit
 800294e:	4b3d      	ldr	r3, [pc, #244]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002950:	691b      	ldr	r3, [r3, #16]
 8002952:	4a3c      	ldr	r2, [pc, #240]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002954:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002958:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_0;
 800295a:	4b3a      	ldr	r3, [pc, #232]	@ (8002a44 <uart2_dma1_config+0x238>)
 800295c:	691b      	ldr	r3, [r3, #16]
 800295e:	4a39      	ldr	r2, [pc, #228]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002960:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8002964:	6113      	str	r3, [r2, #16]
 8002966:	e011      	b.n	800298c <uart2_dma1_config+0x180>
	}
	else if (nstop == USART_STOP_2)
 8002968:	7abb      	ldrb	r3, [r7, #10]
 800296a:	2b02      	cmp	r3, #2
 800296c:	d10c      	bne.n	8002988 <uart2_dma1_config+0x17c>
	{
		USART2->CR2 &= ~USART_CR2_STOP;		// 2 stop bits
 800296e:	4b35      	ldr	r3, [pc, #212]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002970:	691b      	ldr	r3, [r3, #16]
 8002972:	4a34      	ldr	r2, [pc, #208]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002974:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 8002978:	6113      	str	r3, [r2, #16]
		USART2->CR2 |= USART_CR2_STOP_1;
 800297a:	4b32      	ldr	r3, [pc, #200]	@ (8002a44 <uart2_dma1_config+0x238>)
 800297c:	691b      	ldr	r3, [r3, #16]
 800297e:	4a31      	ldr	r2, [pc, #196]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002980:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 8002984:	6113      	str	r3, [r2, #16]
 8002986:	e001      	b.n	800298c <uart2_dma1_config+0x180>
	}
	else
	{
		return USART_INVALID_NSTOP;
 8002988:	2301      	movs	r3, #1
 800298a:	e04f      	b.n	8002a2c <uart2_dma1_config+0x220>
	}

	// pg. 519 STM32F401RE reference
	float usart_div = f_cpu / (2 * 16.0 * baud);		// APB1 bus is 1/2 clock speed of f_cpu
 800298c:	4b2e      	ldr	r3, [pc, #184]	@ (8002a48 <uart2_dma1_config+0x23c>)
 800298e:	681b      	ldr	r3, [r3, #0]
 8002990:	4618      	mov	r0, r3
 8002992:	f7fd fd63 	bl	800045c <__aeabi_ui2d>
 8002996:	4604      	mov	r4, r0
 8002998:	460d      	mov	r5, r1
 800299a:	68f8      	ldr	r0, [r7, #12]
 800299c:	f7fd fd5e 	bl	800045c <__aeabi_ui2d>
 80029a0:	f04f 0200 	mov.w	r2, #0
 80029a4:	4b29      	ldr	r3, [pc, #164]	@ (8002a4c <uart2_dma1_config+0x240>)
 80029a6:	f7fd fdd3 	bl	8000550 <__aeabi_dmul>
 80029aa:	4602      	mov	r2, r0
 80029ac:	460b      	mov	r3, r1
 80029ae:	4620      	mov	r0, r4
 80029b0:	4629      	mov	r1, r5
 80029b2:	f7fd fef7 	bl	80007a4 <__aeabi_ddiv>
 80029b6:	4602      	mov	r2, r0
 80029b8:	460b      	mov	r3, r1
 80029ba:	4610      	mov	r0, r2
 80029bc:	4619      	mov	r1, r3
 80029be:	f7fe f861 	bl	8000a84 <__aeabi_d2f>
 80029c2:	4603      	mov	r3, r0
 80029c4:	617b      	str	r3, [r7, #20]
	uint16_t mantissa = (uint16_t) usart_div;
 80029c6:	edd7 7a05 	vldr	s15, [r7, #20]
 80029ca:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80029ce:	ee17 3a90 	vmov	r3, s15
 80029d2:	827b      	strh	r3, [r7, #18]
	uint8_t fraction = (uint8_t) ((usart_div - mantissa) * 16);
 80029d4:	8a7b      	ldrh	r3, [r7, #18]
 80029d6:	ee07 3a90 	vmov	s15, r3
 80029da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80029de:	ed97 7a05 	vldr	s14, [r7, #20]
 80029e2:	ee77 7a67 	vsub.f32	s15, s14, s15
 80029e6:	eeb3 7a00 	vmov.f32	s14, #48	@ 0x41800000  16.0
 80029ea:	ee67 7a87 	vmul.f32	s15, s15, s14
 80029ee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80029f2:	edc7 7a01 	vstr	s15, [r7, #4]
 80029f6:	793b      	ldrb	r3, [r7, #4]
 80029f8:	747b      	strb	r3, [r7, #17]
	USART2->BRR = mantissa << 4 | fraction;
 80029fa:	8a7b      	ldrh	r3, [r7, #18]
 80029fc:	011a      	lsls	r2, r3, #4
 80029fe:	7c7b      	ldrb	r3, [r7, #17]
 8002a00:	431a      	orrs	r2, r3
 8002a02:	4b10      	ldr	r3, [pc, #64]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a04:	609a      	str	r2, [r3, #8]

	USART2->CR3 |= USART_CR3_DMAT;		// enable DMA transmitter
 8002a06:	4b0f      	ldr	r3, [pc, #60]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a08:	695b      	ldr	r3, [r3, #20]
 8002a0a:	4a0e      	ldr	r2, [pc, #56]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a0c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002a10:	6153      	str	r3, [r2, #20]

	USART2->CR1 |= USART_CR1_TE;		// transmitter enable
 8002a12:	4b0c      	ldr	r3, [pc, #48]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a14:	68db      	ldr	r3, [r3, #12]
 8002a16:	4a0b      	ldr	r2, [pc, #44]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a18:	f043 0308 	orr.w	r3, r3, #8
 8002a1c:	60d3      	str	r3, [r2, #12]
	USART2->CR1 |= USART_CR1_RE;		// receiver enable
 8002a1e:	4b09      	ldr	r3, [pc, #36]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a20:	68db      	ldr	r3, [r3, #12]
 8002a22:	4a08      	ldr	r2, [pc, #32]	@ (8002a44 <uart2_dma1_config+0x238>)
 8002a24:	f043 0304 	orr.w	r3, r3, #4
 8002a28:	60d3      	str	r3, [r2, #12]

	return USART_OK;
 8002a2a:	2300      	movs	r3, #0
}
 8002a2c:	4618      	mov	r0, r3
 8002a2e:	3718      	adds	r7, #24
 8002a30:	46bd      	mov	sp, r7
 8002a32:	bdb0      	pop	{r4, r5, r7, pc}
 8002a34:	40023800 	.word	0x40023800
 8002a38:	400260a0 	.word	0x400260a0
 8002a3c:	40004404 	.word	0x40004404
 8002a40:	40020000 	.word	0x40020000
 8002a44:	40004400 	.word	0x40004400
 8002a48:	200016a8 	.word	0x200016a8
 8002a4c:	40400000 	.word	0x40400000

08002a50 <uart2_dma1_write>:

	return USART_OK;
}

void uart2_dma1_write(uint16_t n, uint8_t * data)
{
 8002a50:	b480      	push	{r7}
 8002a52:	b083      	sub	sp, #12
 8002a54:	af00      	add	r7, sp, #0
 8002a56:	4603      	mov	r3, r0
 8002a58:	6039      	str	r1, [r7, #0]
 8002a5a:	80fb      	strh	r3, [r7, #6]
	while (!(USART2->SR & USART_SR_TXE));	// wait for transmit data register empty
 8002a5c:	bf00      	nop
 8002a5e:	4b18      	ldr	r3, [pc, #96]	@ (8002ac0 <uart2_dma1_write+0x70>)
 8002a60:	681b      	ldr	r3, [r3, #0]
 8002a62:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	d0f9      	beq.n	8002a5e <uart2_dma1_write+0xe>
	USART2->SR &= ~USART_SR_TC;				// clear flag
 8002a6a:	4b15      	ldr	r3, [pc, #84]	@ (8002ac0 <uart2_dma1_write+0x70>)
 8002a6c:	681b      	ldr	r3, [r3, #0]
 8002a6e:	4a14      	ldr	r2, [pc, #80]	@ (8002ac0 <uart2_dma1_write+0x70>)
 8002a70:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8002a74:	6013      	str	r3, [r2, #0]

	DMA1_Stream6->CR &= ~DMA_SxCR_EN;		// disable DMA stream
 8002a76:	4b13      	ldr	r3, [pc, #76]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002a78:	681b      	ldr	r3, [r3, #0]
 8002a7a:	4a12      	ldr	r2, [pc, #72]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002a7c:	f023 0301 	bic.w	r3, r3, #1
 8002a80:	6013      	str	r3, [r2, #0]
	while (DMA1_Stream6->CR & DMA_SxCR_EN);
 8002a82:	bf00      	nop
 8002a84:	4b0f      	ldr	r3, [pc, #60]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002a86:	681b      	ldr	r3, [r3, #0]
 8002a88:	f003 0301 	and.w	r3, r3, #1
 8002a8c:	2b00      	cmp	r3, #0
 8002a8e:	d1f9      	bne.n	8002a84 <uart2_dma1_write+0x34>

	// clear flags
	DMA1->HIFCR |= DMA_HIFCR_CTCIF6 | DMA_HIFCR_CHTIF6 | DMA_HIFCR_CTEIF6 | DMA_HIFCR_CDMEIF6 | DMA_HIFCR_CFEIF6;
 8002a90:	4b0d      	ldr	r3, [pc, #52]	@ (8002ac8 <uart2_dma1_write+0x78>)
 8002a92:	68db      	ldr	r3, [r3, #12]
 8002a94:	4a0c      	ldr	r2, [pc, #48]	@ (8002ac8 <uart2_dma1_write+0x78>)
 8002a96:	f443 1374 	orr.w	r3, r3, #3997696	@ 0x3d0000
 8002a9a:	60d3      	str	r3, [r2, #12]

	DMA1_Stream6->NDTR = n;					// set # of data items to transfer
 8002a9c:	4a09      	ldr	r2, [pc, #36]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002a9e:	88fb      	ldrh	r3, [r7, #6]
 8002aa0:	6053      	str	r3, [r2, #4]
	DMA1_Stream6->M0AR = (uint32_t) data;	// pointer to data
 8002aa2:	4a08      	ldr	r2, [pc, #32]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002aa4:	683b      	ldr	r3, [r7, #0]
 8002aa6:	60d3      	str	r3, [r2, #12]
	DMA1_Stream6->CR |= DMA_SxCR_EN;		// enable DMA stream
 8002aa8:	4b06      	ldr	r3, [pc, #24]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002aaa:	681b      	ldr	r3, [r3, #0]
 8002aac:	4a05      	ldr	r2, [pc, #20]	@ (8002ac4 <uart2_dma1_write+0x74>)
 8002aae:	f043 0301 	orr.w	r3, r3, #1
 8002ab2:	6013      	str	r3, [r2, #0]
}
 8002ab4:	bf00      	nop
 8002ab6:	370c      	adds	r7, #12
 8002ab8:	46bd      	mov	sp, r7
 8002aba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002abe:	4770      	bx	lr
 8002ac0:	40004400 	.word	0x40004400
 8002ac4:	400260a0 	.word	0x400260a0
 8002ac8:	40026000 	.word	0x40026000

08002acc <memset>:
 8002acc:	4402      	add	r2, r0
 8002ace:	4603      	mov	r3, r0
 8002ad0:	4293      	cmp	r3, r2
 8002ad2:	d100      	bne.n	8002ad6 <memset+0xa>
 8002ad4:	4770      	bx	lr
 8002ad6:	f803 1b01 	strb.w	r1, [r3], #1
 8002ada:	e7f9      	b.n	8002ad0 <memset+0x4>

08002adc <__libc_init_array>:
 8002adc:	b570      	push	{r4, r5, r6, lr}
 8002ade:	4d0d      	ldr	r5, [pc, #52]	@ (8002b14 <__libc_init_array+0x38>)
 8002ae0:	4c0d      	ldr	r4, [pc, #52]	@ (8002b18 <__libc_init_array+0x3c>)
 8002ae2:	1b64      	subs	r4, r4, r5
 8002ae4:	10a4      	asrs	r4, r4, #2
 8002ae6:	2600      	movs	r6, #0
 8002ae8:	42a6      	cmp	r6, r4
 8002aea:	d109      	bne.n	8002b00 <__libc_init_array+0x24>
 8002aec:	4d0b      	ldr	r5, [pc, #44]	@ (8002b1c <__libc_init_array+0x40>)
 8002aee:	4c0c      	ldr	r4, [pc, #48]	@ (8002b20 <__libc_init_array+0x44>)
 8002af0:	f000 f818 	bl	8002b24 <_init>
 8002af4:	1b64      	subs	r4, r4, r5
 8002af6:	10a4      	asrs	r4, r4, #2
 8002af8:	2600      	movs	r6, #0
 8002afa:	42a6      	cmp	r6, r4
 8002afc:	d105      	bne.n	8002b0a <__libc_init_array+0x2e>
 8002afe:	bd70      	pop	{r4, r5, r6, pc}
 8002b00:	f855 3b04 	ldr.w	r3, [r5], #4
 8002b04:	4798      	blx	r3
 8002b06:	3601      	adds	r6, #1
 8002b08:	e7ee      	b.n	8002ae8 <__libc_init_array+0xc>
 8002b0a:	f855 3b04 	ldr.w	r3, [r5], #4
 8002b0e:	4798      	blx	r3
 8002b10:	3601      	adds	r6, #1
 8002b12:	e7f2      	b.n	8002afa <__libc_init_array+0x1e>
 8002b14:	08003654 	.word	0x08003654
 8002b18:	08003654 	.word	0x08003654
 8002b1c:	08003654 	.word	0x08003654
 8002b20:	08003658 	.word	0x08003658

08002b24 <_init>:
 8002b24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b26:	bf00      	nop
 8002b28:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002b2a:	bc08      	pop	{r3}
 8002b2c:	469e      	mov	lr, r3
 8002b2e:	4770      	bx	lr

08002b30 <_fini>:
 8002b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b32:	bf00      	nop
 8002b34:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002b36:	bc08      	pop	{r3}
 8002b38:	469e      	mov	lr, r3
 8002b3a:	4770      	bx	lr
